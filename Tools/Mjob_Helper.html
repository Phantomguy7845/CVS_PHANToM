<!--
  File: Selfie_TimeLogger_MintLight.html
  Single-file web app (HTML/CSS/JS) ‚Äî Selfie + Time Logger (Mint Light style)
  Host on GitHub Pages (no backend). Uses IndexedDB (Dexie preferred; native fallback)

  ‚úÖ Latest fixes implemented per your checklist:
  1) Schedule / Missing-tag (‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ) = "horizon-based"
     - ‡∏à‡∏∞‡πÇ‡∏ä‡∏ß‡πå ‚Äú‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ IN-x/OUT-x‚Äù ‡∏Å‡πá‡∏ï‡πà‡∏≠‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ô‡∏±‡πâ‡∏ô ‚Äú‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏ñ‡∏∂‡∏á target (+9:10)‚Äù
     - ‡∏ñ‡πâ‡∏≤‡∏£‡∏π‡∏õ‡∏ó‡∏µ‡πà‡∏°‡∏µ ‚Äú‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á target‚Äù => ‡πÑ‡∏°‡πà‡πÇ‡∏ä‡∏ß‡πå‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ, Header ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Next tag + ‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥

  2) Download ‡∏ã‡πâ‡∏≥‡πÑ‡∏î‡πâ ‡πÅ‡∏ï‡πà "‡πÑ‡∏°‡πà‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏ú‡∏ô‡πÄ‡∏ß‡∏•‡∏≤"
     - ‡∏Å‡∏î Download ‡∏ã‡πâ‡∏≥: ‡πÑ‡∏°‡πà‡πÅ‡∏Å‡πâ downloadedAt ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
     - ‡∏ï‡∏±‡∏ß‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô/‡πÅ‡∏ú‡∏ô‡∏¢‡∏∂‡∏î‡∏Å‡∏≤‡∏£ ‚Äú‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡∏ô‡∏±‡πâ‡∏ô‚Äù ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô

  3) Alarm UI ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏î‡πà‡∏ô
     - ‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ö‡πÅ‡∏î‡∏á‡πÉ‡∏´‡∏ç‡πà => ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô toast ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡πÅ‡∏ö‡∏ö Mint (‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ/auto-hide)
     - ‡∏¢‡∏±‡∏á‡∏°‡∏µ best-effort: Notification (‡∏ñ‡πâ‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï) + vibrate + beep (‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)

  4) Header ‡∏ö‡∏±‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤
     - ‡πÉ‡∏ä‡πâ ResizeObserver ‡∏ß‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á topBar/stickyBar ‡πÅ‡∏ö‡∏ö real-time
     - body padding-top/padding-bottom ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏ï‡∏•‡∏≠‡∏î

  5) UI update ‡∏ä‡πâ‡∏≤/‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏á Download
     - ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£ render ‡∏´‡∏ô‡∏±‡∏Å‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥
     - ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô:
       - heavyRender(): ‡∏™‡∏£‡πâ‡∏≤‡∏á list/‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏ú‡∏ô‡πÄ‡∏ï‡πá‡∏° (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô)
       - lightTick(): ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏Ñ‡πà countdown/‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥ ‡πÄ‡∏ö‡∏≤‡∏°‡∏≤‡∏Å)

  6) Downloaded list ‡∏ã‡πà‡∏≠‡∏ô‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô ‚ÄúDrawer ‡∏™‡πÑ‡∏•‡∏î‡πå‚Äù
     - ‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏° ‚Äú‚úÖ Downloaded(x)‚Äù ‡πÉ‡∏ô Header ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Drawer

  7) ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° Edit ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ ‚ÄúPending‚Äù
     - ‡∏õ‡∏∏‡πà‡∏° ‚úèÔ∏è ‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏≠‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î Time use
     - ‡∏Å‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡πà‡∏≤‡∏¢/‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠ ‚Äú‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏ô slot ‡πÄ‡∏î‡∏¥‡∏°‚Äù (tag/kind/idx/createdAt ‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°)
     - Downloaded ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏î Edit ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏´‡∏ô‡∏î

  -----------------------------------------
  DB Schema (Dexie):
    photos: ++id, tag, kind, idx, createdAt, downloaded, downloadedAt, editedAt, blob, mime, width, height, size

  Tag assignment:
    - "‡πÄ‡∏ï‡∏¥‡∏°‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏Å‡πà‡∏≠‡∏ô" = ‡∏´‡∏≤ slot ‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (IN ‡∏Å‡πà‡∏≠‡∏ô OUT)
    - ‡∏•‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏•‡πâ‡∏ß slot ‡∏ß‡πà‡∏≤‡∏á => ‡∏ñ‡πà‡∏≤‡∏¢/‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡∏°‡πà‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏ï‡∏¥‡∏° slot ‡∏ô‡∏±‡πâ‡∏ô

  Mark downloaded + move list:
    - ‡∏Å‡∏î Download ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å: downloaded=1, downloadedAt=now
    - ‡∏Å‡∏î Download ‡∏ã‡πâ‡∏≥: ‡πÑ‡∏°‡πà‡πÅ‡∏Å‡πâ downloadedAt (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï schedule)

  9:10 Timer lock:
    - ‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà 1: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö + ‡∏•‡πá‡∏≠‡∏Ñ + ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô "‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î HH:MM"
    - ‡∏Å‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà 2: ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠ UNLOCKED ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á 3 ‡∏ß‡∏¥‡∏´‡∏•‡∏±‡∏á ‚Äúüîì ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‚Äù
    - Auto unlock ‡πÄ‡∏°‡∏∑‡πà‡∏≠ downloadedCount >= 40

  Notification + fallback + catch-up:
    - ‡πÑ‡∏°‡πà‡∏°‡∏µ backend/push => ‡∏ô‡∏≠‡∏Å Chrome/‡∏õ‡∏¥‡∏î‡πÅ‡∏ó‡πá‡∏ö "‡πÑ‡∏°‡πà‡∏Å‡∏≤‡∏£‡∏±‡∏ô‡∏ï‡∏µ"
    - ‡πÉ‡∏ô‡πÅ‡∏≠‡∏õ: setTimeout + catch-up ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡∏¥‡∏î (‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏Ç‡∏∂‡πâ‡∏ô toast ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ)
-->

<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#dff7ef" />
  <title>Selfie + Time Logger (Mint Light)</title>

  <!-- Optional: Noto Sans Thai -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;600;700;900&display=swap" rel="stylesheet">

  <!-- Dexie via CDN (preferred) -->
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.5/dist/dexie.min.js"></script>

  <style>
    :root{
      --bg:#f6fffb;
      --card:#ffffff;
      --line:#d7efe7;
      --text:#0e2a23;
      --muted:#557c72;
      --muted2:#7aa39a;
      --accent:#1fbf9a;
      --soft:#e7fbf4;
      --warn:#ffb020;
      --danger:#ff4d4f;
      --shadow:0 10px 28px rgba(14,42,35,.10);
      --radius:18px;

      --stickH: 0px;
      --topH: 0px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", Arial, sans-serif;
      -webkit-tap-highlight-color: transparent;

      padding-top: calc(var(--topH) + 10px);
      padding-bottom: calc(var(--stickH) + 12px);
    }

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 0 14px 24px;
    }

    .mini{ font-size: 12px; color: var(--muted2); }
    .muted{ color: var(--muted); }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      margin: 12px 0;
    }
    .card h2{
      margin:0 0 10px;
      font-size: 14px;
      letter-spacing: .2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row.spread{ justify-content:space-between; }

    .grid2{ display:grid; grid-template-columns: 1fr; gap: 10px; }
    .grid3{ display:grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 720px){
      .grid2{ grid-template-columns: 1fr 1fr; }
      .grid3{ grid-template-columns: 1fr 1fr 1fr; }
    }

    .btn{
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 14px;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(14,42,35,.10);
      user-select:none;
      touch-action: manipulation;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      min-height: 44px;
      width: 100%;
      white-space: nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }

    .btn.primary{
      background: linear-gradient(180deg, #26d7ae, #17b892);
      border-color: rgba(0,0,0,.0);
      color: #062a22;
    }
    .btn.soft{
      background: var(--soft);
      border-color: #c8efe3;
    }
    .btn.danger{
      background: #fff1f1;
      border-color: #ffd1d1;
      color: #7c1313;
    }
    .btn.warn{
      background: #fff7e6;
      border-color: #ffe2ad;
      color: #7a4e00;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #fbfffd;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 900;
      border: 1px solid var(--line);
      background: #fbfffd;
      white-space: nowrap;
    }
    .badge.ok{ background: #e7fbf4; border-color:#bfeee0; color:#0b5f4a; }
    .badge.wait{ background: #fff7e6; border-color:#ffe2ad; color:#7a4e00; }
    .badge.err{ background: #fff1f1; border-color:#ffd1d1; color:#7c1313; }

    .switch{
      display:flex;
      align-items:center;
      gap:10px;
      border: 1px solid var(--line);
      background: #fbfffd;
      padding: 10px 12px;
      border-radius: 14px;
    }
    .switch input{ width: 22px; height: 22px; }

    .progressWrap{
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: #eaf8f2;
      border: 1px solid #cfeee4;
      overflow:hidden;
    }
    .progressBar{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #26d7ae, #17b892);
      border-radius: 999px;
      transition: width .25s ease;
    }

    .list{ display:flex; flex-direction:column; gap:10px; }

    .photoItem{
      display:grid;
      grid-template-columns: 92px 1fr;
      gap: 10px;
      padding: 10px;
      border: 1px solid var(--line);
      background: #fbfffd;
      border-radius: 16px;
    }
    .thumb{
      width: 92px;
      height: 92px;
      border-radius: 16px;
      border: 1px solid var(--line);
      object-fit: cover;
      background: #0b1d18;
    }
    .info{ display:flex; flex-direction:column; gap:8px; min-width:0; }
    .metaTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .metaLine{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .timeText{ font-size: 12px; color: var(--muted); }

    .timeUseRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .recoText{
      font-size: 12px;
      color: #0b5f4a;
      font-weight: 900;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }
    .recoText.muted{ color: var(--muted2); font-weight: 800; }
    .recoText.late{ color:#7c1313; }

    .btnMini{
      width:auto;
      min-height: 32px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 900;
      box-shadow: none;
    }

    .actions{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .actions .btn{ padding: 10px 12px; min-height: 40px; font-size: 13px; }

    .spin{
      width: 14px; height:14px;
      border: 2px solid #cfeee4;
      border-top-color: #1fbf9a;
      border-radius: 999px;
      display:inline-block;
      animation: spin 1s linear infinite;
      vertical-align:-2px;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    /* TopBar (compact, fixed) */
    .topBar{
      position: fixed;
      left:0; right:0; top:0;
      z-index: 70;
      padding: calc(10px + env(safe-area-inset-top)) 12px 10px;
      background: rgba(246,255,251,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }
    .topInner{
      max-width: 980px;
      margin: 0 auto;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
    }
    .topLeft{
      min-width:0;
      flex: 1 1 auto;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .topTitleRow{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .topTitle{
      font-weight: 900;
      letter-spacing: .2px;
      font-size: 16px;
      line-height: 1.1;
      margin:0;
    }
    .topRight{
      flex: 0 0 auto;
      display:flex;
      gap:10px;
      align-items:stretch;
    }
    .topBtn{
      width:auto;
      min-width: 54px;
      padding: 10px 12px;
      min-height: 44px;
      box-shadow: 0 8px 18px rgba(14,42,35,.08);
    }
    @media (max-width: 380px){
      .topBtn{ min-width: 48px; padding: 10px 10px; }
    }

    .headerStatusRow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    /* Sticky bar bottom */
    .stickyBar{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: rgba(246,255,251,.92);
      backdrop-filter: blur(10px);
      border-top: 1px solid var(--line);
      z-index: 60;
    }
    .stickyInner{
      max-width: 980px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:stretch;
    }

    .stickyInner .btn.bigPrimary{
      min-height: 56px;
      font-size: 16px;
      font-weight: 900;
      letter-spacing: .2px;
      box-shadow: 0 10px 22px rgba(14,42,35,.14);
    }

    .btn.square{
      width: 56px;
      height: 56px;
      min-width: 56px;
      min-height: 56px;
      padding: 0;
      border-radius: 16px;
      font-size: 18px;
      font-weight: 900;
      box-shadow: 0 10px 22px rgba(14,42,35,.10);
    }
    @media (max-width: 420px){
      .stickyInner{ gap:8px; }
      .btn.square{ width: 52px; height: 52px; min-width:52px; min-height:52px; border-radius: 14px; }
      .stickyInner .btn.bigPrimary{ min-height: 52px; font-size: 16px; }
    }

    /* Toast (small, not blocking) */
    .toastWrap{
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(var(--stickH) + 12px);
      z-index: 120;
      display:none;
      pointer-events: none;
    }
    .toastWrap.show{ display:block; }
    .toastCard{
      pointer-events: auto;
      max-width: 520px;
      margin: 0 auto;
      background: #fbfffd;
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .toastText{
      font-size: 13px;
      line-height: 1.25;
      font-weight: 900;
      color: #1f4a3f;
    }
    .toastSub{
      margin-top: 3px;
      font-size: 12px;
      font-weight: 800;
      color: var(--muted);
    }
    .toastBtn{
      width:auto;
      min-height: 38px;
      padding: 8px 10px;
      box-shadow:none;
    }

    /* Downloaded Drawer */
    .drawerBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(12, 34, 28, .25);
      display:none;
      z-index: 95;
    }
    .drawerBackdrop.show{ display:block; }
    .drawer{
      position: fixed;
      left: 0; right: 0; bottom: 0;
      transform: translateY(105%);
      transition: transform .22s ease;
      z-index: 100;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
    }
    .drawer.show{ transform: translateY(0%); }
    .drawerPanel{
      max-width: 980px;
      margin: 0 auto;
      background: rgba(246,255,251,.96);
      border: 1px solid var(--line);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      max-height: 76vh;
      display:flex;
      flex-direction:column;
    }
    .drawerHeader{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid var(--line);
      background: #fbfffd;
    }
    .drawerBody{
      padding: 12px 14px 14px;
      overflow:auto;
    }

    /* Modal (camera/replace) */
    .modalBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(12, 34, 28, .45);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 110;
    }
    .modalBackdrop.show{ display:flex; }
    .modal{
      width: 100%;
      max-width: 680px;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHeader{
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid var(--line);
      background: #fbfffd;
    }
    .modalHeader .row{ flex-wrap:nowrap; }
    .modalBody{ padding: 12px 14px 14px; }

    /* Camera viewfinder (portrait 4:3) */
    .viewfinderWrap{
      width: 100%;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: #061a15;
      overflow:hidden;
      position: relative;
      aspect-ratio: 3 / 4;
    }
    video#camVideo{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      transform: none;
    }
    video#camVideo.mirror{
      transform: scaleX(-1);
    }
    .vfOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      border: 1px solid rgba(255,255,255,.08);
    }

    .camHUD{
      position:absolute;
      left:10px; right:10px;
      top:10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      z-index: 3;
    }
    .camHUD .pill{
      background: rgba(251,255,253,.92);
      border-color: rgba(215,239,231,.95);
      box-shadow: 0 10px 24px rgba(0,0,0,.12);
      color: #1f4a3f;
      pointer-events:none;
    }
    .camToast{
      position:absolute;
      left:10px; right:10px;
      bottom:10px;
      display:none;
      z-index: 3;
    }
    .camToast.show{ display:block; }
    .camToastInner{
      background: rgba(231,251,244,.92);
      border: 1px solid rgba(191,238,224,.95);
      color:#0b5f4a;
      border-radius: 16px;
      padding: 10px 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.12);
      font-weight: 900;
      font-size: 13px;
      line-height: 1.25;
    }
    .camFlash{
      position:absolute;
      inset:0;
      background: rgba(255,255,255,.0);
      z-index: 4;
      pointer-events:none;
      transition: background .15s ease;
    }
    .camFlash.on{ background: rgba(255,255,255,.55); }

    details.logPanel{
      border: 1px dashed #cfeee4;
      border-radius: 16px;
      padding: 10px 12px;
      background: #fbfffd;
    }
    details.logPanel summary{
      cursor:pointer;
      font-weight: 900;
      color: var(--muted);
    }
    pre#logBox{
      margin: 10px 0 0;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      color: #1f4a3f;
    }
  </style>
</head>

<body>
  <!-- Top header (sticky, always access Add + Downloaded drawer) -->
  <div class="topBar" id="topBar">
    <div class="topInner">
      <div class="topLeft">
        <div class="topTitleRow">
          <div class="topTitle">Selfie + Time Logger</div>
          <span class="badge wait" id="saveStateBadge">‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>
          <span class="pill" id="headerGoalPill">DL: <b id="dlCountTop">0</b>/40</span>
        </div>

        <div class="headerStatusRow">
          <span class="pill" id="headerNextPill">Next: <b id="headerNextText">-</b></span>
          <span class="pill" id="headerWhenPill">‡πÄ‡∏ß‡∏•‡∏≤: <b id="headerWhenText">-</b></span>
          <span class="pill" id="headerCountdownPill">‡∏≠‡∏µ‡∏Å: <b id="headerCountdownText">-</b></span>
          <span class="badge err" id="headerWarnBadge" style="display:none">‚ö† -</span>
        </div>

        <div class="mini muted" id="headerHint">
          * ‡∏ô‡∏≠‡∏Å Chrome/‡∏õ‡∏¥‡∏î‡πÅ‡∏ó‡πá‡∏ö: ‡πÄ‡∏ß‡πá‡∏ö‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡πÑ‡∏°‡πà‡∏Å‡∏≤‡∏£‡∏±‡∏ô‡∏ï‡∏µ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô (‡πÉ‡∏ô‡πÅ‡∏≠‡∏õ‡∏à‡∏∞‡∏ó‡∏≥‡πÅ‡∏ö‡∏ö best-effort)
        </div>
      </div>

      <div class="topRight">
        <button class="btn primary topBtn" id="openCameraBtn" title="‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏ã‡∏•‡∏ü‡∏µ‡πà">üì∑</button>
        <button class="btn soft topBtn" id="uploadBtn" title="‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏à‡∏≤‡∏Å‡πÅ‡∏Å‡∏•‡πÄ‡∏•‡∏≠‡∏£‡∏µ‡πà">üñºÔ∏è</button>
        <button class="btn topBtn" id="openDrawerBtn" title="‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Downloaded">‚úÖ</button>
      </div>
    </div>
  </div>

  <!-- Toast (small) -->
  <div class="toastWrap" id="toastWrap">
    <div class="toastCard">
      <div>
        <div class="toastText" id="toastText">‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß</div>
        <div class="toastSub" id="toastSub">-</div>
      </div>
      <button class="btn soft toastBtn" id="toastDismissBtn">‡∏õ‡∏¥‡∏î</button>
    </div>
  </div>

  <!-- Main content -->
  <div class="wrap">
    <!-- Pending -->
    <section class="card">
      <h2>
        <span>Pending (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÇ‡∏´‡∏•‡∏î)</span>
        <span class="badge wait" id="pendingBadge">0</span>
      </h2>
      <div class="list" id="pendingList"></div>
      <div class="mini muted" id="pendingEmpty" style="display:none">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Pending</div>
    </section>

    <!-- Progress (moved to bottom as requested) -->
    <section class="card">
      <h2>
        <span>Progress</span>
        <span class="badge ok" id="goalBadge" style="display:none">‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‚úÖ</span>
      </h2>

      <div class="row spread">
        <div class="pill">Total: <b id="totalCount">0</b> ‚Ä¢ Downloaded: <b id="downloadedCount">0</b> ‚Ä¢ Pending: <b id="pendingCount">0</b></div>
        <div class="pill">‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: <b>40</b> ‡∏£‡∏π‡∏õ</div>
      </div>

      <div style="height:10px"></div>
      <div class="progressWrap"><div class="progressBar" id="progressBar"></div></div>

      <div style="height:12px"></div>

      <div class="grid3">
        <div class="switch">
          <input type="checkbox" id="mirrorHintToggle" checked />
          <div>
            <div style="font-weight:900;font-size:13px">‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡∏Å‡∏£‡∏∞‡∏à‡∏Å (Mirror)</div>
            <div class="mini muted">‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß & ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏∞‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô (flip ‡∏ã‡πâ‡∏≤‡∏¢-‡∏Ç‡∏ß‡∏≤)</div>
          </div>
        </div>

        <div class="switch">
          <input type="checkbox" id="autoWakeToggle" checked />
          <div>
            <div style="font-weight:900;font-size:13px">Catch-up ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡∏¥‡∏î</div>
            <div class="mini muted">‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏Ç‡∏∂‡πâ‡∏ô toast ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ</div>
          </div>
        </div>

        <div class="switch">
          <input type="checkbox" id="logToggle" />
          <div>
            <div style="font-weight:900;font-size:13px">‡πÄ‡∏õ‡∏¥‡∏î Log panel</div>
            <div class="mini muted">‡πÉ‡∏ä‡πâ debug ‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠</div>
          </div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="grid2">
        <div class="card" style="margin:0; box-shadow:none">
          <div class="row spread">
            <span class="badge" id="timerLockBadge">-</span>
            <span class="pill" id="timerLeftPill">‡πÄ‡∏´‡∏•‡∏∑‡∏≠: -</span>
          </div>
          <div style="height:8px"></div>
          <div class="mini muted" id="timerMeta">startAt: - ‚Ä¢ targetAt: -</div>
        </div>

        <div class="card" style="margin:0; box-shadow:none">
          <div class="row spread">
            <span class="badge" id="alarmBadge">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á</span>
            <span class="pill" id="alarmLeftPill">‡πÄ‡∏´‡∏•‡∏∑‡∏≠: -</span>
          </div>
          <div style="height:8px"></div>
          <div class="mini muted" id="alarmMeta">next: - ‚Ä¢ dueAt: -</div>
          <div style="height:8px"></div>
          <div class="row">
            <button class="btn soft btnMini" id="requestNotifBtn" style="width:auto">üîî ‡∏Ç‡∏≠‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå</button>
            <button class="btn btnMini" id="testBeepBtn" style="width:auto">üîä ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á/‡∏™‡∏±‡πà‡∏ô</button>
          </div>
        </div>
      </div>

      <div style="height:12px"></div>

      <details class="logPanel" id="logPanel" style="display:none">
        <summary>Log panel (‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î)</summary>
        <pre id="logBox"></pre>
      </details>
    </section>
  </div>

  <!-- Sticky Bar bottom -->
  <div class="stickyBar" id="stickyBar">
    <div class="stickyInner">
      <button class="btn primary bigPrimary" id="start910Btn">‚è±Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤</button>
      <button class="btn warn square" id="unlockBtn" disabled title="‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ (3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)">üîì</button>
      <button class="btn danger square" id="deleteAllBtn" title="‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î">üß®</button>
    </div>
  </div>

  <!-- Downloaded Drawer -->
  <div class="drawerBackdrop" id="drawerBackdrop"></div>
  <div class="drawer" id="drawer">
    <div class="drawerPanel">
      <div class="drawerHeader">
        <div class="row" style="gap:10px">
          <span class="badge ok">Downloaded</span>
          <span class="pill">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: <b id="drawerDownloadedCount">0</b></span>
        </div>
        <div class="row" style="gap:10px">
          <button class="btn soft btnMini" id="closeDrawerBtn" style="width:auto">‡∏õ‡∏¥‡∏î</button>
        </div>
      </div>
      <div class="drawerBody">
        <div class="list" id="downloadedList"></div>
        <div class="mini muted" id="downloadedEmpty" style="display:none">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Downloaded</div>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input id="fileInputAdd" type="file" accept="image/*" multiple style="display:none" />
  <input id="fileInputReplace" type="file" accept="image/*" style="display:none" />

  <!-- Camera / Replace Modal -->
  <div class="modalBackdrop" id="camModalBackdrop">
    <div class="modal">
      <div class="modalHeader">
        <div class="row" style="gap:10px">
          <span class="badge ok" id="camModeBadge">CAM</span>
          <span class="pill" id="camFacingPill">facing: -</span>
          <span class="pill" id="camMirrorPill">mirror: -</span>
          <span class="badge wait" id="replaceBadge" style="display:none">REPLACE -</span>
        </div>
        <div class="row" style="gap:10px">
          <button class="btn soft" id="switchCamBtn" style="width:auto">üîÑ</button>
          <button class="btn" id="closeCamBtn" style="width:auto">‚úñ</button>
        </div>
      </div>

      <div class="modalBody">
        <div class="viewfinderWrap">
          <video id="camVideo" playsinline autoplay muted></video>

          <div class="camHUD">
            <span class="pill" id="camCountPill">üì∏ Total: 0</span>
            <span class="pill" id="camNextPill">Next: -</span>
          </div>

          <div class="camToast" id="camToast">
            <div class="camToastInner" id="camToastInner">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß</div>
          </div>

          <div class="camFlash" id="camFlash"></div>
          <div class="vfOverlay"></div>
        </div>

        <div style="height:12px"></div>
        <div class="grid2">
          <button class="btn primary" id="captureBtn">üì∏ ‡∏ñ‡πà‡∏≤‡∏¢‡∏†‡∏≤‡∏û</button>
          <button class="btn soft" id="fallbackUploadBtn">üñºÔ∏è ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ó‡∏ô</button>
        </div>

        <div style="height:10px"></div>
        <div class="mini muted" id="camHint">
          ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤: ‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏£‡∏∞‡∏à‡∏Å ‡πÅ‡∏•‡∏∞‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏à‡∏∞ ‚Äú‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡πá‡∏ô‚Äù ‚Ä¢ ‡∏ñ‡πâ‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏Å‡∏î‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ó‡∏ô
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************************************************************
     * Utilities + State
     **********************************************************************/
    const $ = (id) => document.getElementById(id);

    const LS = {
      timer910: "stl_timer910_state",   // {running, locked, startAt, targetAt}
      alarm: "stl_alarm_state",         // {dueAt, nextTag, firedDueAt}
      ui: "stl_ui_state"                // {logEnabled, autoWake, mirrorPref}
    };

    const state = {
      db: null,
      dbType: "unknown",
      photos: [],
      thumbUrl: new Map(), // id -> objectURL

      busy: { saving:false },

      cam: { stream:null, facing:"user" },

      ui: { logEnabled:false, autoWake:true, mirrorPref:true },

      // Replace mode (Pending only)
      replace: { active:false, targetId:null, targetTag:null },

      // 9:10 timer
      timer910: { running:false, locked:false, startAt:null, targetAt:null },

      // Unlock window
      unlock: { until:null, ticker:null },

      // Alarm (best-effort in-app)
      alarm: { dueAt:null, nextTag:null, firedDueAt:null },
      alarmTimeout: null,

      // Schedule (frontend dynamic)
      schedule: {
        ok:false,
        reason:"",
        nextTag:null,
        nextAt:null,
        planAtById: new Map(), // only tags needed up to target
        source: { lastDownloadedTag:null, lastDownloadedAt:null }
      },

      // Ticking
      tickInterval: null,
      toastTimer: null
    };

    function now(){ return Date.now(); }

    function fmtDT(ts){
      if(!ts) return "-";
      try{
        return new Date(ts).toLocaleString("th-TH", {
          year:"2-digit", month:"2-digit", day:"2-digit",
          hour:"2-digit", minute:"2-digit", second:"2-digit"
        });
      }catch(_){
        return new Date(ts).toString();
      }
    }
    function fmtTimeOnly(ts){
      if(!ts) return "-";
      try{
        return new Date(ts).toLocaleTimeString("th-TH", { hour:"2-digit", minute:"2-digit" });
      }catch(_){
        const d = new Date(ts);
        return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
      }
    }
    function fmtHMS(ms){
      if(ms == null) return "-";
      const sign = ms < 0 ? "-" : "";
      ms = Math.abs(ms);
      const s = Math.floor(ms/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return `${sign}${String(hh).padStart(2,"0")}:${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
    }

    function loadJSON(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return fallback;
        return JSON.parse(raw);
      }catch(_){ return fallback; }
    }
    function saveJSON(key, obj){
      try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(_){}
    }

    function setSaveState(text, mode){
      const b = $("saveStateBadge");
      b.className = "badge " + (mode || "wait");
      b.innerHTML = text;
    }

    function log(...args){
      const line = `[${new Date().toLocaleTimeString("th-TH")}] ` + args.map(a=>{
        if(typeof a === "string") return a;
        try{ return JSON.stringify(a); }catch(_){ return String(a); }
      }).join(" ");
      if(state.ui.logEnabled){
        const box = $("logBox");
        box.textContent = (line + "\n" + box.textContent).slice(0, 16000);
      }
      console.log(...args);
    }

    /**********************************************************************
     * Tag logic: fill earliest missing slot (IN before OUT)
     **********************************************************************/
    function parseTag(tag){
      const m = String(tag || "").trim().match(/^(IN|OUT)-(\d+)$/i);
      if(!m) return null;
      return { kind: m[1].toUpperCase(), idx: parseInt(m[2], 10) };
    }
    function ensureKindIdx(photo){
      if(photo && (!photo.kind || !photo.idx) && photo.tag){
        const p = parseTag(photo.tag);
        if(p){ photo.kind = p.kind; photo.idx = p.idx; }
      }
      return photo;
    }
    function computeNextSlot(photos){
      const occ = new Map(); // idx -> {IN, OUT}
      for(const raw of photos){
        const p = ensureKindIdx(raw);
        if(!p || !p.kind || !p.idx) continue;
        const o = occ.get(p.idx) || { IN:false, OUT:false };
        if(p.kind === "IN") o.IN = true;
        if(p.kind === "OUT") o.OUT = true;
        occ.set(p.idx, o);
      }
      let i = 1;
      while(true){
        const o = occ.get(i) || { IN:false, OUT:false };
        if(!o.IN) return { tag:`IN-${i}`, kind:"IN", idx:i };
        if(!o.OUT) return { tag:`OUT-${i}`, kind:"OUT", idx:i };
        i++;
      }
    }
    function peekNextTag(){
      return computeNextSlot(state.photos).tag;
    }
    function nextTagInSequence(tag){
      const p = parseTag(tag);
      if(!p) return null;
      if(p.kind === "IN") return `OUT-${p.idx}`;
      return `IN-${p.idx + 1}`;
    }

    /**********************************************************************
     * IndexedDB: Dexie preferred, native fallback
     **********************************************************************/
    async function initDB(){
      const hasDexie = typeof window.Dexie !== "undefined";
      if(hasDexie){
        try{
          const db = new Dexie("SelfieTimeLoggerMintLight");
          db.version(1).stores({
            photos: "++id, tag, kind, idx, createdAt, downloaded"
          });
          db.version(2).stores({
            photos: "++id, tag, kind, idx, createdAt, downloaded, downloadedAt"
          }).upgrade(async tx=>{
            const table = tx.table("photos");
            await table.toCollection().modify(p=>{
              if(!("downloadedAt" in p)) p.downloadedAt = null;
              if(!("editedAt" in p)) p.editedAt = null;
              if((!p.kind || !p.idx) && p.tag){
                const q = parseTag(p.tag);
                if(q){ p.kind = q.kind; p.idx = q.idx; }
              }
            });
          });
          // v3: add editedAt
          db.version(3).stores({
            photos: "++id, tag, kind, idx, createdAt, downloaded, downloadedAt, editedAt"
          }).upgrade(async tx=>{
            const table = tx.table("photos");
            await table.toCollection().modify(p=>{
              if(!("editedAt" in p)) p.editedAt = null;
            });
          });

          await db.open();
          state.dbType = "Dexie";
          state.db = db;
          log("DB: Dexie");
          return;
        }catch(e){
          console.warn("Dexie open failed, fallback to native:", e);
        }
      }
      state.dbType = "Native";
      state.db = await openNativeDB();
      log("DB: Native fallback");
    }

    function openNativeDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open("SelfieTimeLoggerMintLight_Native", 2);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains("photos")){
            const store = db.createObjectStore("photos", { keyPath:"id", autoIncrement:true });
            store.createIndex("createdAt", "createdAt", { unique:false });
            store.createIndex("downloaded", "downloaded", { unique:false });
            store.createIndex("tag", "tag", { unique:false });
          }
        };
        req.onsuccess = () => {
          const db = req.result;

          const api = {
            async addPhoto(obj){
              return txWrap(db, "photos", "readwrite", store => store.add(obj));
            },
            async updatePhoto(id, changes){
              return txWrap(db, "photos", "readwrite", async store => {
                const existing = await reqWrap(store.get(id));
                if(!existing) return null;
                const merged = { ...existing, ...changes };
                await reqWrap(store.put(merged));
                return merged;
              });
            },
            async deletePhoto(id){
              return txWrap(db, "photos", "readwrite", store => store.delete(id));
            },
            async clearAll(){
              return txWrap(db, "photos", "readwrite", store => store.clear());
            },
            async getAll(){
              return txWrap(db, "photos", "readonly", async store => {
                const idx = store.index("createdAt");
                const all = await reqWrap(idx.getAll());
                return all;
              });
            }
          };
          resolve(api);
        };
        req.onerror = () => reject(req.error);
      });

      function txWrap(db, storeName, mode, fn){
        return new Promise((resolve, reject)=>{
          const tx = db.transaction(storeName, mode);
          const store = tx.objectStore(storeName);
          Promise.resolve(fn(store)).then(res=>{
            tx.oncomplete = ()=> resolve(res);
            tx.onerror = ()=> reject(tx.error);
            tx.onabort = ()=> reject(tx.error);
          }).catch(reject);
        });
      }
      function reqWrap(req){
        return new Promise((resolve, reject)=>{
          req.onsuccess = ()=> resolve(req.result);
          req.onerror = ()=> reject(req.error);
        });
      }
    }

    async function dbAddPhoto(photo){
      if(state.dbType === "Dexie") return state.db.photos.add(photo);
      return state.db.addPhoto(photo);
    }
    async function dbUpdatePhoto(id, changes){
      if(state.dbType === "Dexie") return state.db.photos.update(id, changes);
      return state.db.updatePhoto(id, changes);
    }
    async function dbDeletePhoto(id){
      if(state.dbType === "Dexie") return state.db.photos.delete(id);
      return state.db.deletePhoto(id);
    }
    async function dbClearAll(){
      if(state.dbType === "Dexie") return state.db.photos.clear();
      return state.db.clearAll();
    }
    async function dbGetAll(){
      if(state.dbType === "Dexie") return state.db.photos.orderBy("createdAt").toArray();
      return state.db.getAll();
    }

    /**********************************************************************
     * Image processing: re-encode via canvas to strip EXIF
     **********************************************************************/
    function loadImage(src){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=> resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }
    function fitWithin(w, h, maxSide){
      const max = Math.max(w, h);
      if(max <= maxSide) return { w, h };
      const scale = maxSide / max;
      return { w: Math.round(w*scale), h: Math.round(h*scale) };
    }
    function canvasToJpegBlob(canvas, quality=0.92){
      return new Promise((resolve)=>{
        canvas.toBlob((b)=> resolve(b), "image/jpeg", quality);
      });
    }
    async function imageFileToCleanJpegBlob(file, targetMax = 1600){
      const url = URL.createObjectURL(file);
      try{
        const img = await loadImage(url);
        const { w, h } = fitWithin(img.naturalWidth, img.naturalHeight, targetMax);
        const canvas = document.createElement("canvas");
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext("2d", { alpha:false });
        ctx.drawImage(img, 0, 0, w, h);
        const blob = await canvasToJpegBlob(canvas, 0.92);
        return { blob, width:w, height:h, mime:"image/jpeg" };
      }finally{
        URL.revokeObjectURL(url);
      }
    }

    /**********************************************************************
     * ObjectURL thumbs
     **********************************************************************/
    function getThumbUrl(photo){
      if(state.thumbUrl.has(photo.id)) return state.thumbUrl.get(photo.id);
      const u = URL.createObjectURL(photo.blob);
      state.thumbUrl.set(photo.id, u);
      return u;
    }
    function revokeThumbUrl(id){
      const u = state.thumbUrl.get(id);
      if(u){
        URL.revokeObjectURL(u);
        state.thumbUrl.delete(id);
      }
    }
    function revokeAllThumbs(){
      for(const u of state.thumbUrl.values()) URL.revokeObjectURL(u);
      state.thumbUrl.clear();
    }

    /**********************************************************************
     * Add photo: store immediately, tag continuity ensured
     **********************************************************************/
    async function addPhotoFromBlob(blob, meta = {}){
      if(state.busy.saving) return;
      state.busy.saving = true;

      const next = computeNextSlot(state.photos);
      const { tag, kind, idx } = next;

      const createdAt = now();
      const record = {
        tag, kind, idx,
        createdAt,
        downloaded: 0,
        downloadedAt: null,
        editedAt: null,
        mime: meta.mime || blob.type || "image/jpeg",
        width: meta.width || null,
        height: meta.height || null,
        size: blob.size,
        blob
      };

      setSaveState(`<span class="spin"></span> ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‚Ä¶`, "wait");
      try{
        const id = await dbAddPhoto(record);
        record.id = id;

        state.photos.push(record);
        state.photos.sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));

        setSaveState("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß ‚úÖ", "ok");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 900);

        heavyRender();
        updateCamHUD();
        showCamToast(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß: ${tag}`);
      }catch(e){
        setSaveState("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß", "err");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 1200);
        log("Save error:", e && (e.message||e.name) ? (e.message||e.name) : e);
      }finally{
        state.busy.saving = false;
      }
    }

    async function replacePhotoBlob(targetId, blob, meta = {}){
      const p = state.photos.find(x => x.id === targetId);
      if(!p) return;

      // revoke old thumb url so UI updates image immediately
      revokeThumbUrl(targetId);

      const editedAt = now();
      const changes = {
        blob,
        mime: meta.mime || blob.type || "image/jpeg",
        width: meta.width || p.width || null,
        height: meta.height || p.height || null,
        size: blob.size,
        editedAt
      };

      setSaveState(`<span class="spin"></span> ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‚Ä¶`, "wait");
      try{
        await dbUpdatePhoto(targetId, changes);

        // update in-memory record (keep tag/kind/idx/createdAt and downloaded stays 0 because edit only in Pending)
        Object.assign(p, changes);

        setSaveState("‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‚úÖ", "ok");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 900);

        heavyRender();
        showCamToast(`‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß: ${p.tag}`);
      }catch(e){
        setSaveState("‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß", "err");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 1200);
        log("Replace error:", e && (e.message||e.name) ? (e.message||e.name) : e);
      }
    }

    async function handleFilesAdd(files){
      if(!files || !files.length) return;
      setSaveState(`<span class="spin"></span> ‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏π‡∏õ‚Ä¶`, "wait");

      for(const file of files){
        try{
          const clean = await imageFileToCleanJpegBlob(file, 1600);
          await addPhotoFromBlob(clean.blob, clean);
        }catch(e){
          log("Upload error:", e && (e.message || e.name) ? (e.message || e.name) : e);
          setSaveState("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß", "err");
          setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 1200);
        }
      }
      heavyRender();
    }

    async function handleFileReplace(file){
      if(!file || !state.replace.active || !state.replace.targetId) return;
      setSaveState(`<span class="spin"></span> ‡πÅ‡∏õ‡∏•‡∏á‡∏£‡∏π‡∏õ‚Ä¶`, "wait");
      try{
        const clean = await imageFileToCleanJpegBlob(file, 1600);
        await replacePhotoBlob(state.replace.targetId, clean.blob, clean);
      }catch(e){
        log("Replace upload error:", e && (e.message || e.name) ? (e.message || e.name) : e);
        setSaveState("‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß", "err");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 1200);
      }
    }

    /**********************************************************************
     * 9:10 Timer (persist)
     **********************************************************************/
    const TIMER_910_MS = (9*60*60 + 10*60) * 1000;

    function loadTimer910(){
      const t = loadJSON(LS.timer910, null);
      if(t && typeof t === "object"){
        state.timer910 = {
          running: !!t.running,
          locked: !!t.locked,
          startAt: t.startAt || null,
          targetAt: t.targetAt || null
        };
      }
    }
    function saveTimer910(){ saveJSON(LS.timer910, state.timer910); }

    function isUnlockWindowActive(){
      return !!state.unlock.until && now() < state.unlock.until;
    }
    function clearUnlockWindow(){
      state.unlock.until = null;
      if(state.unlock.ticker){
        clearInterval(state.unlock.ticker);
        state.unlock.ticker = null;
      }
      $("unlockBtn").textContent = "üîì";
    }
    function openUnlockWindow3s(){
      clearUnlockWindow();
      state.unlock.until = now() + 3000;

      const tick = () => {
        const leftMs = state.unlock.until - now();
        const leftSec = Math.max(0, Math.ceil(leftMs / 1000));
        if(leftSec <= 0){
          clearUnlockWindow();
          lightTick(); // update button disabled state quickly
          return;
        }
        $("unlockBtn").textContent = `üîì${leftSec}`;
        lightTick();
      };

      tick();
      state.unlock.ticker = setInterval(tick, 200);
      log("Unlock window opened: 3s");
    }

    function startTimer910(){
      const startAt = now();
      const targetAt = startAt + TIMER_910_MS;
      state.timer910 = { running:true, locked:true, startAt, targetAt };
      saveTimer910();
      log("Timer start", fmtDT(startAt), "->", fmtDT(targetAt));
    }

    function resetTimer910ToReady(){
      state.timer910 = { running:false, locked:false, startAt:null, targetAt:null };
      saveTimer910();
      clearUnlockWindow();
      // clear alarm
      state.alarm = { dueAt:null, nextTag:null, firedDueAt:null };
      saveJSON(LS.alarm, state.alarm);
      stopAlarmTimeout();
      hideToast();
      log("Timer reset -> READY");
    }

    async function onStartButtonClick(){
      const { downloaded } = computeCounts();

      // Step 1: Start
      if(!state.timer910.running){
        startTimer910();
        heavyRender();
        return;
      }

      // Step 2: Reset (only when unlocked or within unlock window)
      const allowed = (!state.timer910.locked) || isUnlockWindowActive();
      if(!allowed) return;
      resetTimer910ToReady();
      heavyRender();
    }

    /**********************************************************************
     * Schedule (horizon-based up to target) + Missing logic only if needed
     **********************************************************************/
    function computeCounts(){
      const total = state.photos.length;
      const downloaded = state.photos.filter(p=>p.downloaded === 1).length;
      const pending = total - downloaded;
      return { total, downloaded, pending };
    }

    function sortSlot(a,b){
      const ai = a.idx||0, bi = b.idx||0;
      if(ai !== bi) return ai - bi;
      const ak = (String(a.kind).toUpperCase()==="IN") ? 0 : 1;
      const bk = (String(b.kind).toUpperCase()==="IN") ? 0 : 1;
      return ak - bk;
    }

    function getLastDownloadedFirstTime(){
      // NOTE: downloadedAt is only set on "first download" and never overwritten (per your requirement)
      const downloaded = state.photos.filter(p=>p.downloaded===1 && p.downloadedAt);
      if(!downloaded.length) return null;
      downloaded.sort((a,b)=> (a.downloadedAt||0) - (b.downloadedAt||0));
      return downloaded[downloaded.length-1] || null;
    }

    function minGapMinutes(kind){ return (kind==="IN") ? 3 : 4; }
    function maxGapMinutes(kind){ return (kind==="IN") ? 25 : 30; }

    function solveKindAverages(totalMin, nIn, nOut){
      const mean = totalMin / Math.max(1,(nIn+nOut));
      const best = { a:null, b:null, score: 1e18 };

      if(nOut===0 && nIn>0){
        let a = totalMin / nIn;
        a = Math.max(3, Math.min(25, a));
        return { a, b:null, ok:true };
      }
      if(nIn===0 && nOut>0){
        let b = totalMin / nOut;
        b = Math.max(4, Math.min(30, b));
        return { a:null, b, ok:true };
      }
      if(nIn===0 && nOut===0){
        return { a:null, b:null, ok:false };
      }

      for(let a=3; a<=25; a+=0.25){
        const b = (totalMin - a*nIn) / nOut;
        if(b < 4 || b > 30) continue;
        if(!(b - a >= 0.25)) continue; // IN < OUT
        const score = Math.abs(a-mean) + Math.abs(b-mean);
        if(score < best.score){
          best.a = a; best.b = b; best.score = score;
        }
      }

      if(best.a==null){
        let a = Math.max(3, Math.min(25, mean-1));
        let b = Math.max(4, Math.min(30, mean+1));
        if(!(b - a >= 0.25)) b = Math.min(30, a + 0.25);
        return { a, b, ok:false };
      }
      return { a: best.a, b: best.b, ok:true };
    }

    function distributeDiffWithinBounds(gapsMs, kinds, totalMs){
      let sum = gapsMs.reduce((s,x)=>s+x,0);
      let diff = totalMs - sum;
      if(Math.abs(diff) < 500) return gapsMs;

      for(let i=gapsMs.length-1;i>=0;i--){
        if(diff === 0) break;
        const kind = kinds[i];
        const minMs = minGapMinutes(kind)*60000;
        const maxMs = maxGapMinutes(kind)*60000;

        const current = gapsMs[i];
        const target = current + diff;

        const clamped = Math.max(minMs, Math.min(maxMs, target));
        const applied = clamped - current;
        if(applied !== 0){
          gapsMs[i] = clamped;
          diff -= applied;
        }
      }
      return gapsMs;
    }

    function computeScheduleHorizon(){
      const sched = {
        ok:false,
        reason:"",
        nextTag:null,
        nextAt:null,
        planAtById: new Map(),
        source: { lastDownloadedTag:null, lastDownloadedAt:null }
      };

      // Must have timer running
      if(!state.timer910.running || !state.timer910.targetAt){
        sched.reason = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤";
        return sched;
      }

      // Build pending lookup
      const pending = state.photos.filter(p=>p.downloaded===0).map(ensureKindIdx);
      const pendingByTag = new Map(pending.map(p=>[p.tag, p]));

      // Determine last downloaded (first-time) and next expected tag
      const last = getLastDownloadedFirstTime();
      let nextExpected = last ? nextTagInSequence(last.tag) : "IN-1";
      sched.source.lastDownloadedTag = last ? last.tag : null;
      sched.source.lastDownloadedAt = last ? last.downloadedAt : null;

      // Base time for schedule:
      // - If there is lastDownloadedAt, schedule from that time (alarm starts after download)
      // - Else: schedule UI can still compute; but alarm will not auto-fire until first download
      let baseTime = last ? last.downloadedAt : now();
      baseTime = Math.max(baseTime, state.timer910.startAt || 0);

      const targetAt = state.timer910.targetAt;
      const totalMs = targetAt - baseTime;

      if(totalMs <= 0){
        sched.reason = "‡πÄ‡∏•‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß";
        sched.nextTag = nextExpected || "-";
        sched.nextAt = now();
        return sched;
      }

      // Horizon-based chain:
      // Build minimal number of steps so that maxPossible >= totalMs
      // If we hit missing before that -> missing is truly needed => show reason
      const plan = [];
      const gapKinds = []; // kind that determines wait before the corresponding plan item (if last exists), or between items (if no last)
      let minPossibleMs = 0;
      let maxPossibleMs = 0;

      // helper to add gap kind
      const addGap = (kind) => {
        gapKinds.push(kind);
        minPossibleMs += minGapMinutes(kind)*60000;
        maxPossibleMs += maxGapMinutes(kind)*60000;
      };

      if(last){
        // we need a gap before each planned download
        let cur = nextExpected;
        let prevKind = (parseTag(last.tag)?.kind) || "IN";
        for(let i=0;i<200;i++){
          const p = pendingByTag.get(cur);
          if(!p){
            // missing needed because we haven't covered target yet
            sched.reason = `‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ ${cur}`;
            break;
          }
          plan.push(p);
          // gap kind for this step:
          const kindForGap = (i===0) ? prevKind : String(plan[i-1].kind).toUpperCase();
          addGap(kindForGap);

          if(totalMs <= maxPossibleMs){
            // enough photos to potentially cover target, stop here
            break;
          }
          cur = nextTagInSequence(cur);
          if(!cur) break;
        }

        // If we never set reason missing and plan is empty => can't compute
        if(!plan.length && !sched.reason){
          sched.reason = `‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ ${nextExpected}`;
        }
      }else{
        // no last download: first planned "should be now" if exists
        let cur = nextExpected;
        const first = pendingByTag.get(cur);
        if(!first){
          sched.reason = `‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ ${cur}`;
          sched.nextTag = cur;
          return sched;
        }
        plan.push(first);

        // add more steps until horizon covered
        for(let i=1;i<200;i++){
          const prev = plan[i-1];
          const kindForGap = String(prev.kind).toUpperCase(); // after IN => gap 3-25, after OUT => gap 4-30
          addGap(kindForGap);

          if(totalMs <= maxPossibleMs){
            break;
          }

          cur = nextTagInSequence(prev.tag);
          const p = pendingByTag.get(cur);
          if(!p){
            sched.reason = `‡∏Ç‡∏≤‡∏î‡∏£‡∏π‡∏õ ${cur}`;
            break;
          }
          plan.push(p);
        }
      }

      // Determine nextTag even when missing
      sched.nextTag = plan[0]?.tag || nextExpected || "-";

      // If we have missing reason, we still compute times for "available plan" as far as possible,
      // BUT we won't claim schedule is OK. (Header will show missing)
      // Also: If missing isn't needed (horizon covered), it will never be set.

      const gapCount = last ? plan.length : Math.max(0, plan.length - 1);

      // If no gaps (only 1 item when no last), nextAt is now
      if(gapCount === 0){
        sched.ok = (sched.reason === "");
        sched.nextAt = last ? (baseTime + (minGapMinutes((parseTag(last.tag)?.kind)||"IN")*60000)) : baseTime;
        if(plan[0]) sched.planAtById.set(plan[0].id, sched.nextAt);
        return sched;
      }

      // Feasibility check only if we have enough horizon (i.e., missing not set)
      const feasible = (totalMs >= (minPossibleMs - 2000)) && (totalMs <= (maxPossibleMs + 2000));

      // count kinds for averages
      let nIn=0, nOut=0;
      for(const k of gapKinds){ if(k==="IN") nIn++; else nOut++; }

      let gapsMs = new Array(gapCount).fill(0);

      if(!feasible){
        // If missing was set: keep reason as missing
        // Else show time feasibility reason
        if(!sched.reason){
          if(totalMs > maxPossibleMs){
            const extra = totalMs - maxPossibleMs;
            const needMore = Math.ceil(extra / (30*60000));
            sched.reason = `‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡∏û‡∏≠‡∏ñ‡∏∂‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢ (‡∏Ñ‡∏ß‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° ~${needMore} ‡∏£‡∏π‡∏õ+)`;
          }else{
            sched.reason = `‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏π‡∏õ‡πÉ‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö`;
          }
        }

        // best-effort gaps: stretch or shrink
        for(let i=0;i<gapKinds.length;i++){
          const k = gapKinds[i];
          gapsMs[i] = Math.round((totalMs > maxPossibleMs ? maxGapMinutes(k) : minGapMinutes(k)) * 60000);
        }
      }else{
        const totalMin = totalMs / 60000;
        const { a, b } = solveKindAverages(totalMin, nIn, nOut);
        for(let i=0;i<gapKinds.length;i++){
          const k = gapKinds[i];
          const mins = (k==="IN") ? (a ?? 10) : (b ?? 12);
          const clamped = Math.max(minGapMinutes(k), Math.min(maxGapMinutes(k), mins));
          gapsMs[i] = Math.round(clamped * 60000);
        }
        gapsMs = distributeDiffWithinBounds(gapsMs, gapKinds, totalMs);
      }

      // Build recommended times
      let t = baseTime;
      if(last){
        for(let i=0;i<plan.length;i++){
          t += gapsMs[i];
          sched.planAtById.set(plan[i].id, t);
        }
        sched.nextAt = sched.planAtById.get(plan[0].id) || null;
      }else{
        // first at baseTime (now)
        sched.planAtById.set(plan[0].id, t);
        for(let i=1;i<plan.length;i++){
          t += gapsMs[i-1];
          sched.planAtById.set(plan[i].id, t);
        }
        sched.nextAt = sched.planAtById.get(plan[0].id) || null;
      }

      // Mark ok only when no reason
      sched.ok = (sched.reason === "");
      return sched;
    }

    /**********************************************************************
     * Alarm / Notification (best-effort)
     **********************************************************************/
    function loadAlarmState(){
      const a = loadJSON(LS.alarm, null);
      if(a && typeof a === "object"){
        state.alarm = {
          dueAt: a.dueAt || null,
          nextTag: a.nextTag || null,
          firedDueAt: a.firedDueAt || null
        };
      }
    }
    function saveAlarmState(){
      saveJSON(LS.alarm, state.alarm);
    }
    function stopAlarmTimeout(){
      if(state.alarmTimeout){
        clearTimeout(state.alarmTimeout);
        state.alarmTimeout = null;
      }
    }

    function tryNotify(body){
      if(typeof Notification === "undefined") return;
      if(Notification.permission !== "granted") return;
      try{
        new Notification("Selfie Time Logger", { body });
      }catch(_){}
    }

    function beepOnce(duration=0.14, freq=880){
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        o.connect(g); g.connect(ctx.destination);
        g.gain.value = 0.08;
        o.start();
        setTimeout(()=>{ o.stop(); ctx.close(); }, duration*1000);
      }catch(_){}
    }
    function vibratePattern(){
      try{
        if(navigator.vibrate) navigator.vibrate([120, 70, 120]);
      }catch(_){}
    }
    function beepSoft(){
      vibratePattern();
      beepOnce(0.12, 880);
      setTimeout(()=>beepOnce(0.12, 990), 170);
    }

    function showToast(text, sub, autoHideMs=6500){
      $("toastText").textContent = text;
      $("toastSub").textContent = sub || "";
      $("toastWrap").classList.add("show");

      if(state.toastTimer) clearTimeout(state.toastTimer);
      state.toastTimer = setTimeout(()=> hideToast(), autoHideMs);
    }
    function hideToast(){
      $("toastWrap").classList.remove("show");
      if(state.toastTimer){
        clearTimeout(state.toastTimer);
        state.toastTimer = null;
      }
    }

    function scheduleNextAlarmFromSchedule(){
      stopAlarmTimeout();

      // Alarm starts only after first download exists (per original spec)
      const last = getLastDownloadedFirstTime();
      if(!last){
        state.alarm = { dueAt:null, nextTag:null, firedDueAt:null };
        saveAlarmState();
        return;
      }

      const s = state.schedule;
      if(!s || !s.nextAt || !s.nextTag){
        state.alarm = { dueAt:null, nextTag:null, firedDueAt:null };
        saveAlarmState();
        return;
      }

      const dueAt = s.nextAt;
      state.alarm.dueAt = dueAt;
      state.alarm.nextTag = s.nextTag;
      if(state.alarm.firedDueAt && state.alarm.firedDueAt !== dueAt){
        state.alarm.firedDueAt = null;
      }
      saveAlarmState();

      const delay = Math.max(0, dueAt - now());
      state.alarmTimeout = setTimeout(()=>{
        fireAlarmIfNeeded(true);
      }, delay + 80);

      fireAlarmIfNeeded(false);
    }

    function fireAlarmIfNeeded(fromTimeout){
      const dueAt = state.alarm.dueAt;
      if(!dueAt) return;

      const isPast = (dueAt - now()) <= 0;
      if(!isPast) return;

      if(state.alarm.firedDueAt === dueAt) return;

      if(!fromTimeout && !state.ui.autoWake) return;

      state.alarm.firedDueAt = dueAt;
      saveAlarmState();

      const nextTag = state.alarm.nextTag || "-";
      const msg = nextTag.startsWith("OUT-") ? "‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ Check Out ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß" : "‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ Check In ‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß";

      showToast(msg, `Next: ${nextTag}`);
      tryNotify(`${msg} ‚Ä¢ Next: ${nextTag}`);
      beepSoft();
      log("ALARM FIRED:", msg, "dueAt=", fmtDT(dueAt));
    }

    async function requestNotificationPermission(){
      if(typeof Notification === "undefined"){
        alert("‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå/‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Notification");
        return;
      }
      try{
        const p = await Notification.requestPermission();
        log("Notification permission:", p);
        showToast("Permission", `Notification: ${p}`, 2500);
      }catch(e){
        log("Permission request error:", e);
      }
    }

    /**********************************************************************
     * Download + mark downloaded (NO overwrite downloadedAt on re-download)
     **********************************************************************/
    async function downloadPhoto(photo){
      const filename = `${photo.tag}.jpg`;

      const url = URL.createObjectURL(photo.blob);
      try{
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }finally{
        URL.revokeObjectURL(url);
      }

      if(photo.downloaded !== 1){
        const t = now();
        await dbUpdatePhoto(photo.id, { downloaded: 1, downloadedAt: t });
        photo.downloaded = 1;
        photo.downloadedAt = t;
        log("Marked downloaded (first time):", photo.tag);
        heavyRender(); // move to downloaded immediately
      }else{
        // re-download: do NOT touch downloadedAt (per your requirement)
        log("Downloaded again (no schedule reset):", photo.tag);
      }
    }

    async function deletePhoto(id, tag){
      await dbDeletePhoto(id);
      revokeThumbUrl(id);
      state.photos = state.photos.filter(p => p.id !== id);
      log("Deleted", tag, "id=", id);
      heavyRender();
    }

    /**********************************************************************
     * Drawer (Downloaded)
     **********************************************************************/
    function openDrawer(){
      $("drawerBackdrop").classList.add("show");
      $("drawer").classList.add("show");
    }
    function closeDrawer(){
      $("drawerBackdrop").classList.remove("show");
      $("drawer").classList.remove("show");
    }

    /**********************************************************************
     * Render: heavy vs light
     **********************************************************************/
    function renderTopCounts(){
      const { downloaded } = computeCounts();
      $("dlCountTop").textContent = downloaded;
      $("openDrawerBtn").textContent = `‚úÖ`;
      $("openDrawerBtn").title = `Downloaded (${downloaded})`;
    }

    function renderTimerPanel(){
      const { downloaded } = computeCounts();

      // Auto unlock if downloaded >= 40
      if(state.timer910.running && state.timer910.locked && downloaded >= 40){
        state.timer910.locked = false;
        saveTimer910();
        log("Auto unlock timer (downloaded >= 40)");
      }

      const b = $("timerLockBadge");
      if(state.timer910.running){
        if(state.timer910.locked){
          b.className = "badge err";
          b.textContent = "LOCKED";
        }else{
          b.className = "badge ok";
          b.textContent = "UNLOCKED";
        }
      }else{
        b.className = "badge ok";
        b.textContent = "READY";
      }

      $("timerMeta").textContent =
        `startAt: ${fmtDT(state.timer910.startAt)} ‚Ä¢ targetAt: ${fmtDT(state.timer910.targetAt)}`;

      // button label
      const startBtn = $("start910Btn");
      if(!state.timer910.running){
        startBtn.textContent = "‚è±Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤";
      }else{
        startBtn.textContent = `‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î ${fmtTimeOnly(state.timer910.targetAt)}`;
      }

      // Start button enabled rules (2-step)
      const canResetNow = state.timer910.running && (!state.timer910.locked || isUnlockWindowActive());
      startBtn.disabled = state.timer910.running ? !canResetNow : false;

      // Unlock button enabled rules
      const unlockBtn = $("unlockBtn");
      const canUnlock = state.timer910.running && state.timer910.locked && downloaded < 40;
      unlockBtn.disabled = !canUnlock && !isUnlockWindowActive();
      if(!isUnlockWindowActive()) unlockBtn.textContent = "üîì";
    }

    function renderProgressBar(){
      const { total } = computeCounts();
      const prog = Math.min(40, total);
      $("progressBar").style.width = `${(prog/40)*100}%`;
      if(total >= 40){
        $("goalBadge").style.display = "";
      }else{
        $("goalBadge").style.display = "none";
      }
    }

    function renderHeaderStatus(){
      // schedule is already computed in heavyRender and stored
      const s = state.schedule;
      const warn = $("headerWarnBadge");

      if(!state.timer910.running){
        $("headerNextText").textContent = peekNextTag();
        $("headerWhenText").textContent = "-";
        $("headerCountdownText").textContent = "-";
        warn.style.display = "";
        warn.className = "badge wait";
        warn.textContent = "‚è± ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡πà‡∏≠‡∏ô";
        return;
      }

      // show Next tag always (based on plan)
      $("headerNextText").textContent = s.nextTag || "-";

      // show warning only when schedule has reason (missing/insufficient/too fast)
      if(s.reason){
        warn.style.display = "";
        warn.className = "badge err";
        warn.textContent = `‚ö† ${s.reason}`;
      }else{
        warn.style.display = "none";
        warn.textContent = "";
      }

      // show time and countdown if nextAt exists
      if(s.nextAt){
        const left = s.nextAt - now();
        const when = left <= 0 ? "‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ" : fmtTimeOnly(s.nextAt);
        $("headerWhenText").textContent = when;
        $("headerCountdownText").textContent = left <= 0 ? "‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤" : fmtHMS(left);
      }else{
        $("headerWhenText").textContent = "-";
        $("headerCountdownText").textContent = "-";
      }
    }

    function renderAlarmPanel(){
      if(state.alarm.dueAt){
        const left = state.alarm.dueAt - now();
        if(left <= 0){
          $("alarmBadge").className = "badge err";
          $("alarmBadge").textContent = "‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß";
        }else{
          $("alarmBadge").className = "badge wait";
          $("alarmBadge").textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏±‡∏ö‚Ä¶";
        }
        $("alarmLeftPill").textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${fmtHMS(left)}`;
        $("alarmMeta").textContent = `next: ${state.alarm.nextTag || "-"} ‚Ä¢ dueAt: ${fmtDT(state.alarm.dueAt)}`;
      }else{
        $("alarmBadge").className = "badge";
        $("alarmBadge").textContent = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏±‡πâ‡∏á";
        $("alarmLeftPill").textContent = "‡πÄ‡∏´‡∏•‡∏∑‡∏≠: -";
        $("alarmMeta").textContent = "next: - ‚Ä¢ dueAt: -";
      }
    }

    function renderLists(){
      // pending
      const pendingList = $("pendingList");
      pendingList.innerHTML = "";

      // downloaded (drawer)
      const downloadedList = $("downloadedList");
      downloadedList.innerHTML = "";

      const pending = state.photos.filter(p=>p.downloaded===0).map(ensureKindIdx);
      const downloaded = state.photos.filter(p=>p.downloaded===1).map(ensureKindIdx);

      pending.sort(sortSlot);
      downloaded.sort(sortSlot);

      $("pendingBadge").textContent = pending.length;
      $("pendingEmpty").style.display = pending.length ? "none" : "";

      $("drawerDownloadedCount").textContent = downloaded.length;
      $("downloadedEmpty").style.display = downloaded.length ? "none" : "";

      // Show Time use only if the photo is part of schedule.planAtById (i.e., needed to reach target)
      const planMap = state.schedule.planAtById || new Map();

      for(const p of pending){
        pendingList.appendChild(renderPhotoItem(p, false, planMap));
      }
      for(const p of downloaded){
        downloadedList.appendChild(renderPhotoItem(p, true, planMap));
      }

      // counts bottom
      const { total, downloaded: dlCount, pending: pendCount } = computeCounts();
      $("totalCount").textContent = total;
      $("downloadedCount").textContent = dlCount;
      $("pendingCount").textContent = pendCount;
    }

    function renderPhotoItem(photo, isDownloaded, planMap){
      const wrap = document.createElement("div");
      wrap.className = "photoItem";

      const img = document.createElement("img");
      img.className = "thumb";
      img.src = getThumbUrl(photo);
      img.alt = photo.tag;

      const info = document.createElement("div");
      info.className = "info";

      const metaTop = document.createElement("div");
      metaTop.className = "metaTop";

      const left = document.createElement("div");
      left.className = "metaLine";

      const tagBadge = document.createElement("span");
      tagBadge.className = "badge ok";
      tagBadge.textContent = photo.tag;

      const statusBadge = document.createElement("span");
      statusBadge.className = "badge " + (isDownloaded ? "ok" : "wait");
      statusBadge.textContent = isDownloaded ? "‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡πâ‡∏ß ‚úÖ" : "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÇ‡∏´‡∏•‡∏î";

      left.appendChild(tagBadge);
      left.appendChild(statusBadge);

      const time = document.createElement("div");
      time.className = "timeText";
      time.textContent = fmtDT(photo.createdAt);

      metaTop.appendChild(left);
      metaTop.appendChild(time);

      // Time use line + Edit (Pending only)
      const timeUseRow = document.createElement("div");
      timeUseRow.className = "timeUseRow";

      const reco = document.createElement("div");
      reco.className = "recoText";

      if(!isDownloaded){
        const t = planMap.get(photo.id);
        if(t){
          const late = (t - now()) <= 0;
          reco.classList.toggle("late", late);
          reco.textContent = `Time use ${fmtTimeOnly(t)}${late ? " ‚Ä¢ ‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤" : ""}`;
        }else{
          // show nothing intrusive (not red) when not needed / can't compute due to missing earlier needed tag
          reco.classList.add("muted");
          reco.textContent = "Time use ‚Äî";
        }
      }else{
        reco.classList.add("muted");
        reco.textContent = `Time use ‚Äî`;
      }

      timeUseRow.appendChild(reco);

      if(!isDownloaded){
        const editBtn = document.createElement("button");
        editBtn.className = "btn soft btnMini";
        editBtn.style.width = "auto";
        editBtn.textContent = "‚úèÔ∏è";
        editBtn.title = "‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‡πÉ‡∏ö‡∏ô‡∏µ‡πâ (Pending ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)";
        editBtn.onclick = async () => {
          // open replace mode: camera modal, show REPLACE badge
          state.replace.active = true;
          state.replace.targetId = photo.id;
          state.replace.targetTag = photo.tag;
          await openCamera(true);
        };
        timeUseRow.appendChild(editBtn);
      }

      // Actions
      const actions = document.createElement("div");
      actions.className = "actions";

      const dlBtn = document.createElement("button");
      dlBtn.className = "btn primary";
      dlBtn.textContent = "‚¨á Download";
      dlBtn.onclick = async () => {
        dlBtn.disabled = true;
        try{ await downloadPhoto(photo); }
        finally{ dlBtn.disabled = false; }
      };

      const delBtn = document.createElement("button");
      delBtn.className = "btn danger";
      delBtn.textContent = "üóë Delete";
      delBtn.onclick = async () => {
        const ok = confirm(`‡∏•‡∏ö‡∏£‡∏π‡∏õ ${photo.tag} ‡πÉ‡∏ä‡πà‡πÑ‡∏´‡∏°?\n(‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á/IndexedDB)`);
        if(!ok) return;
        delBtn.disabled = true;
        try{ await deletePhoto(photo.id, photo.tag); }
        finally{ delBtn.disabled = false; }
      };

      actions.appendChild(dlBtn);
      actions.appendChild(delBtn);

      info.appendChild(metaTop);
      info.appendChild(timeUseRow);
      info.appendChild(actions);

      wrap.appendChild(img);
      wrap.appendChild(info);
      return wrap;
    }

    function heavyRender(){
      // compute schedule once (heavy) and render lists
      state.schedule = computeScheduleHorizon();

      renderTopCounts();
      renderProgressBar();
      renderTimerPanel();
      renderAlarmPanel();
      renderLists();

      // schedule next alarm after recompute (best-effort) + catch-up
      scheduleNextAlarmFromSchedule();
      fireAlarmIfNeeded(false);

      // header uses schedule
      renderHeaderStatus();

      // measure bars (in case content changed)
      requestAnimationFrame(()=>measureBars());
    }

    function lightTick(){
      // lightweight updates every second (no list rebuild)
      renderTimerPanel();    // update button disabled + lock status
      renderHeaderStatus();  // update countdown
      renderAlarmPanel();    // update remaining time

      // alarm catch-up
      fireAlarmIfNeeded(false);
    }

    /**********************************************************************
     * Delete all (2-step confirm)
     **********************************************************************/
    async function deleteAll(){
      const ok1 = confirm("‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏π‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ä‡πà‡πÑ‡∏´‡∏°?\n(‡∏•‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á/IndexedDB)");
      if(!ok1) return;
      const ok2 = confirm("‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á: ‡∏•‡∏ö‡∏£‡∏π‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
      if(!ok2) return;

      setSaveState(`<span class="spin"></span> ‡∏•‡∏ö‚Ä¶`, "wait");
      try{
        await dbClearAll();
        revokeAllThumbs();
        state.photos = [];
        resetTimer910ToReady();
        setSaveState("‡∏•‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‚úÖ", "ok");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 900);
      }catch(e){
        setSaveState("‡∏•‡∏ö‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß", "err");
        setTimeout(()=> setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait"), 1200);
      }
      heavyRender();
    }

    /**********************************************************************
     * Refresh from DB (boot)
     **********************************************************************/
    async function refresh(){
      const all = await dbGetAll();
      all.sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
      for(const p of all) ensureKindIdx(p);
      state.photos = all;
      heavyRender();
    }

    /**********************************************************************
     * UI state (persist)
     **********************************************************************/
    function loadUIState(){
      const u = loadJSON(LS.ui, null);
      if(u && typeof u === "object"){
        state.ui.logEnabled = !!u.logEnabled;
        state.ui.autoWake = (u.autoWake !== false);
        state.ui.mirrorPref = (u.mirrorPref !== false);
      }
      $("logToggle").checked = state.ui.logEnabled;
      $("autoWakeToggle").checked = state.ui.autoWake;
      $("mirrorHintToggle").checked = state.ui.mirrorPref;
      $("logPanel").style.display = state.ui.logEnabled ? "" : "none";
    }
    function saveUIState(){
      saveJSON(LS.ui, {
        logEnabled: state.ui.logEnabled,
        autoWake: state.ui.autoWake,
        mirrorPref: state.ui.mirrorPref
      });
    }

    /**********************************************************************
     * Camera modal (mirror + saved matches preview)
     **********************************************************************/
    async function openCamera(isReplace = false){
      $("camModalBackdrop").classList.add("show");
      $("camModeBadge").textContent = "CAM";
      $("camModeBadge").className = "badge ok";

      // show replace badge if needed
      if(isReplace && state.replace.active && state.replace.targetTag){
        $("replaceBadge").style.display = "";
        $("replaceBadge").textContent = `REPLACE ${state.replace.targetTag}`;
      }else{
        $("replaceBadge").style.display = "none";
        $("replaceBadge").textContent = "REPLACE -";
      }

      updateCamHUD();
      await startCameraStream();
    }

    function closeCamera(){
      stopCameraStream();
      $("camModalBackdrop").classList.remove("show");
      hideCamToast();

      // leaving camera should exit replace mode
      state.replace.active = false;
      state.replace.targetId = null;
      state.replace.targetTag = null;
      $("replaceBadge").style.display = "none";
    }

    async function startCameraStream(){
      stopCameraStream();

      if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
        $("camModeBadge").textContent = "NO CAMERA";
        $("camModeBadge").className = "badge err";
        log("Camera API not supported");
        return;
      }

      const facing = state.cam.facing;
      const useMirror = (facing === "user") && state.ui.mirrorPref;

      $("camFacingPill").textContent = `facing: ${facing}`;
      $("camMirrorPill").textContent = `mirror: ${useMirror ? "ON" : "OFF"}`;

      try{
        const constraints = {
          audio: false,
          video: {
            facingMode: { ideal: facing },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        state.cam.stream = stream;

        const video = $("camVideo");
        video.srcObject = stream;
        video.classList.toggle("mirror", useMirror);

        await video.play();
      }catch(e){
        $("camModeBadge").textContent = "CAM ERROR";
        $("camModeBadge").className = "badge err";
        log("Camera error:", e && (e.name || e.message) ? (e.name || e.message) : e);
      }
    }

    function stopCameraStream(){
      const s = state.cam.stream;
      if(s) s.getTracks().forEach(t=>t.stop());
      state.cam.stream = null;
      $("camVideo").srcObject = null;
    }

    async function switchCamera(){
      state.cam.facing = (state.cam.facing === "user") ? "environment" : "user";
      await startCameraStream();
    }

    function camFlash(){
      const el = $("camFlash");
      el.classList.add("on");
      setTimeout(()=> el.classList.remove("on"), 140);
    }
    function showCamToast(text){
      $("camToastInner").textContent = text;
      $("camToast").classList.add("show");
      setTimeout(()=> hideCamToast(), 900);
    }
    function hideCamToast(){
      $("camToast").classList.remove("show");
    }

    function updateCamHUD(){
      const { total, downloaded, pending } = computeCounts();
      $("camCountPill").textContent = `üì∏ Total: ${total} ‚Ä¢ Pending: ${pending} ‚Ä¢ DL: ${downloaded}`;

      const next = state.replace.active ? state.replace.targetTag : peekNextTag();
      $("camNextPill").textContent = `Next: ${next}`;
    }

    async function captureFromCamera(){
      const video = $("camVideo");
      if(!video || !video.videoWidth){
        showCamToast("‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°");
        return;
      }

      camFlash();
      if(navigator.vibrate) navigator.vibrate(12);

      const facing = state.cam.facing;
      const mirror = (facing === "user") && state.ui.mirrorPref;

      // Output portrait 4:3 (aspect 3/4)
      const outAR = 3/4;
      const srcW = video.videoWidth;
      const srcH = video.videoHeight;
      const srcAR = srcW/srcH;

      // crop to match outAR
      let cropW, cropH, sx, sy;
      if(srcAR > outAR){
        cropH = srcH;
        cropW = cropH * outAR;
        sx = (srcW - cropW)/2;
        sy = 0;
      }else{
        cropW = srcW;
        cropH = cropW / outAR;
        sx = 0;
        sy = (srcH - cropH)/2;
      }

      const maxH = 1600;
      let outH = Math.min(maxH, Math.round(cropH));
      let outW = Math.round(outH * outAR);
      if(cropH < maxH){
        outH = Math.round(cropH);
        outW = Math.round(cropW);
      }

      const canvas = document.createElement("canvas");
      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext("2d", { alpha:false });

      // mirror saved image to match mirror preview
      if(mirror){
        ctx.save();
        ctx.translate(outW, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, outW, outH);
        ctx.restore();
      }else{
        ctx.drawImage(video, sx, sy, cropW, cropH, 0, 0, outW, outH);
      }

      const blob = await canvasToJpegBlob(canvas, 0.92);

      if(state.replace.active && state.replace.targetId){
        await replacePhotoBlob(state.replace.targetId, blob, { width: outW, height: outH, mime:"image/jpeg" });
      }else{
        await addPhotoFromBlob(blob, { width: outW, height: outH, mime:"image/jpeg" });
      }

      updateCamHUD();
    }

    /**********************************************************************
     * Layout measurements: fixed top & bottom bars (real-time)
     **********************************************************************/
    function measureBars(){
      const top = $("topBar");
      const bottom = $("stickyBar");
      const topH = top ? top.offsetHeight : 0;
      const stickH = bottom ? bottom.offsetHeight : 0;
      document.documentElement.style.setProperty("--topH", `${topH}px`);
      document.documentElement.style.setProperty("--stickH", `${stickH}px`);
    }

    function installResizeObservers(){
      const ro = new ResizeObserver(() => measureBars());
      ro.observe($("topBar"));
      ro.observe($("stickyBar"));
    }

    /**********************************************************************
     * Boot
     **********************************************************************/
    async function boot(){
      loadUIState();
      loadTimer910();
      loadAlarmState();

      await initDB();
      await refresh();

      installResizeObservers();
      measureBars();
      window.addEventListener("resize", ()=> measureBars());
      window.addEventListener("orientationchange", ()=> setTimeout(()=> measureBars(), 200));

      // Wire: Add
      $("uploadBtn").onclick = ()=> $("fileInputAdd").click();
      $("fileInputAdd").addEventListener("change", async (e)=>{
        const files = Array.from(e.target.files || []);
        e.target.value = "";
        await handleFilesAdd(files);
      });

      // Wire: Replace upload in camera modal
      $("fallbackUploadBtn").onclick = ()=> {
        if(state.replace.active) $("fileInputReplace").click();
        else $("fileInputAdd").click(); // allow multi-add outside replace
      };
      $("fileInputReplace").addEventListener("change", async (e)=>{
        const file = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
        e.target.value = "";
        await handleFileReplace(file);
      });

      // Camera
      $("openCameraBtn").onclick = async ()=> {
        state.replace.active = false;
        state.replace.targetId = null;
        state.replace.targetTag = null;
        await openCamera(false);
      };
      $("closeCamBtn").onclick = closeCamera;
      $("switchCamBtn").onclick = switchCamera;
      $("captureBtn").onclick = captureFromCamera;

      $("camModalBackdrop").addEventListener("click", (e)=>{
        if(e.target === $("camModalBackdrop")) closeCamera();
      });

      // Drawer
      $("openDrawerBtn").onclick = openDrawer;
      $("closeDrawerBtn").onclick = closeDrawer;
      $("drawerBackdrop").onclick = closeDrawer;

      // Timer buttons
      $("start910Btn").onclick = onStartButtonClick;
      $("unlockBtn").onclick = ()=> openUnlockWindow3s();
      $("deleteAllBtn").onclick = deleteAll;

      // Toast dismiss
      $("toastDismissBtn").onclick = hideToast;

      // Progress actions
      $("requestNotifBtn").onclick = requestNotificationPermission;
      $("testBeepBtn").onclick = ()=> beepSoft();

      // toggles
      $("logToggle").addEventListener("change", ()=>{
        state.ui.logEnabled = $("logToggle").checked;
        $("logPanel").style.display = state.ui.logEnabled ? "" : "none";
        saveUIState();
        log("Log enabled:", state.ui.logEnabled);
      });
      $("autoWakeToggle").addEventListener("change", ()=>{
        state.ui.autoWake = $("autoWakeToggle").checked;
        saveUIState();
        log("AutoWake:", state.ui.autoWake);
      });
      $("mirrorHintToggle").addEventListener("change", ()=>{
        state.ui.mirrorPref = $("mirrorHintToggle").checked;
        saveUIState();

        const facing = state.cam.facing;
        const mirror = (facing === "user") && state.ui.mirrorPref;
        $("camVideo").classList.toggle("mirror", mirror);
        $("camMirrorPill").textContent = `mirror: ${mirror ? "ON" : "OFF"}`;
      });

      // visibility catch-up
      document.addEventListener("visibilitychange", ()=>{
        if(!document.hidden){
          measureBars();
          if(state.ui.autoWake){
            fireAlarmIfNeeded(false);
          }
          lightTick();
        }
      });

      // Start light tick
      if(state.tickInterval) clearInterval(state.tickInterval);
      state.tickInterval = setInterval(lightTick, 1000);

      setSaveState("‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô", "wait");
      heavyRender();

      log("BOOT OK", "dbType=", state.dbType, "nextSlot=", peekNextTag());
    }

    window.addEventListener("beforeunload", ()=>{
      revokeAllThumbs();
    });

    boot();
  </script>
</body>
</html>
