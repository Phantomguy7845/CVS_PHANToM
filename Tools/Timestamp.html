<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>PT Timestamp Camera (4:3 Portrait UI) v3.2</title>

  <!-- Leaflet (ใช้ตอนเปิดแผนที่ใน Settings เท่านั้น) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- JSZip (fallback ถ้า File System Access API ใช้ไม่ได้) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>

  <style>
    :root{
      --bg:#000;
      --text:#f5f7ff;
      --muted:rgba(245,247,255,.72);
      --muted2:rgba(245,247,255,.52);
      --line:rgba(255,255,255,.10);
      --accent:#10b981;
      --danger:#ef4444;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:18px;

      --safe-b: env(safe-area-inset-bottom);
      --safe-t: env(safe-area-inset-top);
      --safe-l: env(safe-area-inset-left);
      --safe-r: env(safe-area-inset-right);

      /* Responsive sizing (เน้น %/vw/vh) */
      --btn: clamp(40px, 10.5vw, 52px);
      --btn-mini: clamp(56px, 14vw, 70px);
      --shutter: clamp(78px, 20vw, 96px);
      --top-pad: clamp(10px, 2.2vh, 14px);
      --side-pad: clamp(10px, 2.4vw, 14px);
      --bottom-bar-h: clamp(92px, 14vh, 124px);
      --film-h: clamp(62px, 10.5vh, 78px);
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif;
      overflow:hidden;
    }
    button, input, select{
      font-family: inherit;
      -webkit-tap-highlight-color: transparent;
    }

    /* ===== Stage ===== */
    .stage{
      position:relative;
      width:100%;
      height: 100svh;
      height: 100dvh;
      background:#000;
      overflow:hidden;
    }

    /* ===== Viewfinder: 4:3 แนวตั้ง (3:4) + ขอบดำบน/ล่าง ===== */
    .viewfinder{
      position:absolute;
      left:0; right:0;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      aspect-ratio: 3 / 4; /* 4:3 ในแนวตั้ง */
      background:#000;
      overflow:hidden;
      box-shadow: 0 22px 70px rgba(0,0,0,.50);
    }

    /* ปรับในแนวนอน (กันล้นจอ) */
    @media (orientation: landscape){
      .viewfinder{
        width: min(70vw, 520px);
        left: 50%;
        right: auto;
        transform: translate(-50%, -50%);
      }
    }

    video#camVideo{
      width:100%;
      height:100%;
      object-fit: cover;
      background:#000;
      transform: translateZ(0);
    }
    video#camVideo.mirror{
      transform: scaleX(-1) translateZ(0);
    }

    /* ===== Live overlay (STAMP GUIDE) : ไม่มีแถบดำ ===== */
    .liveOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 3;
      display:flex;
      align-items:flex-start;
      justify-content:flex-end;
      padding: clamp(10px, 2.6vw, 16px);
    }
    .overlayText{
      max-width: 92%;
      display:none;
      white-space: pre-wrap;
      line-height: 1.2;
      font-weight: 950;
      color:#fff;
      background: transparent;
      border: none;
      padding: 0;
      text-shadow:
        0 2px 12px rgba(0,0,0,.88),
        0 0 2px rgba(0,0,0,.88);
    }

    /* ===== Top bar ===== */
    .topBar{
      position:absolute;
      top:0; left:0; right:0;
      z-index: 10;
      padding:
        calc(var(--top-pad) + var(--safe-t))
        calc(var(--side-pad) + var(--safe-r))
        var(--top-pad)
        calc(var(--side-pad) + var(--safe-l));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .topGroup{ display:flex; align-items:center; gap: clamp(8px, 2vw, 12px); }

    .brandPill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: clamp(8px, 2.2vw, 12px) clamp(10px, 2.6vw, 14px);
      border-radius: 999px;
      background: rgba(0,0,0,.34);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
      font-weight: 950;
      letter-spacing:.4px;
      user-select:none;
      color: rgba(255,255,255,.92);
      font-size: clamp(12px, 3.2vw, 14px);
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 0 4px rgba(255,255,255,.08);
    }
    .dot.ok{ background: rgba(16,185,129,.95); box-shadow: 0 0 0 4px rgba(16,185,129,.18); }
    .dot.err{ background: rgba(239,68,68,.95); box-shadow: 0 0 0 4px rgba(239,68,68,.18); }

    .iconBtn{
      width: var(--btn);
      height: var(--btn);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.34);
      color:#fff;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }
    .iconBtn:active{ transform: translateY(1px); }
    .iconBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .iconBtn.on{
      border-color: rgba(16,185,129,.55);
      background: rgba(16,185,129,.16);
    }
    .iconBtn svg{
      width: 56%;
      height: 56%;
      opacity: .95;
    }

    /* ===== Main time HUD (หน้าหลัก) ===== */
    .timeHUD{
      position:absolute;
      top: calc(var(--safe-t) + clamp(58px, 9vh, 78px));
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      display:flex;
      align-items:center;
      gap: clamp(8px, 2vw, 12px);
      padding: clamp(8px, 2vw, 10px) clamp(10px, 2.6vw, 12px);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(10px);
      box-shadow: 0 14px 34px rgba(0,0,0,.30);
      user-select:none;
      max-width: min(92vw, 760px);
    }
    .timeModeBtn{
      padding: clamp(8px, 2vw, 10px) clamp(10px, 2.6vw, 12px);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      font-weight: 950;
      cursor:pointer;
      min-height: clamp(36px, 6.5vh, 42px);
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
      font-size: clamp(12px, 3.3vw, 14px);
    }
    .timeModeBtn.on{
      border-color: rgba(16,185,129,.55);
      background: rgba(16,185,129,.16);
      color:#d6fff1;
    }
    .timeLabelBtn{
      padding: clamp(8px, 2vw, 10px) clamp(10px, 2.6vw, 12px);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.90);
      font-weight: 950;
      cursor:pointer;
      min-height: clamp(36px, 6.5vh, 42px);
      max-width: 62vw;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
      font-size: clamp(12px, 3.3vw, 14px);
    }

    /* ===== Filmstrip ===== */
    .filmstrip{
      position:absolute;
      left: calc(var(--side-pad) + var(--safe-l));
      right: calc(var(--side-pad) + var(--safe-r));
      bottom: calc(var(--bottom-bar-h) + clamp(10px, 2.2vh, 16px) + var(--safe-b));
      z-index: 12;
      display:flex;
      gap: clamp(8px, 2.2vw, 12px);
      align-items:center;
      padding: clamp(8px, 2vw, 10px);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.26);
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      overflow-x:auto;
      scrollbar-width: none;
      max-height: var(--film-h);
    }
    .filmstrip::-webkit-scrollbar{ display:none; }

    .thumb{
      width: calc(var(--film-h) - 10px);
      height: calc(var(--film-h) - 10px);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      flex: 0 0 auto;
      position:relative;
      cursor:pointer;
      user-select:none;
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
    }
    .thumb.active{
      outline: 3px solid rgba(16,185,129,.55);
      outline-offset: 2px;
    }
    .thumb .del{
      position:absolute;
      top:6px; right:6px;
      width: 22px; height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.55);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 13px;
      font-weight: 950;
      cursor:pointer;
    }
    .thumb .num{
      position:absolute;
      left:6px; bottom:6px;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 11px;
      font-weight: 950;
    }
    .emptyPill{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.80);
      font-size: 12px;
      font-weight: 900;
      user-select:none;
      white-space:nowrap;
    }

    /* ===== Bottom controls ===== */
    .bottomBar{
      position:absolute;
      left:0; right:0; bottom:0;
      z-index: 13;
      height: var(--bottom-bar-h);
      padding:
        clamp(10px, 2vh, 12px)
        calc(var(--side-pad) + var(--safe-r))
        calc(clamp(12px, 2.4vh, 14px) + var(--safe-b))
        calc(var(--side-pad) + var(--safe-l));
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: clamp(10px, 2.6vw, 16px);
      pointer-events:auto;
    }
    .miniBtn{
      width: var(--btn-mini);
      height: var(--btn-mini);
      border-radius: clamp(16px, 4.5vw, 22px);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.34);
      color:#fff;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
    }
    .miniBtn:active{ transform: translateY(1px); }
    .miniBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .miniBtn svg{ width: 52%; height: 52%; opacity:.95; }

    .latestThumbImg{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.05);
    }
    .countBadge{
      position:absolute;
      right:6px; bottom:6px;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(0,0,0,.58);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 11px;
      font-weight: 950;
    }

    .shutter{
      width: var(--shutter);
      height: var(--shutter);
      border-radius: 999px;
      border: clamp(5px, 1.2vw, 7px) solid rgba(255,255,255,.94);
      background: rgba(255,255,255,.10);
      cursor:pointer;
      user-select:none;
      position:relative;
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      flex: 0 0 auto;
    }
    .shutter::after{
      content:"";
      position:absolute;
      inset: clamp(9px, 2.2vw, 12px);
      border-radius: 999px;
      background: rgba(255,255,255,.92);
    }
    .shutter:active{ transform: scale(.987); }
    .shutter[disabled]{ opacity:.45; cursor:not-allowed; }

    /* ===== Delete all FAB (ขวาล่าง) ===== */
    .fabDanger{
      position:absolute;
      right: calc(var(--side-pad) + var(--safe-r));
      bottom: calc(var(--bottom-bar-h) + var(--safe-b) + clamp(10px, 2.2vh, 16px));
      z-index: 20;
      width: var(--btn-mini);
      height: var(--btn-mini);
      border-radius: 999px;
      border: 1px solid rgba(239,68,68,.40);
      background: rgba(239,68,68,.14);
      color:#ffd7d7;
      cursor:pointer;
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
    }
    .fabDanger:active{ transform: translateY(1px); }
    .fabDanger svg{ width: 52%; height: 52%; opacity:.95; }

    /* ===== Modals ===== */
    .backdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.74);
      display:none;
      z-index:50;
      padding: 12px;
      padding-top: calc(12px + var(--safe-t));
      padding-bottom: calc(12px + var(--safe-b));
      align-items:center;
      justify-content:center;
    }
    .modal{
      width: min(920px, 100%);
      max-height: 100%;
      background: linear-gradient(180deg, rgba(15,22,32,.98), rgba(10,14,20,.98));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }
    .modalTitle{
      font-weight: 950;
      font-size: 14px;
      color: rgba(255,255,255,.92);
      letter-spacing:.2px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .modalBody{
      padding: 12px;
      overflow:auto;
      display:grid;
      gap: 12px;
    }
    .modalFooter{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 950;
      cursor:pointer;
      min-height: 46px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(16,185,129,.95), rgba(16,185,129,.65));
      border-color: rgba(16,185,129,.45);
      color: #062b1f;
    }
    .btn.danger{
      background: rgba(239,68,68,.12);
      border-color: rgba(239,68,68,.35);
      color: #ffd7d7;
    }
    .btn.ghost{ background: rgba(255,255,255,.03); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .card{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .label{
      font-size: 12px;
      color: rgba(255,255,255,.78);
      font-weight: 900;
      letter-spacing:.2px;
    }
    .mini{
      font-size: 12px;
      color: rgba(255,255,255,.60);
      line-height:1.35;
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 820px){ .grid3{ grid-template-columns: 1fr; } }
    @media (max-width: 680px){ .grid2{ grid-template-columns: 1fr; } }

    .field{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: 15px;
      outline: none;
    }
    .field:focus{
      border-color: rgba(16,185,129,.55);
      box-shadow: 0 0 0 4px rgba(16,185,129,.16);
    }
    .switch{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      user-select:none;
      min-height: 46px;
    }
    .switch .left{
      display:flex; align-items:center; gap:10px;
    }
    .switch input{ width: 20px; height: 20px; accent-color: var(--accent); }
    .switch span{ font-size: 15px; font-weight: 900; color: rgba(255,255,255,.92); }

    /* Map */
    #mapWrap{
      display:none;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    #map{ width: 100%; height: 320px; }

    /* Preview */
    .previewImg{
      width:100%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      display:block;
      max-height: 58vh;
      object-fit: contain;
    }
    .previewMeta{
      font-size:12px;
      color: rgba(255,255,255,.70);
      line-height:1.35;
      white-space: pre-wrap;
    }

    /* Toast */
    .toast{
      position:fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(18px + var(--safe-b));
      z-index: 60;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.62);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 12px;
      font-weight: 900;
      display:none;
      box-shadow: 0 20px 50px rgba(0,0,0,.55);
      max-width: min(92vw, 720px);
      text-align:center;
      backdrop-filter: blur(8px);
    }

    /* Busy overlay */
    .busy{
      position:fixed;
      inset:0;
      z-index: 70;
      background: rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 14px;
      text-align:center;
    }
    .busyCard{
      width:min(520px, 100%);
      background: rgba(15,22,32,.98);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 14px;
      display:grid;
      gap: 10px;
    }
    .busyTitle{ font-weight: 950; font-size: 14px; }
    .bar{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height:100%;
      width: 0%;
      background: rgba(16,185,129,.92);
      transition: width .15s linear;
    }
  </style>
</head>

<body>
  <!-- SVG Icons -->
  <svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
    <symbol id="i-bolt" viewBox="0 0 24 24">
      <path fill="currentColor" d="M13 2 3 14h7l-1 8 12-14h-7l-1-6z"/>
    </symbol>
    <symbol id="i-image" viewBox="0 0 24 24">
      <path fill="currentColor" d="M4 5a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5zm2 0v14h12V5H6zm2 10 2.5-3 2.5 3 1.5-2 3.5 5H8z"/>
    </symbol>
    <symbol id="i-download" viewBox="0 0 24 24">
      <path fill="currentColor" d="M12 3a1 1 0 0 1 1 1v9.59l2.3-2.3a1 1 0 1 1 1.4 1.42l-4 4a1 1 0 0 1-1.4 0l-4-4a1 1 0 1 1 1.4-1.42L11 13.59V4a1 1 0 0 1 1-1z"/>
      <path fill="currentColor" d="M5 19a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1z"/>
    </symbol>
    <symbol id="i-gear" viewBox="0 0 24 24">
      <path fill="currentColor" d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.1 7.1 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.42l-.36 2.54c-.58.23-1.12.54-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 7.48a.5.5 0 0 0 .12.64l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94L2.83 14.52a.5.5 0 0 0-.12.64l1.92 3.32c.13.22.39.3.6.22l2.39-.96c.51.4 1.05.71 1.63.94l.36 2.54c.04.24.25.42.49.42h3.8c.24 0 .45-.18.49-.42l.36-2.54c.58-.23 1.12-.54 1.63-.94l2.39.96c.22.09.47 0 .6-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8a3.5 3.5 0 0 1 0 7.5z"/>
    </symbol>
    <symbol id="i-switch" viewBox="0 0 24 24">
      <path fill="currentColor" d="M7 7h9l-1.5-1.5a1 1 0 0 1 1.4-1.4l3.2 3.2a1 1 0 0 1 0 1.4l-3.2 3.2a1 1 0 1 1-1.4-1.4L16 9H7a4 4 0 0 0-4 4v1a1 1 0 1 1-2 0v-1a6 6 0 0 1 6-6z"/>
      <path fill="currentColor" d="M17 17H8l1.5 1.5a1 1 0 1 1-1.4 1.4l-3.2-3.2a1 1 0 0 1 0-1.4l3.2-3.2a1 1 0 0 1 1.4 1.4L8 15h9a4 4 0 0 0 4-4v-1a1 1 0 1 1 2 0v1a6 6 0 0 1-6 6z"/>
    </symbol>
    <symbol id="i-trash" viewBox="0 0 24 24">
      <path fill="currentColor" d="M9 3a1 1 0 0 0-1 1v1H5a1 1 0 1 0 0 2h1v13a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7h1a1 1 0 1 0 0-2h-3V4a1 1 0 0 0-1-1H9zm1 2h4v0H10zM8 7h8v13H8V7zm2 2a1 1 0 0 1 1 1v7a1 1 0 1 1-2 0v-7a1 1 0 0 1 1-1zm5 0a1 1 0 0 1 1 1v7a1 1 0 1 1-2 0v-7a1 1 0 0 1 1-1z"/>
    </symbol>
  </svg>

  <div class="stage" id="stage">
    <!-- Viewfinder 4:3 portrait -->
    <div class="viewfinder" id="viewfinder">
      <video id="camVideo" playsinline autoplay muted></video>

      <!-- Live overlay preview (ไม่มีพื้นหลังดำ) -->
      <div class="liveOverlay" id="liveOverlay">
        <div class="overlayText" id="liveOverlayText"></div>
      </div>
    </div>

    <!-- Top bar -->
    <div class="topBar">
      <div class="topGroup">
        <div class="brandPill" title="PT Timestamp">
          <span class="dot" id="dotCam"></span>
          <span>PT Timestamp</span>
        </div>
      </div>

      <div class="topGroup">
        <button class="iconBtn" id="btnTorch" title="Torch/Flash" aria-label="Torch" disabled>
          <svg><use href="#i-bolt"></use></svg>
        </button>
        <button class="iconBtn" id="btnImport" title="Import from gallery" aria-label="Import">
          <svg><use href="#i-image"></use></svg>
        </button>
        <button class="iconBtn" id="btnDownloadAll" title="Download All" aria-label="Download All" disabled>
          <svg><use href="#i-download"></use></svg>
        </button>
        <button class="iconBtn" id="btnSettings" title="Settings" aria-label="Settings">
          <svg><use href="#i-gear"></use></svg>
        </button>
      </div>
    </div>

    <!-- Main time HUD (หน้าหลัก) -->
    <div class="timeHUD" id="timeHUD">
      <button class="timeModeBtn on" id="btnMainNow" type="button">NOW</button>
      <button class="timeLabelBtn" id="btnMainPick" type="button">-</button>
      <input id="mainTimeInput" type="datetime-local" style="display:none" />
    </div>

    <!-- Filmstrip -->
    <div class="filmstrip" id="filmstrip" aria-label="filmstrip"></div>

    <!-- Delete all (ขวาล่าง) -->
    <button class="fabDanger" id="btnDeleteAll" title="ลบทั้งหมด" aria-label="Delete All">
      <svg><use href="#i-trash"></use></svg>
    </button>

    <!-- Bottom camera controls -->
    <div class="bottomBar">
      <button class="miniBtn" id="btnLatest" title="เปิดพรีวิวรูปล่าสุด" aria-label="Latest" disabled>
        <img id="latestImg" class="latestThumbImg" alt="" style="display:none" />
        <svg id="latestPlaceholder" viewBox="0 0 24 24" style="display:block">
          <use href="#i-image"></use>
        </svg>
        <span class="countBadge" id="countBadge" style="display:none;">0</span>
      </button>

      <button class="shutter" id="btnShutter" title="Shutter" aria-label="Shutter"></button>

      <button class="miniBtn" id="btnSwitchCam" title="Switch camera" aria-label="Switch camera">
        <svg><use href="#i-switch"></use></svg>
      </button>
    </div>
  </div>

  <!-- Hidden file input (multiple) -->
  <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />

  <!-- Preview Modal -->
  <div class="backdrop" id="previewBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">Preview / Download</div>
        <button class="btn danger" id="btnClosePreview" style="min-height:42px; padding:10px 12px;">ปิด</button>
      </div>
      <div class="modalBody">
        <img id="previewImg" class="previewImg" alt="preview" />
        <div class="previewMeta" id="previewMeta">-</div>

        <!-- Per-photo time controls -->
        <div class="card">
          <div class="label">เวลา Stamp ของ “รูปนี้”</div>
          <label class="switch">
            <div class="left">
              <input id="photoUseCustomTime" type="checkbox" />
              <span>กำหนดเวลาเฉพาะรูปนี้</span>
            </div>
            <span class="mini">ถ้าปิด = ใช้เวลาหน้าหลัก</span>
          </label>
          <div class="grid2">
            <div>
              <div class="label">เวลาเฉพาะรูปนี้ (datetime-local)</div>
              <input id="photoTimeInput" class="field" type="datetime-local" disabled />
              <div class="mini">Tip: เปิดสวิตช์ด้านบนก่อน</div>
            </div>
            <div>
              <div class="label">ดึงค่าจากหน้าหลัก</div>
              <button class="btn" id="btnCopyMainTime">คัดลอกเวลาหน้าหลักใส่รูปนี้</button>
              <div class="mini">ช่วยตั้งเร็ว ๆ ให้เหมือนกันหลายรูป</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">Download options (ต่อรูป)</div>
          <div class="grid2">
            <div>
              <div class="label">ชนิดไฟล์</div>
              <select id="dlFormat" class="field">
                <option value="image/jpeg">JPG</option>
                <option value="image/png">PNG</option>
              </select>
              <div class="mini">Export ผ่าน canvas → ไฟล์ที่ได้ “ไม่มี EXIF/metadata ส่วนเกิน”</div>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="dlQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
              <div class="mini">ใช้เมื่อเลือก JPG เท่านั้น</div>
            </div>
          </div>

          <div style="display:flex; gap:10px; justify-content:space-between; flex-wrap:wrap;">
            <button class="btn danger" id="btnDeletePhoto" style="flex:1">ลบรูปนี้</button>
            <button class="btn primary" id="btnDownloadPhoto" style="flex:1">Download</button>
          </div>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn ghost" id="btnReRender">Re-render preview</button>
        <button class="btn" id="btnPrevPhoto">ก่อนหน้า</button>
        <button class="btn" id="btnNextPhoto">ถัดไป</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="backdrop" id="settingsBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">Settings</div>
        <button class="btn danger" id="btnCloseSettings" style="min-height:42px; padding:10px 12px;">ปิด</button>
      </div>

      <div class="modalBody">
        <div class="card">
          <div class="label">1) เวลา (Timestamp)</div>
          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="useNow" type="checkbox" checked />
                <span>ใช้เวลาปัจจุบัน</span>
              </div>
              <span class="mini" id="timeMini">-</span>
            </label>
            <div>
              <div class="label">แก้เวลาเอง (ถ้าไม่ติ๊กใช้เวลาปัจจุบัน)</div>
              <input id="customTime" class="field" type="datetime-local" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">รูปแบบเวลา</div>
              <select id="timeFormat" class="field">
                <option value="thai_verbose" selected>Thai verbose (แบบเดิม)</option>
                <option value="ddmmyyyy_hms">DD/MM/YYYY HH:mm:ss</option>
                <option value="yyyymmdd_hms">YYYY-MM-DD HH:mm:ss</option>
                <option value="iso">ISO 8601</option>
              </select>
              <div class="mini">Overlay จะ render ใหม่ทุกครั้งที่ Download/Preview</div>
            </div>
            <div>
              <div class="label">เส้นบรรทัดเวลา</div>
              <select id="timeLines" class="field">
                <option value="two" selected>2 บรรทัด (Network + Local)</option>
                <option value="one">1 บรรทัด</option>
              </select>
              <div class="mini">คงฟีเจอร์เดิมไว้ + ปรับได้</div>
            </div>
          </div>

          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnSetNow" style="flex:1">ตั้งเป็นเวลาปัจจุบัน</button>
          </div>
        </div>

        <div class="card">
          <div class="label">2) Output size (Preset/Original) + Fit</div>
          <div class="grid3">
            <div>
              <div class="label">โหมดขนาดส่งออก</div>
              <select id="outputMode" class="field">
                <option value="preset" selected>เลือกขนาด (Preset)</option>
                <option value="original">ขนาดรูปเดิม (ตามภาพจริง)</option>
              </select>
              <div class="mini">Preset = เลือกขนาดเอง • Original = ตามรูปจริง</div>
            </div>

            <div>
              <div class="label">Preset Size (แนวตั้งทั้งหมด)</div>
              <select id="outputSize" class="field">
                <!-- 3:4 (4:3 แนวตั้ง) -->
                <option value="1440x1920" selected>1440 × 1920 (3:4)</option>
                <option value="1200x1600">1200 × 1600 (3:4)</option>
                <option value="1536x2048">1536 × 2048 (3:4)</option>

                <!-- 9:16 -->
                <option value="1080x1920">1080 × 1920 (9:16)</option>
                <option value="720x1280">720 × 1280 (9:16)</option>

                <!-- 10:16 / 3:5-ish -->
                <option value="1200x1920">1200 × 1920</option>
                <option value="960x1600">960 × 1600</option>

                <!-- 20:9 / Tall -->
                <option value="1080x2400">1080 × 2400 (20:9)</option>
                <option value="720x1600">720 × 1600</option>

                <!-- Small vertical -->
                <option value="600x800">600 × 800 (3:4)</option>
                <option value="480x640">480 × 640 (3:4)</option>
                <option value="360x480">360 × 480 (3:4)</option>
              </select>
              <div class="mini">ถ้าเลือก Original จะปิด preset</div>
            </div>

            <div>
              <div class="label">Fit Mode</div>
              <select id="fitMode" class="field">
                <option value="contain" selected>Contain (มีขอบดำถ้าสัดส่วนไม่ตรง)</option>
                <option value="cover">Cover (เต็มเฟรม + ครอป)</option>
              </select>
              <div class="mini">ทั้งสองแบบ “ไม่ยืดภาพ”</div>
            </div>
          </div>
          <div class="mini" id="outStatus">-</div>
        </div>

        <div class="card">
          <div class="label">3) Overlay style (ค่าเริ่มต้น “ไม่มีพื้นหลังดำ”)</div>

          <div class="grid3">
            <div>
              <div class="label">ตำแหน่ง Overlay</div>
              <select id="overlayPos" class="field">
                <option value="tl">ซ้ายบน</option>
                <option value="tr" selected>ขวาบน</option>
                <option value="bl">ซ้ายล่าง</option>
                <option value="br">ขวาล่าง</option>
              </select>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayBoxEnable" type="checkbox" />
                  <span>กล่องพื้นหลังโปร่งดำ</span>
                </div>
                <span class="mini">แนะนำ: ปิด</span>
              </label>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayStrokeEnable" type="checkbox" checked />
                  <span>Stroke/Shadow</span>
                </div>
                <span class="mini">แนะนำ: เปิด</span>
              </label>
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">ฟอนต์</div>
              <label class="switch" style="margin-bottom:10px">
                <div class="left">
                  <input id="fontAuto" type="checkbox" checked />
                  <span>Auto (สเกลตาม Output)</span>
                </div>
                <span class="mini">เหมาะกับหลาย preset</span>
              </label>

              <div class="grid2">
                <div>
                  <div class="label">Auto scale (%)</div>
                  <input id="fontScale" class="field" type="number" min="50" max="250" step="5" value="100">
                </div>
                <div>
                  <div class="label">Fixed px (เมื่อปิด Auto)</div>
                  <input id="fontPx" class="field" type="number" min="10" max="200" step="1" value="32" disabled>
                </div>
              </div>
              <div class="mini">Auto จะคำนวณจาก output แล้วคูณด้วย %</div>
            </div>

            <div>
              <div class="label">ระยะขอบ/สเกลกล่อง</div>
              <div class="grid2">
                <div>
                  <div class="label">Margin scale (%)</div>
                  <input id="overlayMarginScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
                <div>
                  <div class="label">Padding scale (%)</div>
                  <input id="overlayPadScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
              </div>
              <div class="mini">ช่วยปรับให้เข้ากับภาพแนวตั้ง/แนวนอน</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="liveOverlayEnable" type="checkbox" checked />
                <span>แสดง overlay บนพรีวิวกล้อง</span>
              </div>
              <span class="mini">Preview-only</span>
            </label>
            <div class="mini">
              * Preview overlay เป็นไกด์ แต่ไฟล์จริงจะ render ผ่าน canvas ตอน Download/Preview
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">4) Location (Lat/Lng + Address via Nominatim)</div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="enableLocation" type="checkbox" />
                <span>เปิดใช้งานตำแหน่ง (Overlay)</span>
              </div>
              <span class="mini" id="locMini">ปิดใช้งาน</span>
            </label>

            <div class="grid2">
              <label class="switch">
                <div class="left">
                  <input id="showLatLng" type="checkbox" checked />
                  <span>แสดง Lat/Lng</span>
                </div>
              </label>
              <label class="switch">
                <div class="left">
                  <input id="showAddress" type="checkbox" checked />
                  <span>แสดงที่อยู่</span>
                </div>
              </label>
            </div>
          </div>

          <div class="grid2">
            <button class="btn" id="btnUseGPS">ใช้พิกัดปัจจุบัน (GPS)</button>
            <button class="btn" id="btnPickOnMap">เลือกจุดบนแผนที่</button>
          </div>

          <div class="grid2">
            <div>
              <div class="label">Lat</div>
              <input id="lat" class="field" type="number" step="any" placeholder="เช่น 13.7563" />
            </div>
            <div>
              <div class="label">Lng</div>
              <input id="lng" class="field" type="number" step="any" placeholder="เช่น 100.5018" />
            </div>
          </div>

          <div>
            <div class="label">ค้นหาสถานที่ (Forward geocode)</div>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <input id="placeQuery" class="field" placeholder="เช่น CentralWorld Bangkok" style="flex:1" />
              <button class="btn" id="btnSearchPlace">ค้นหา</button>
            </div>
          </div>

          <div id="mapWrap">
            <div id="map"></div>
            <div style="display:flex; gap:10px; padding:10px; flex-wrap:wrap;">
              <button class="btn primary" id="btnConfirmMap" style="flex:1">ยืนยันพิกัดนี้</button>
              <button class="btn danger" id="btnCloseMap" style="flex:1">ปิดแผนที่</button>
            </div>
          </div>

          <div class="mini" id="locStatus">-</div>
        </div>

        <div class="card">
          <div class="label">5) Download (Default)</div>
          <div class="grid3">
            <div>
              <div class="label">ชนิดไฟล์เริ่มต้น</div>
              <select id="defaultFormat" class="field">
                <option value="image/jpeg" selected>JPG</option>
                <option value="image/png">PNG</option>
              </select>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="jpgQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
            </div>
            <div>
              <div class="label">ชื่อไฟล์</div>
              <select id="namePattern" class="field">
                <option value="pt_now_index" selected>PT_YYYYMMDD_HHMMSS_<index></option>
                <option value="pt_capture_index">PT_(captureTime)_<index></option>
              </select>
              <div class="mini">Download All จะใช้เวลาเดียวกันทั้งชุด</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="preferFolderSave" type="checkbox" checked />
                <span>Download All แบบไม่ zip (โฟลเดอร์)</span>
              </div>
              <span class="mini">Chrome แนะนำ</span>
            </label>
            <label class="switch">
              <div class="left">
                <input id="zipFallback" type="checkbox" checked />
                <span>Fallback เป็น ZIP ถ้าบันทึกโฟลเดอร์ไม่ได้</span>
              </div>
              <span class="mini">ใช้ JSZip</span>
            </label>
          </div>

          <div class="mini">
            • “โฟลเดอร์” ต้องใช้ File System Access API (Chrome/Android มักรองรับ)<br>
            • ถ้าไม่รองรับ → ZIP → ถ้ายังไม่ได้ จะ fallback เป็นดาวน์โหลดทีละไฟล์
          </div>
        </div>
      </div>

      <div class="modalFooter">
        <button class="btn" id="btnResetSettings">รีเซ็ตค่า</button>
        <button class="btn primary" id="btnApplySettings">Apply/Save</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="busy" id="busy">
    <div class="busyCard">
      <div class="busyTitle" id="busyTitle">กำลังทำงาน...</div>
      <div class="mini" id="busyText">-</div>
      <div class="bar"><div id="busyBar"></div></div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button class="btn danger" id="btnBusyClose" style="flex:1">ปิด</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* =========================
     Storage
  ========================== */
  const SETTINGS_KEY = "PT_TS_SETTINGS_V2_4";

  const DEFAULT_SETTINGS = {
    // time
    useNow: true,
    customTime: "",
    timeFormat: "thai_verbose",
    timeLines: "two",

    // output
    outputMode: "preset",
    outputSize: "1440x1920", // <-- เปลี่ยนเป็นแนวตั้ง default
    fitMode: "contain",

    // overlay
    overlayPos: "tr",
    overlayBoxEnable: false,
    overlayStrokeEnable: true,
    overlayMarginScale: 100,
    overlayPadScale: 100,
    liveOverlayEnable: true,

    // font
    fontAuto: true,
    fontScale: 100,
    fontPx: 32,

    // location
    enableLocation: false,
    showLatLng: true,
    showAddress: true,
    lat: "",
    lng: "",
    placeQuery: "",

    // download
    defaultFormat: "image/jpeg",
    jpgQuality: 0.95,
    namePattern: "pt_now_index",
    preferFolderSave: true,
    zipFallback: true,

    // camera prefs
    preferredFacing: "environment",
    preferredDeviceId: "",
    torchOn: false
  };

  /* =========================
     Elements
  ========================== */
  const camVideo = document.getElementById("camVideo");
  const dotCam = document.getElementById("dotCam");

  const btnTorch = document.getElementById("btnTorch");
  const btnImport = document.getElementById("btnImport");
  const btnDownloadAll = document.getElementById("btnDownloadAll");
  const btnSettings = document.getElementById("btnSettings");
  const btnSwitchCam = document.getElementById("btnSwitchCam");

  const btnLatest = document.getElementById("btnLatest");
  const latestImg = document.getElementById("latestImg");
  const latestPlaceholder = document.getElementById("latestPlaceholder");
  const countBadge = document.getElementById("countBadge");

  const btnShutter = document.getElementById("btnShutter");

  const filmstrip = document.getElementById("filmstrip");
  const btnDeleteAll = document.getElementById("btnDeleteAll");

  const liveOverlay = document.getElementById("liveOverlay");
  const liveOverlayText = document.getElementById("liveOverlayText");

  const fileInput = document.getElementById("fileInput");

  // Main time HUD
  const btnMainNow = document.getElementById("btnMainNow");
  const btnMainPick = document.getElementById("btnMainPick");
  const mainTimeInput = document.getElementById("mainTimeInput");

  // Preview modal
  const previewBackdrop = document.getElementById("previewBackdrop");
  const btnClosePreview = document.getElementById("btnClosePreview");
  const previewImg = document.getElementById("previewImg");
  const previewMeta = document.getElementById("previewMeta");
  const dlFormat = document.getElementById("dlFormat");
  const dlQuality = document.getElementById("dlQuality");
  const btnDownloadPhoto = document.getElementById("btnDownloadPhoto");
  const btnDeletePhoto = document.getElementById("btnDeletePhoto");
  const btnPrevPhoto = document.getElementById("btnPrevPhoto");
  const btnNextPhoto = document.getElementById("btnNextPhoto");
  const btnReRender = document.getElementById("btnReRender");

  // Per-photo time UI
  const photoUseCustomTime = document.getElementById("photoUseCustomTime");
  const photoTimeInput = document.getElementById("photoTimeInput");
  const btnCopyMainTime = document.getElementById("btnCopyMainTime");

  // Settings modal
  const settingsBackdrop = document.getElementById("settingsBackdrop");
  const btnCloseSettings = document.getElementById("btnCloseSettings");
  const btnApplySettings = document.getElementById("btnApplySettings");
  const btnResetSettings = document.getElementById("btnResetSettings");

  const useNow = document.getElementById("useNow");
  const customTime = document.getElementById("customTime");
  const timeFormat = document.getElementById("timeFormat");
  const timeLines = document.getElementById("timeLines");
  const btnSetNow = document.getElementById("btnSetNow");
  const timeMini = document.getElementById("timeMini");

  const outputMode = document.getElementById("outputMode");
  const outputSize = document.getElementById("outputSize");
  const fitMode = document.getElementById("fitMode");
  const outStatus = document.getElementById("outStatus");

  const overlayPos = document.getElementById("overlayPos");
  const overlayBoxEnable = document.getElementById("overlayBoxEnable");
  const overlayStrokeEnable = document.getElementById("overlayStrokeEnable");
  const overlayMarginScale = document.getElementById("overlayMarginScale");
  const overlayPadScale = document.getElementById("overlayPadScale");
  const liveOverlayEnable = document.getElementById("liveOverlayEnable");

  const fontAuto = document.getElementById("fontAuto");
  const fontScale = document.getElementById("fontScale");
  const fontPx = document.getElementById("fontPx");

  const enableLocation = document.getElementById("enableLocation");
  const showLatLng = document.getElementById("showLatLng");
  const showAddress = document.getElementById("showAddress");
  const btnUseGPS = document.getElementById("btnUseGPS");
  const btnPickOnMap = document.getElementById("btnPickOnMap");
  const btnConfirmMap = document.getElementById("btnConfirmMap");
  const btnCloseMap = document.getElementById("btnCloseMap");
  const mapWrap = document.getElementById("mapWrap");
  const locStatus = document.getElementById("locStatus");
  const locMini = document.getElementById("locMini");

  const latEl = document.getElementById("lat");
  const lngEl = document.getElementById("lng");
  const placeQuery = document.getElementById("placeQuery");
  const btnSearchPlace = document.getElementById("btnSearchPlace");

  const defaultFormat = document.getElementById("defaultFormat");
  const jpgQuality = document.getElementById("jpgQuality");
  const namePattern = document.getElementById("namePattern");
  const preferFolderSave = document.getElementById("preferFolderSave");
  const zipFallback = document.getElementById("zipFallback");

  const toast = document.getElementById("toast");
  const busy = document.getElementById("busy");
  const busyTitle = document.getElementById("busyTitle");
  const busyText = document.getElementById("busyText");
  const busyBar = document.getElementById("busyBar");
  const btnBusyClose = document.getElementById("btnBusyClose");

  /* =========================
     Utils
  ========================== */
  const pad2 = (n) => String(n).padStart(2, "0");
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const toNumberOrNull = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  let toastTimer = null;
  function showToast(msg, ms=1600){
    toast.textContent = msg;
    toast.style.display = "block";
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { toast.style.display = "none"; }, ms);
  }

  function setBusy(on, title="กำลังทำงาน...", text="-", pct=null){
    busy.style.display = on ? "flex" : "none";
    busyTitle.textContent = title;
    busyText.textContent = text;
    if (pct === null) busyBar.style.width = "0%";
    else busyBar.style.width = `${clamp(pct,0,100)}%`;
  }

  function showModal(backdropEl, on){
    backdropEl.style.display = on ? "flex" : "none";
    backdropEl.setAttribute("aria-hidden", on ? "false" : "true");
  }

  /* =========================
     Settings
  ========================== */
  let settings = readSettings();

  function readSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return { ...DEFAULT_SETTINGS };
      const obj = JSON.parse(raw);
      return { ...DEFAULT_SETTINGS, ...(obj || {}) };
    } catch {
      return { ...DEFAULT_SETTINGS };
    }
  }
  function writeSettings(next){
    settings = { ...settings, ...(next || {}) };
    try{
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } catch {}
    applySettingsToUI();
  }

  let saveTimer = null;
  function scheduleSave(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      try{
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectSettingsFromUI()));
        settings = readSettings();
      } catch {}
      applySettingsToUI();
    }, 220);
  }

  function applySettingsToInputs(){
    useNow.checked = !!settings.useNow;
    customTime.value = settings.customTime || "";
    timeFormat.value = settings.timeFormat || "thai_verbose";
    timeLines.value = settings.timeLines || "two";

    outputMode.value = settings.outputMode || "preset";
    outputSize.value = settings.outputSize || "1440x1920";
    fitMode.value = settings.fitMode || "contain";

    overlayPos.value = settings.overlayPos || "tr";
    overlayBoxEnable.checked = !!settings.overlayBoxEnable;
    overlayStrokeEnable.checked = (settings.overlayStrokeEnable ?? true);
    overlayMarginScale.value = String(settings.overlayMarginScale ?? 100);
    overlayPadScale.value = String(settings.overlayPadScale ?? 100);
    liveOverlayEnable.checked = (settings.liveOverlayEnable ?? true);

    fontAuto.checked = !!settings.fontAuto;
    fontScale.value = String(settings.fontScale ?? 100);
    fontPx.value = String(settings.fontPx ?? 32);

    enableLocation.checked = !!settings.enableLocation;
    showLatLng.checked = (settings.showLatLng ?? true);
    showAddress.checked = (settings.showAddress ?? true);
    latEl.value = settings.lat ?? "";
    lngEl.value = settings.lng ?? "";
    placeQuery.value = settings.placeQuery ?? "";

    defaultFormat.value = settings.defaultFormat || "image/jpeg";
    jpgQuality.value = String(settings.jpgQuality ?? 0.95);
    namePattern.value = settings.namePattern || "pt_now_index";
    preferFolderSave.checked = (settings.preferFolderSave ?? true);
    zipFallback.checked = (settings.zipFallback ?? true);

    // Preview defaults
    dlFormat.value = settings.defaultFormat || "image/jpeg";
    dlQuality.value = String(settings.jpgQuality ?? 0.95);

    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    updateDownloadAllState();
  }

  function collectSettingsFromUI(){
    return {
      useNow: useNow.checked,
      customTime: customTime.value || "",
      timeFormat: timeFormat.value,
      timeLines: timeLines.value,

      outputMode: outputMode.value,
      outputSize: outputSize.value,
      fitMode: fitMode.value,

      overlayPos: overlayPos.value,
      overlayBoxEnable: overlayBoxEnable.checked,
      overlayStrokeEnable: overlayStrokeEnable.checked,
      overlayMarginScale: Number(overlayMarginScale.value) || 100,
      overlayPadScale: Number(overlayPadScale.value) || 100,
      liveOverlayEnable: liveOverlayEnable.checked,

      fontAuto: fontAuto.checked,
      fontScale: Number(fontScale.value) || 100,
      fontPx: Number(fontPx.value) || 32,

      enableLocation: enableLocation.checked,
      showLatLng: showLatLng.checked,
      showAddress: showAddress.checked,
      lat: latEl.value || "",
      lng: lngEl.value || "",
      placeQuery: placeQuery.value || "",

      defaultFormat: defaultFormat.value,
      jpgQuality: clamp(Number(jpgQuality.value) || 0.95, 0.5, 1),
      namePattern: namePattern.value,
      preferFolderSave: preferFolderSave.checked,
      zipFallback: zipFallback.checked,

      preferredFacing: settings.preferredFacing || "environment",
      preferredDeviceId: settings.preferredDeviceId || "",
      torchOn: settings.torchOn || false
    };
  }

  function applySettingsToUI(){
    applySettingsToInputs();
  }

  /* =========================
     Time formatting
  ========================== */
  function parseDatetimeLocalToDate(v){
    if (!v) return null;
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return null;
    return d;
  }

  function getGlobalDate(){
    if (useNow.checked) return new Date();
    const d = parseDatetimeLocalToDate(customTime.value);
    return d;
  }

  function formatThaiVerbose(date){
    const d = date.getDate();
    const m = date.toLocaleString("th-TH", { month: "short" });
    const y = date.getFullYear();
    const hh = date.getHours();
    const mm = date.getMinutes();
    const ss = date.getSeconds();
    const tz = "GMT+07:00";
    return `${d} ${m}. ${y} ${hh} นาฬิกา ${mm} นาที ${ss} วินาที ${tz}`;
  }
  function formatDDMMYYYY(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${dd}/${MM}/${yyyy} ${HH}:${mm}:${ss}`;
  }
  function formatYYYYMMDD(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${yyyy}-${MM}-${dd} ${HH}:${mm}:${ss}`;
  }
  function formatTimestamp(date){
    switch (timeFormat.value){
      case "ddmmyyyy_hms": return formatDDMMYYYY(date);
      case "yyyymmdd_hms": return formatYYYYMMDD(date);
      case "iso": return date.toISOString();
      case "thai_verbose":
      default: return formatThaiVerbose(date);
    }
  }
  function buildTimeLines(date){
    const t = formatTimestamp(date);
    if ((timeLines.value || "two") === "one") return [`Timestamp: ${t}`];
    return [`Network: ${t}`, `Local: ${t}`];
  }
  function updateTimeMini(){
    const d = getGlobalDate();
    timeMini.textContent = d ? formatTimestamp(d) : "กรุณาเลือกเวลา";
  }

  /* =========================
     Main Time HUD (หน้าหลัก)
  ========================== */
  function dateToDatetimeLocalValue(date){
    const yyyy = date.getFullYear();
    const MM = pad2(date.getMonth()+1);
    const dd = pad2(date.getDate());
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    return `${yyyy}-${MM}-${dd}T${HH}:${mm}`;
  }

  function syncMainTimeHUDFromSettings(){
    btnMainNow.classList.toggle("on", useNow.checked);
    btnMainNow.textContent = useNow.checked ? "NOW" : "SET";

    const d = getGlobalDate() || new Date();
    const label = (timeFormat.value === "thai_verbose")
      ? formatDDMMYYYY(d)
      : formatTimestamp(d);

    btnMainPick.textContent = label;
  }

  btnMainNow.addEventListener("click", () => {
    useNow.checked = !useNow.checked;
    if (useNow.checked){
      syncMainTimeHUDFromSettings();
      scheduleSave();
      updateLiveOverlay();
      showToast("ใช้เวลาปัจจุบัน");
    } else {
      if (!customTime.value){
        customTime.value = dateToDatetimeLocalValue(new Date());
      }
      syncMainTimeHUDFromSettings();
      scheduleSave();
      updateLiveOverlay();
      setTimeout(() => { mainTimeInput.value = customTime.value; mainTimeInput.click(); }, 50);
    }
  });

  btnMainPick.addEventListener("click", () => {
    useNow.checked = false;
    if (!customTime.value){
      customTime.value = dateToDatetimeLocalValue(new Date());
    }
    mainTimeInput.value = customTime.value;
    syncMainTimeHUDFromSettings();
    scheduleSave();
    updateLiveOverlay();
    mainTimeInput.click();
  });

  mainTimeInput.addEventListener("change", () => {
    if (!mainTimeInput.value) return;
    useNow.checked = false;
    customTime.value = mainTimeInput.value;
    syncMainTimeHUDFromSettings();
    updateTimeMini();
    scheduleSave();
    updateLiveOverlay();
    showToast("ตั้งเวลาแล้ว");
  });

  setInterval(() => {
    if (useNow.checked){
      syncMainTimeHUDFromSettings();
      updateLiveOverlay();
    }
  }, 1000);

  /* =========================
     Output + Font
  ========================== */
  function parseOutputSize(){
    const v = (outputSize.value || "1440x1920").toLowerCase().trim();
    const m = v.match(/^(\d+)\s*x\s*(\d+)$/);
    if (!m) return { w: 1440, h: 1920 };
    const w = Number(m[1]);
    const h = Number(m[2]);
    if (!Number.isFinite(w) || !Number.isFinite(h) || w < 1 || h < 1) return { w: 1440, h: 1920 };
    return { w, h };
  }

  function updateOutputUI(){
    const mode = outputMode.value;
    outputSize.disabled = (mode !== "preset");
    fitMode.disabled = (mode !== "preset");
    if (mode === "original"){
      outStatus.textContent = "Output = ขนาดรูปเดิม (ตามภาพจริง)";
    } else {
      const { w, h } = parseOutputSize();
      outStatus.textContent = `Output = ${w}×${h} • Fit = ${fitMode.value === "contain" ? "Contain" : "Cover"}`;
    }
  }

  function updateFontUI(){
    const auto = fontAuto.checked;
    fontScale.disabled = !auto;
    fontPx.disabled = auto;
  }

  function computeFontSizePx(outW, outH){
    if (!fontAuto.checked){
      const px = Number(fontPx.value);
      return clamp(Number.isFinite(px) ? px : 32, 10, 200);
    }
    const base = Math.min(outW, outH);
    const autoPx = clamp(Math.round(base * 0.022), 12, 220);
    const scalePct = clamp(Number(fontScale.value) || 100, 50, 250);
    return clamp(Math.round(autoPx * (scalePct / 100)), 10, 240);
  }

  /* =========================
     Location + Geocode
  ========================== */
  function hasValidLatLng(){
    const lat = toNumberOrNull(latEl.value);
    const lng = toNumberOrNull(lngEl.value);
    if (lat === null || lng === null) return false;
    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
  }

  let addressText = "";
  let addressCacheKey = "";
  let lastGeoFetchAt = 0;

  async function reverseGeocode(lat, lng){
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=18&addressdetails=1`;
    const res = await fetch(url, {
      headers: { "Accept":"application/json", "Accept-Language":"th-TH,th;q=0.9,en;q=0.7" }
    });
    if (!res.ok) throw new Error("Reverse geocode failed");
    const data = await res.json();
    return data?.display_name || "";
  }

  async function forwardGeocode(q){
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&limit=1`;
    const res = await fetch(url, {
      headers: { "Accept":"application/json", "Accept-Language":"th-TH,th;q=0.9,en;q=0.7" }
    });
    if (!res.ok) throw new Error("Search place failed");
    const data = await res.json();
    if (!Array.isArray(data) || data.length === 0) return null;
    return { lat: Number(data[0].lat), lng: Number(data[0].lon), display_name: data[0].display_name || "" };
  }

  async function refreshAddressIfNeeded(){
    addressText = "";
    addressCacheKey = "";

    if (!enableLocation.checked){
      locStatus.textContent = "ปิดใช้งานตำแหน่ง";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }
    if (!hasValidLatLng()){
      locStatus.textContent = "เปิดใช้งานตำแหน่ง แต่ยังไม่มี Lat/Lng ที่ถูกต้อง";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|${showAddress.checked ? "addr" : "noaddr"}`;
    addressCacheKey = key;

    let msg = `Lat/Lng: ${lat.toFixed(6)}, ${lng.toFixed(6)}\n`;

    if (showAddress.checked){
      locStatus.textContent = msg + "กำลังดึงที่อยู่จาก Nominatim...";
      try{
        addressText = await reverseGeocode(lat, lng);
        msg += `Address: ${addressText || "(ไม่พบที่อยู่)"}`;
      } catch {
        msg += "Address: (ดึงที่อยู่ไม่ได้ — แนะนำเปิดผ่าน https)";
      }
    } else {
      msg += "Address: (ปิดการแสดงที่อยู่)";
    }

    locStatus.textContent = msg;
    refreshLocMini();
    updateLiveOverlay();
  }

  function refreshLocMini(){
    if (!enableLocation.checked){
      locMini.textContent = "ปิดใช้งาน";
      return;
    }
    if (hasValidLatLng()){
      locMini.textContent = `ON • ${Number(latEl.value).toFixed(4)}, ${Number(lngEl.value).toFixed(4)}`;
    } else {
      locMini.textContent = "ON • ยังไม่มีพิกัด";
    }
  }

  async function ensureAddressLazy(){
    if (!enableLocation.checked) return;
    if (!hasValidLatLng()) return;
    if (!showAddress.checked) return;
    if (addressText) return;

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|addr`;
    if (addressCacheKey === key && addressText) return;

    try{
      addressText = await reverseGeocode(lat, lng);
      addressCacheKey = key;
    } catch {}
  }

  /* =========================
     Overlay lines + Drawing
  ========================== */
  function buildOverlayLines(date){
    const lines = [];
    lines.push(...buildTimeLines(date));

    if (enableLocation.checked && hasValidLatLng()){
      const lat = Number(latEl.value);
      const lng = Number(lngEl.value);
      if (showLatLng.checked) lines.push(`📍 ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
      if (showAddress.checked) lines.push(addressText ? addressText : "(ที่อยู่ยังไม่พร้อม)");
    }
    return lines;
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawOverlayOnCanvas(ctx, lines, outW, outH){
    if (!lines || lines.length === 0) return;

    const fontSize = computeFontSizePx(outW, outH);
    const lineGap = Math.round(fontSize * 1.18);
    const marginScalePct = clamp(Number(overlayMarginScale.value) || 100, 50, 200);
    const padScalePct = clamp(Number(overlayPadScale.value) || 100, 50, 200);

    const margin = Math.round(Math.min(outW, outH) * 0.018 * (marginScalePct/100));
    const pad = Math.round(fontSize * 0.55 * (padScalePct/100));

    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");

    ctx.save();
    ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif`;
    ctx.textBaseline = "top";
    ctx.textAlign = isLeft ? "left" : "right";

    let maxW = 0;
    for (const line of lines){
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    }
    const boxW = Math.round(maxW + pad*2);
    const boxH = Math.round(lines.length * lineGap + pad*2 - (lineGap - fontSize));

    const x = isLeft ? margin : (outW - margin);
    const y = isTop ? margin : (outH - margin - boxH);
    const boxX = isLeft ? x : (x - boxW);

    if (overlayBoxEnable.checked){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = Math.max(1, Math.round(fontSize * 0.06));
      roundRect(ctx, boxX, y, boxW, boxH, Math.round(fontSize * 0.6));
      ctx.fill();
      ctx.stroke();
    }

    if (overlayStrokeEnable.checked){
      ctx.shadowColor = "rgba(0,0,0,.85)";
      ctx.shadowBlur = Math.round(fontSize * 0.45);
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = "#fff";
    const textX = isLeft ? (boxX + pad) : (boxX + boxW - pad);
    let ty = y + pad;

    for (const line of lines){
      if (overlayStrokeEnable.checked){
        ctx.save();
        ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,.70)";
        ctx.strokeText(line, textX, ty);
        ctx.restore();
      }
      ctx.fillText(line, textX, ty);
      ty += lineGap;
    }

    ctx.restore();
  }

  function updateLiveOverlay(){
    if (!liveOverlayEnable.checked){
      liveOverlayText.style.display = "none";
      return;
    }
    const d = getGlobalDate();
    if (!d){
      liveOverlayText.style.display = "none";
      return;
    }
    const lines = buildOverlayLines(d);
    if (!lines.length){
      liveOverlayText.style.display = "none";
      return;
    }

    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");
    liveOverlay.style.alignItems = isTop ? "flex-start" : "flex-end";
    liveOverlay.style.justifyContent = isLeft ? "flex-start" : "flex-end";

    liveOverlayText.style.display = "block";
    liveOverlayText.textContent = lines.join("\n");
  }

  /* =========================
     EXIF orientation fix
  ========================== */
  async function getExifOrientation(file){
    try{
      if (!file || !file.type || !file.type.toLowerCase().includes("jpeg")) return 1;
      const buf = await file.arrayBuffer();
      const view = new DataView(buf);

      if (view.getUint16(0, false) !== 0xFFD8) return 1;
      let offset = 2;
      const length = view.byteLength;

      while (offset < length){
        if (view.getUint8(offset) !== 0xFF) break;
        const marker = view.getUint16(offset, false);
        offset += 2;

        if (marker === 0xFFE1){
          offset += 2;
          if (view.getUint32(offset, false) !== 0x45786966) return 1;
          offset += 6;

          const tiffOffset = offset;
          const endianness = view.getUint16(tiffOffset, false);
          const little = (endianness === 0x4949);
          if (!little && endianness !== 0x4D4D) return 1;

          const getU16 = (o) => view.getUint16(o, little);
          const getU32 = (o) => view.getUint32(o, little);

          if (getU16(tiffOffset + 2) !== 0x002A) return 1;

          const ifd0Offset = getU32(tiffOffset + 4);
          let dirOffset = tiffOffset + ifd0Offset;
          if (dirOffset < 0 || dirOffset > length - 2) return 1;

          const entries = getU16(dirOffset);
          dirOffset += 2;

          for (let i=0;i<entries;i++){
            const entryOffset = dirOffset + i*12;
            if (entryOffset + 12 > length) break;
            const tag = getU16(entryOffset);
            if (tag === 0x0112){
              const type = getU16(entryOffset + 2);
              const count = getU32(entryOffset + 4);
              if (type !== 3 || count !== 1) return 1;
              const valOffset = entryOffset + 8;
              const orient = getU16(valOffset);
              return (orient >= 1 && orient <= 8) ? orient : 1;
            }
          }
          return 1;
        } else {
          if (offset + 2 > length) break;
          const size = view.getUint16(offset, false);
          offset += size;
        }
      }
      return 1;
    } catch {
      return 1;
    }
  }

  async function blobToImage(blob){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const im = new Image();
      im.onload = () => resolve({ im, url });
      im.onerror = () => { try{ URL.revokeObjectURL(url);}catch{}; reject(new Error("Image onerror(blobUrl)")); };
      im.src = url;
    });
  }

  function drawWithOrientationToCanvas(img, orientation){
    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const c = document.createElement("canvas");
    const cctx = c.getContext("2d");

    if ([5,6,7,8].includes(orientation)){ c.width = h; c.height = w; }
    else { c.width = w; c.height = h; }

    cctx.save();
    switch (orientation){
      case 2: cctx.translate(w, 0); cctx.scale(-1, 1); break;
      case 3: cctx.translate(w, h); cctx.rotate(Math.PI); break;
      case 4: cctx.translate(0, h); cctx.scale(1, -1); break;
      case 5: cctx.rotate(0.5*Math.PI); cctx.scale(1, -1); break;
      case 6: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); break;
      case 7: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); cctx.scale(-1, 1); break;
      case 8: cctx.translate(0, w); cctx.rotate(-0.5*Math.PI); break;
      default: break;
    }
    cctx.drawImage(img, 0, 0);
    cctx.restore();
    return c;
  }

  function drawContain(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.min(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  function drawCover(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.max(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  /* =========================
     Session Gallery
     IMPORTANT: ลบรูป = ลบจริง (ถูกตัดออกจาก photos array)
  ========================== */
  const photos = []; // {id, blob, type, fromCamera, capturedAt, exifOrientation, thumbUrl, correctedCacheCanvas, lastPreviewUrl, stampMode, stampTime}
  let activePhotoId = null;

  function updateDownloadAllState(){
    btnDownloadAll.disabled = photos.length === 0;
    btnDeleteAll.style.display = photos.length > 0 ? "inline-flex" : "none";
    btnLatest.disabled = photos.length === 0;
    countBadge.style.display = photos.length > 0 ? "block" : "none";
    countBadge.textContent = String(photos.length);
  }

  function updateLatestThumb(){
    if (photos.length === 0){
      latestImg.style.display = "none";
      latestPlaceholder.style.display = "block";
      btnLatest.disabled = true;
      updateDownloadAllState();
      return;
    }
    const p = photos[photos.length - 1];
    if (p.thumbUrl){
      latestImg.src = p.thumbUrl;
      latestImg.style.display = "block";
      latestPlaceholder.style.display = "none";
      btnLatest.disabled = false;
    } else {
      latestImg.style.display = "none";
      latestPlaceholder.style.display = "block";
    }
    updateDownloadAllState();
  }

  function renderFilmstrip(){
    filmstrip.innerHTML = "";
    if (photos.length === 0){
      const empty = document.createElement("div");
      empty.className = "emptyPill";
      empty.textContent = "ยังไม่มีรูป — ถ่าย หรือ Import";
      filmstrip.appendChild(empty);
      updateLatestThumb();
      return;
    }

    photos.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "thumb" + (p.id === activePhotoId ? " active" : "");
      div.dataset.id = p.id;

      const img = document.createElement("img");
      img.alt = `thumb ${idx+1}`;
      img.src = p.thumbUrl || "";
      div.appendChild(img);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(idx+1);
      div.appendChild(num);

      const del = document.createElement("div");
      del.className = "del";
      del.textContent = "×";
      del.title = "ลบรูปนี้";
      del.addEventListener("click", (e) => {
        e.stopPropagation();
        removePhotoById(p.id);
      });
      div.appendChild(del);

      div.addEventListener("click", () => openPreview(p.id));
      filmstrip.appendChild(div);
    });

    updateLatestThumb();
  }

  async function generateThumbnailForPhoto(p){
    try{
      const { im, url } = await blobToImage(p.blob);
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected;
      try { URL.revokeObjectURL(url); } catch {}

      const maxSide = 260;
      const tw = corrected.width;
      const th = corrected.height;
      const scale = Math.min(1, maxSide / Math.max(tw, th));
      const cw = Math.max(1, Math.round(tw * scale));
      const ch = Math.max(1, Math.round(th * scale));
      const tcan = document.createElement("canvas");
      tcan.width = cw;
      tcan.height = ch;
      tcan.getContext("2d").drawImage(corrected, 0,0, tw,th, 0,0, cw,ch);

      p.thumbUrl = tcan.toDataURL("image/jpeg", 0.85);
    } catch {
      p.thumbUrl = "";
    }
    renderFilmstrip();
  }

  async function addPhotoFromBlob(blob, {fromCamera=false, capturedAt=null, exifOrientation=1} = {}){
    const id = `p_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const p = {
      id,
      blob,
      type: blob.type || "image/jpeg",
      fromCamera: !!fromCamera,
      capturedAt: capturedAt || new Date(),
      exifOrientation,
      thumbUrl: "",
      correctedCacheCanvas: null,
      lastPreviewUrl: "",
      stampMode: "global",
      stampTime: ""
    };
    photos.push(p);
    activePhotoId = id;
    renderFilmstrip();
    await generateThumbnailForPhoto(p);
    showToast(fromCamera ? "ถ่ายแล้ว" : "นำเข้าแล้ว");
    renderFilmstrip();
  }

  async function addPhotosFromFiles(fileList){
    const files = Array.from(fileList || []).filter(Boolean);
    if (files.length === 0) return;

    setBusy(true, "กำลังนำเข้ารูป...", `0 / ${files.length}`, 0);

    for (let i=0;i<files.length;i++){
      const f = files[i];
      try{
        const orient = await getExifOrientation(f);
        await addPhotoFromBlob(f, { fromCamera:false, capturedAt:new Date(), exifOrientation: orient });
      } catch {}
      const pct = Math.round(((i+1)/files.length)*100);
      setBusy(true, "กำลังนำเข้ารูป...", `${i+1} / ${files.length}`, pct);
    }
    setBusy(false);
  }

  function findPhotoIndexById(id){
    return photos.findIndex(p => p.id === id);
  }
  function getActivePhoto(){
    if (!activePhotoId) return null;
    return photos.find(p => p.id === activePhotoId) || null;
  }

  function removePhotoById(id){
    const idx = findPhotoIndexById(id);
    if (idx < 0) return;
    const p = photos[idx];
    try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
    photos.splice(idx, 1); // <-- ลบจริง

    if (photos.length === 0){
      activePhotoId = null;
      showToast("ลบรูปแล้ว");
      closePreview();
    } else {
      const nextIdx = Math.min(idx, photos.length-1);
      activePhotoId = photos[nextIdx].id;
      showToast("ลบรูปแล้ว");
      if (previewBackdrop.style.display === "flex") renderPreview();
    }

    renderFilmstrip();
  }

  function deleteAllPhotos(){
    if (photos.length === 0) return;
    const ok = confirm(`ลบทั้งหมด ${photos.length} รูป?\n(ยกเลิกได้ด้วย Cancel)`);
    if (!ok) return;

    for (const p of photos){
      try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
    }
    photos.length = 0;
    activePhotoId = null;
    renderFilmstrip();
    closePreview();
    showToast("ลบทั้งหมดแล้ว");
  }

  /* =========================
     Per-photo time helpers
  ========================== */
  function getStampDateForPhoto(p){
    if (p?.stampMode === "custom"){
      const d = parseDatetimeLocalToDate(p.stampTime);
      if (d) return d;
    }
    return getGlobalDate();
  }

  function applyPhotoTimeUI(p){
    if (!p) return;
    const isCustom = (p.stampMode === "custom");
    photoUseCustomTime.checked = isCustom;
    photoTimeInput.disabled = !isCustom;

    if (isCustom){
      if (!p.stampTime){
        const gd = getGlobalDate() || new Date();
        p.stampTime = dateToDatetimeLocalValue(gd);
      }
      photoTimeInput.value = p.stampTime;
    } else {
      photoTimeInput.value = "";
    }
  }

  /* =========================
     Render per photo
  ========================== */
  async function getCorrectedCanvasForPhoto(p){
    if (p.correctedCacheCanvas) return p.correctedCacheCanvas;

    const { im, url } = await blobToImage(p.blob);
    try{
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected;
      return corrected;
    } finally {
      try{ URL.revokeObjectURL(url); } catch {}
    }
  }

  function getOutputDims(srcW, srcH){
    if (outputMode.value === "original"){
      return { outW: srcW, outH: srcH, mode: "original" };
    }
    const { w, h } = parseOutputSize();
    return { outW: w, outH: h, mode: "preset" };
  }

  async function renderPhotoToBlob(p, { mime=null, quality=null } = {}){
    const d = getStampDateForPhoto(p);
    if (!d) throw new Error("กรุณาเลือกเวลา (NOW หรือ เลือกเอง)");

    await ensureAddressLazy();

    const src = await getCorrectedCanvasForPhoto(p);
    const sw = src.width;
    const sh = src.height;

    const { outW, outH } = getOutputDims(sw, sh);
    const outCanvas = document.createElement("canvas");
    outCanvas.width = outW;
    outCanvas.height = outH;
    const ctx = outCanvas.getContext("2d", { alpha:false });

    if (outputMode.value === "original"){
      ctx.drawImage(src, 0,0, sw,sh, 0,0, outW,outH);
    } else {
      if (fitMode.value === "cover") drawCover(ctx, src, outW, outH);
      else drawContain(ctx, src, outW, outH);
    }

    const lines = buildOverlayLines(d);
    drawOverlayOnCanvas(ctx, lines, outW, outH);

    const finalMime = mime || defaultFormat.value || "image/jpeg";
    let q = quality;
    if (q == null) q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const blob = await new Promise((resolve, reject) => {
      outCanvas.toBlob((b) => {
        if (!b) return reject(new Error("toBlob failed"));
        resolve(b);
      }, finalMime, finalMime === "image/jpeg" ? q : undefined);
    });

    return { blob, outW, outH, linesCount: lines.length, mime: finalMime, quality: finalMime === "image/jpeg" ? q : null };
  }

  function buildFilename(baseDate, index1, ext, p){
    const yyyy = baseDate.getFullYear();
    const MM = pad2(baseDate.getMonth()+1);
    const dd = pad2(baseDate.getDate());
    const HH = pad2(baseDate.getHours());
    const mm = pad2(baseDate.getMinutes());
    const ss = pad2(baseDate.getSeconds());

    const idx = String(index1).padStart(2, "0");
    const stampNow = `${yyyy}${MM}${dd}_${HH}${mm}${ss}`;

    if (namePattern.value === "pt_capture_index" && p?.capturedAt){
      const cd = p.capturedAt;
      const cy = cd.getFullYear();
      const cM = pad2(cd.getMonth()+1);
      const cD = pad2(cd.getDate());
      const cH = pad2(cd.getHours());
      const cm = pad2(cd.getMinutes());
      const cs = pad2(cd.getSeconds());
      return `PT_${cy}${cM}${cD}_${cH}${cm}${cs}_${idx}.${ext}`;
    }
    return `PT_${stampNow}_${idx}.${ext}`;
  }

  function triggerDownload(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => { try{ URL.revokeObjectURL(url);}catch{} }, 1200);
  }

  /* =========================
     Preview flow
  ========================== */
  function openPreview(id){
    activePhotoId = id;
    renderFilmstrip();
    showModal(previewBackdrop, true);
    const p = getActivePhoto();
    applyPhotoTimeUI(p);
    renderPreview();
  }

  function closePreview(){
    showModal(previewBackdrop, false);
  }

  async function renderPreview(){
    const p = getActivePhoto();
    if (!p){
      previewMeta.textContent = "ไม่มีรูป";
      return;
    }

    btnDownloadPhoto.disabled = true;
    btnDeletePhoto.disabled = true;
    btnReRender.disabled = true;

    previewMeta.textContent = "กำลัง render...";
    previewImg.src = "";

    try{
      setBusy(true, "กำลัง render preview...", "โปรดรอสักครู่", null);

      const mime = dlFormat.value || "image/jpeg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const url = URL.createObjectURL(r.blob);

      try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
      p.lastPreviewUrl = url;

      previewImg.src = url;

      const idx = findPhotoIndexById(p.id);
      const ext = (mime === "image/png") ? "png" : "jpg";
      const filename = buildFilename(new Date(), idx+1, ext, p);

      const usedDate = getStampDateForPhoto(p);
      const usedStr = usedDate ? formatDDMMYYYY(usedDate) : "-";
      const modeStr = (p.stampMode === "custom") ? "custom (per-photo)" : "global";

      previewMeta.textContent =
        `#${idx+1}\n` +
        `StampTime: ${modeStr} • ${usedStr}\n` +
        `Source: ${p.fromCamera ? "Camera" : "File"} • EXIF: ${p.fromCamera ? "-" : (p.exifOrientation || 1)}\n` +
        `Output: ${r.outW}×${r.outH} • Lines: ${r.linesCount}\n` +
        `Format: ${mime === "image/png" ? "PNG" : `JPG (q=${r.quality})`}\n` +
        `Filename: ${filename}`;

      btnDownloadPhoto.disabled = false;
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;

      setBusy(false);
      updateLiveOverlay();
    } catch (e){
      setBusy(false);
      previewMeta.textContent = `Render ไม่สำเร็จ: ${String(e.message || e)}`;
      showToast("Render ไม่สำเร็จ");
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;
    }
  }

  /* =========================
     Download All
     IMPORTANT: จะดาวน์โหลดเฉพาะ “ที่เหลืออยู่จริง” ใน photos[]
  ========================== */
  async function downloadAll(){
    if (photos.length === 0) return;

    const mime = defaultFormat.value || "image/jpeg";
    const ext = (mime === "image/png") ? "png" : "jpg";
    const q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const batchDate = new Date();
    const canFS = !!window.showDirectoryPicker;

    try{
      setBusy(true, "Download All", "กำลังเตรียม...", 0);

      if (preferFolderSave.checked && canFS){
        const dir = await window.showDirectoryPicker({ mode: "readwrite" });

        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All", `กำลัง render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);

          const handle = await dir.getFileHandle(filename, { create:true });
          const writable = await handle.createWritable();
          await writable.write(r.blob);
          await writable.close();

          setBusy(true, "Download All", `บันทึกแล้ว: ${i+1} / ${photos.length}`, Math.round(((i+1)/photos.length)*100));
        }

        setBusy(false);
        showToast("Download All เสร็จแล้ว (โฟลเดอร์)");
        return;
      }

      if (zipFallback.checked && window.JSZip){
        const zip = new window.JSZip();
        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All (ZIP)", `กำลัง render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);
          zip.file(filename, r.blob);
        }

        setBusy(true, "Download All (ZIP)", "กำลังสร้าง ZIP...", 96);
        const zipBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
          const pct = clamp(Math.round(meta.percent), 0, 100);
          setBusy(true, "Download All (ZIP)", `กำลังสร้าง ZIP... ${pct}%`, pct);
        });

        const zipName = `PT_${batchDate.getFullYear()}${pad2(batchDate.getMonth()+1)}${pad2(batchDate.getDate())}_${pad2(batchDate.getHours())}${pad2(batchDate.getMinutes())}${pad2(batchDate.getSeconds())}.zip`;
        triggerDownload(zipBlob, zipName);
        setBusy(false);
        showToast("Download All เสร็จแล้ว (ZIP)");
        return;
      }

      for (let i=0;i<photos.length;i++){
        const p = photos[i];
        setBusy(true, "Download All (fallback)", `กำลัง render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));
        const r = await renderPhotoToBlob(p, { mime, quality: q });
        const filename = buildFilename(batchDate, i+1, ext, p);
        triggerDownload(r.blob, filename);
        await new Promise(r => setTimeout(r, 180));
      }

      setBusy(false);
      showToast("Download All เสร็จแล้ว");
    } catch (e){
      setBusy(false);
      showToast("Download All ไม่สำเร็จ");
    }
  }

  /* =========================
     Camera
  ========================== */
  let camStream = null;
  let currentFacing = "environment";
  let videoDevices = [];
  let selectedDeviceId = "";

  function setCamIndicator(ok){
    dotCam.className = "dot " + (ok ? "ok" : "err");
  }

  function isUserFacingNow(){
    return (currentFacing === "user");
  }

  function applyMirrorClass(){
    camVideo.classList.toggle("mirror", isUserFacingNow());
  }

  async function stopCamera(){
    try{
      if (camStream) camStream.getTracks().forEach(t => t.stop());
    } catch {}
    camStream = null;
    camVideo.srcObject = null;
    btnTorch.disabled = true;
    btnTorch.classList.remove("on");
    setCamIndicator(false);
  }

  async function refreshDevices(){
    if (!navigator.mediaDevices?.enumerateDevices) return [];
    const all = await navigator.mediaDevices.enumerateDevices();
    videoDevices = all.filter(d => d.kind === "videoinput");
    return videoDevices;
  }

  function getVideoTrack(){
    try{ return camStream?.getVideoTracks?.()[0] || null; }
    catch { return null; }
  }

  async function refreshTorchSupport(){
    const track = getVideoTrack();
    if (!track){
      btnTorch.disabled = true;
      btnTorch.classList.remove("on");
      return;
    }
    const caps = track.getCapabilities ? track.getCapabilities() : null;
    const supported = !!(caps && "torch" in caps);
    btnTorch.disabled = !supported;
    if (!supported){
      btnTorch.classList.remove("on");
      settings.torchOn = false;
      return;
    }
    btnTorch.classList.toggle("on", !!settings.torchOn);
  }

  async function setTorch(on){
    const track = getVideoTrack();
    if (!track || !track.applyConstraints) throw new Error("torch not supported");
    await track.applyConstraints({ advanced: [{ torch: !!on }] });
    settings.torchOn = !!on;
    btnTorch.classList.toggle("on", !!on);
    writeSettings({ torchOn: !!on });
  }

  async function startCamera({ forceFacing=null, forceDeviceId=null } = {}){
    if (!navigator.mediaDevices?.getUserMedia){
      setCamIndicator(false);
      showToast("เบราว์เซอร์นี้ไม่รองรับกล้อง");
      return;
    }

    try{
      await stopCamera();

      currentFacing = forceFacing || settings.preferredFacing || "environment";
      selectedDeviceId = forceDeviceId || settings.preferredDeviceId || "";

      const constraints = {
        video: { width:{ideal:1920}, height:{ideal:1080} },
        audio: false
      };

      if (selectedDeviceId) constraints.video.deviceId = { exact: selectedDeviceId };
      else constraints.video.facingMode = { ideal: currentFacing };

      camStream = await navigator.mediaDevices.getUserMedia(constraints);
      camVideo.srcObject = camStream;
      try { await camVideo.play(); } catch {}

      setCamIndicator(true);
      applyMirrorClass();

      try{ await refreshDevices(); } catch {}
      await refreshTorchSupport();

      writeSettings({
        preferredFacing: currentFacing,
        preferredDeviceId: selectedDeviceId || ""
      });

      updateLiveOverlay();
    } catch {
      setCamIndicator(false);
      showToast("เปิดกล้องไม่สำเร็จ (ต้องเป็น https + อนุญาตกล้อง)");
    }
  }

  async function switchCamera(){
    try{ await refreshDevices(); } catch {}

    if (videoDevices.length >= 2){
      let idx = videoDevices.findIndex(d => d.deviceId === selectedDeviceId);
      idx = (idx < 0) ? 0 : idx;
      const next = videoDevices[(idx + 1) % videoDevices.length];
      selectedDeviceId = next.deviceId;

      const label = (next.label || "").toLowerCase();
      const likelyFront = label.includes("front") || label.includes("user") || label.includes("facetime");
      currentFacing = likelyFront ? "user" : "environment";

      await startCamera({ forceFacing: currentFacing, forceDeviceId: selectedDeviceId });
      showToast("สลับกล้อง");
      return;
    }

    currentFacing = (currentFacing === "environment") ? "user" : "environment";
    selectedDeviceId = "";
    await startCamera({ forceFacing: currentFacing, forceDeviceId: "" });
    showToast("สลับกล้อง");
  }

  async function snapPhoto(){
    if (!camStream || !camVideo.videoWidth || !camVideo.videoHeight){
      showToast("ยังไม่พร้อมถ่าย");
      await startCamera({ forceFacing: currentFacing || "environment" });
      return;
    }

    const vw = camVideo.videoWidth;
    const vh = camVideo.videoHeight;

    const c = document.createElement("canvas");
    c.width = vw;
    c.height = vh;
    const cctx = c.getContext("2d", { alpha:false });

    // Front camera: บันทึกแบบ mirror เหมือนพรีวิว
    if (isUserFacingNow()){
      cctx.save();
      cctx.translate(vw, 0);
      cctx.scale(-1, 1);
      cctx.drawImage(camVideo, 0, 0, vw, vh);
      cctx.restore();
    } else {
      cctx.drawImage(camVideo, 0, 0, vw, vh);
    }

    const rawBlob = await new Promise((resolve, reject) => {
      c.toBlob((b) => {
        if (!b) return reject(new Error("capture toBlob failed"));
        resolve(b);
      }, "image/jpeg", 0.95);
    });

    await addPhotoFromBlob(rawBlob, { fromCamera:true, capturedAt:new Date(), exifOrientation: 1 });
  }

  /* =========================
     Leaflet map
  ========================== */
  let map = null;
  let mapMarker = null;

  function openMap(){
    if (!window.L){
      locStatus.textContent = "แผนที่โหลดไม่สำเร็จ (Leaflet) — ตรวจเน็ต/เปิดผ่าน https";
      mapWrap.style.display = "none";
      return;
    }

    mapWrap.style.display = "block";
    const lat = hasValidLatLng() ? Number(latEl.value) : 13.7563;
    const lng = hasValidLatLng() ? Number(lngEl.value) : 100.5018;

    if (!map){
      map = L.map('map', { zoomControl: true }).setView([lat, lng], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);

      mapMarker = L.marker([lat, lng]).addTo(map);

      map.on('click', async (e) => {
        latEl.value = e.latlng.lat;
        lngEl.value = e.latlng.lng;
        mapMarker.setLatLng(e.latlng);
        addressText = "";
        if (!enableLocation.checked) enableLocation.checked = true;
        await refreshAddressIfNeeded();
        scheduleSave();
      });
    } else {
      map.setView([lat, lng], 15);
      if (mapMarker) mapMarker.setLatLng([lat, lng]);
    }
    setTimeout(() => map.invalidateSize(), 120);
  }

  function closeMap(){ mapWrap.style.display = "none"; }

  /* =========================
     Wire events
  ========================== */
  btnBusyClose.addEventListener("click", () => setBusy(false));

  btnSettings.addEventListener("click", () => {
    applySettingsToInputs();
    showModal(settingsBackdrop, true);
  });
  btnCloseSettings.addEventListener("click", () => showModal(settingsBackdrop, false));

  btnApplySettings.addEventListener("click", async () => {
    writeSettings(collectSettingsFromUI());
    showModal(settingsBackdrop, false);
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    await refreshAddressIfNeeded();
    showToast("บันทึกแล้ว");
  });

  btnResetSettings.addEventListener("click", async () => {
    writeSettings({ ...DEFAULT_SETTINGS, preferredFacing: settings.preferredFacing, preferredDeviceId: settings.preferredDeviceId, torchOn: false });
    showToast("รีเซ็ตค่าแล้ว");
    await refreshAddressIfNeeded();
  });

  const bindSave = (el, evt="change") => el.addEventListener(evt, () => {
    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(useNow, "change");
  bindSave(customTime, "input");
  bindSave(timeFormat, "change");
  bindSave(timeLines, "change");

  btnSetNow.addEventListener("click", () => {
    const now = new Date();
    customTime.value = dateToDatetimeLocalValue(now);
    useNow.checked = true;
    updateTimeMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(outputMode, "change");
  bindSave(outputSize, "change");
  bindSave(fitMode, "change");

  bindSave(overlayPos, "change");
  bindSave(overlayBoxEnable, "change");
  bindSave(overlayStrokeEnable, "change");
  bindSave(overlayMarginScale, "input");
  bindSave(overlayPadScale, "input");
  bindSave(liveOverlayEnable, "change");

  bindSave(fontAuto, "change");
  bindSave(fontScale, "input");
  bindSave(fontPx, "input");

  enableLocation.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showLatLng.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showAddress.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  latEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });
  lngEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });

  btnUseGPS.addEventListener("click", async () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();

    if (!navigator.geolocation){
      locStatus.textContent = "อุปกรณ์/เบราว์เซอร์นี้ไม่รองรับ GPS";
      showToast("GPS ไม่รองรับ");
      return;
    }

    locStatus.textContent = "กำลังขอพิกัดจาก GPS...";
    navigator.geolocation.getCurrentPosition(async (pos) => {
      latEl.value = pos.coords.latitude;
      lngEl.value = pos.coords.longitude;
      addressText = "";
      await refreshAddressIfNeeded();
      scheduleSave();
      showToast("ได้พิกัดแล้ว");
    }, (err) => {
      locStatus.textContent = "ขอพิกัดไม่ได้: " + (err?.message || "unknown error");
      showToast("ขอพิกัดไม่ได้");
    }, { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 });
  });

  btnPickOnMap.addEventListener("click", () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();
    openMap();
  });

  btnConfirmMap.addEventListener("click", async () => {
    if (!hasValidLatLng()){
      locStatus.textContent = "ยังไม่มีพิกัดที่ถูกต้อง";
      return;
    }
    closeMap();
    await refreshAddressIfNeeded();
    scheduleSave();
    showToast("ยืนยันพิกัดแล้ว");
  });
  btnCloseMap.addEventListener("click", closeMap);

  btnSearchPlace.addEventListener("click", async () => {
    const q = (placeQuery.value || "").trim();
    if (!q) return;
    if (!enableLocation.checked) enableLocation.checked = true;

    locStatus.textContent = "กำลังค้นหาสถานที่...";
    try{
      const r = await forwardGeocode(q);
      if (!r){
        locStatus.textContent = "ไม่พบสถานที่";
        showToast("ไม่พบสถานที่");
        return;
      }
      latEl.value = r.lat;
      lngEl.value = r.lng;
      addressText = r.display_name || "";
      await refreshAddressIfNeeded();
      scheduleSave();

      if (map && window.L){
        map.setView([r.lat, r.lng], 17);
        if (!mapMarker) mapMarker = L.marker([r.lat, r.lng]).addTo(map);
        mapMarker.setLatLng([r.lat, r.lng]);
      }
      showToast("พบสถานที่แล้ว");
    } catch {
      locStatus.textContent = "ค้นหาไม่สำเร็จ (แนะนำเปิดผ่าน https)";
      showToast("ค้นหาไม่สำเร็จ");
    }
  });

  bindSave(defaultFormat, "change");
  bindSave(jpgQuality, "input");
  bindSave(namePattern, "change");
  bindSave(preferFolderSave, "change");
  bindSave(zipFallback, "change");

  btnTorch.addEventListener("click", async () => {
    if (btnTorch.disabled){
      showToast("Torch ไม่รองรับ");
      return;
    }
    try{
      const next = !btnTorch.classList.contains("on");
      await setTorch(next);
      showToast(next ? "Torch ON" : "Torch OFF");
    } catch {
      showToast("Torch ใช้ไม่ได้");
    }
  });

  btnImport.addEventListener("click", () => {
    fileInput.value = "";
    fileInput.click();
  });

  fileInput.addEventListener("change", async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    await addPhotosFromFiles(files);
  });

  btnDownloadAll.addEventListener("click", downloadAll);

  btnSwitchCam.addEventListener("click", switchCamera);
  btnShutter.addEventListener("click", snapPhoto);

  btnLatest.addEventListener("click", () => {
    if (photos.length === 0) return;
    const last = photos[photos.length - 1];
    openPreview(last.id);
  });

  btnDeleteAll.addEventListener("click", deleteAllPhotos);

  btnClosePreview.addEventListener("click", closePreview);
  previewBackdrop.addEventListener("click", (e) => { if (e.target === previewBackdrop) closePreview(); });

  btnReRender.addEventListener("click", renderPreview);

  btnPrevPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx <= 0) return;
    openPreview(photos[idx-1].id);
  });

  btnNextPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx >= photos.length-1) return;
    openPreview(photos[idx+1].id);
  });

  btnDeletePhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    removePhotoById(p.id);
  });

  btnDownloadPhoto.addEventListener("click", async () => {
    const p = getActivePhoto();
    if (!p) return;

    try{
      const idx = findPhotoIndexById(p.id);
      const mime = dlFormat.value || "image/jpeg";
      const ext = (mime === "image/png") ? "png" : "jpg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      setBusy(true, "กำลังดาวน์โหลด...", "กำลัง render ไฟล์", null);
      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const filename = buildFilename(new Date(), idx+1, ext, p);
      triggerDownload(r.blob, filename);
      setBusy(false);

      showToast("ดาวน์โหลดแล้ว");
    } catch (e){
      setBusy(false);
      showToast("ดาวน์โหลดไม่สำเร็จ");
    }
  });

  photoUseCustomTime.addEventListener("change", () => {
    const p = getActivePhoto();
    if (!p) return;

    p.stampMode = photoUseCustomTime.checked ? "custom" : "global";
    photoTimeInput.disabled = !photoUseCustomTime.checked;

    if (photoUseCustomTime.checked){
      if (!p.stampTime){
        const gd = getGlobalDate() || new Date();
        p.stampTime = dateToDatetimeLocalValue(gd);
      }
      photoTimeInput.value = p.stampTime;
    } else {
      photoTimeInput.value = "";
    }
    renderPreview();
  });

  photoTimeInput.addEventListener("change", () => {
    const p = getActivePhoto();
    if (!p) return;
    if (!photoTimeInput.value) return;

    p.stampMode = "custom";
    p.stampTime = photoTimeInput.value;
    photoUseCustomTime.checked = true;
    photoTimeInput.disabled = false;
    renderPreview();
  });

  btnCopyMainTime.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;

    const gd = getGlobalDate() || new Date();
    p.stampMode = "custom";
    p.stampTime = dateToDatetimeLocalValue(gd);

    photoUseCustomTime.checked = true;
    photoTimeInput.disabled = false;
    photoTimeInput.value = p.stampTime;

    renderPreview();
    showToast("คัดลอกเวลาหน้าหลักแล้ว");
  });

  settingsBackdrop.addEventListener("click", (e) => {
    if (e.target === settingsBackdrop) showModal(settingsBackdrop, false);
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (settingsBackdrop.style.display === "flex") showModal(settingsBackdrop, false);
      if (previewBackdrop.style.display === "flex") closePreview();
    }
  });

  window.addEventListener("beforeunload", () => { try{ stopCamera(); } catch {} });

  /* =========================
     Boot
  ========================== */
  function boot(){
    applySettingsToUI();
    renderFilmstrip();
    refreshLocMini();
    updateTimeMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    startCamera({ forceFacing: settings.preferredFacing || "environment", forceDeviceId: settings.preferredDeviceId || "" });
  }

  boot();
})();
</script>
</body>
</html>
