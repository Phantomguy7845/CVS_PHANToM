<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>PT Timestamp Camera (Camera UI) v3.1</title>

  <!-- Leaflet (‡πÉ‡∏ä‡πâ‡∏ï‡∏≠‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ô Settings ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- JSZip (fallback ‡∏ñ‡πâ‡∏≤ File System Access API ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>

  <style>
    :root{
      --bg:#000;
      --text:#f3f7ff;
      --muted:rgba(243,247,255,.72);
      --muted2:rgba(243,247,255,.52);
      --line:rgba(255,255,255,.10);
      --accent:#10b981;
      --danger:#ef4444;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:18px;

      --safe-b: env(safe-area-inset-bottom);
      --safe-t: env(safe-area-inset-top);
      --safe-l: env(safe-area-inset-left);
      --safe-r: env(safe-area-inset-right);
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif;
      overflow:hidden;
    }
    button, input, select{
      font-family: inherit;
      -webkit-tap-highlight-color: transparent;
    }

    /* ===== Stage ===== */
    .stage{
      position:relative;
      width:100%;
      height: 100svh;
      height: 100dvh;
      background:#000;
      overflow:hidden;
    }

    .videoWrap{
      position:absolute;
      inset:0;
      background:#000;
    }
    video#camVideo{
      width:100%;
      height:100%;
      object-fit: cover;
      background:#000;
      transform: translateZ(0);
    }
    video#camVideo.mirror{
      transform: scaleX(-1) translateZ(0);
    }

    /* Gradient bars (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏≠‡∏õ‡∏Å‡∏•‡πâ‡∏≠‡∏á) */
    .topShade{
      position:absolute;
      top:0; left:0; right:0;
      height: 160px;
      pointer-events:none;
      background: linear-gradient(180deg, rgba(0,0,0,.70), rgba(0,0,0,.20), rgba(0,0,0,0));
      z-index: 5;
    }
    .bottomShade{
      position:absolute;
      left:0; right:0; bottom:0;
      height: 220px;
      pointer-events:none;
      background: linear-gradient(0deg, rgba(0,0,0,.82), rgba(0,0,0,.25), rgba(0,0,0,0));
      z-index: 8;
    }

    /* ===== Live overlay (STAMP GUIDE) : ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏ñ‡∏ö‡∏î‡∏≥ ===== */
    .liveOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      z-index: 6;
      display:flex;
      align-items:flex-start;
      justify-content:flex-end;
      padding: calc(12px + var(--safe-t)) calc(12px + var(--safe-r)) calc(12px + var(--safe-b)) calc(12px + var(--safe-l));
    }
    .overlayText{
      max-width: min(92vw, 720px);
      display:none;
      white-space: pre-wrap;
      line-height: 1.25;
      font-weight: 900;
      color:#fff;
      /* ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á/‡∏Å‡∏£‡∏≠‡∏ö */
      background: transparent;
      border: none;
      padding: 0;
      text-shadow:
        0 2px 10px rgba(0,0,0,.85),
        0 0 2px rgba(0,0,0,.85);
    }

    /* ===== Top bar (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏£‡πá‡∏ü) ===== */
    .topBar{
      position:absolute;
      top:0; left:0; right:0;
      z-index: 10;
      padding: calc(10px + var(--safe-t)) calc(10px + var(--safe-r)) 10px calc(10px + var(--safe-l));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .topGroup{ display:flex; align-items:center; gap:8px; }

    .iconBtn{
      width: 42px;
      height: 42px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.30);
      color:#fff;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
    }
    .iconBtn:active{ transform: translateY(1px); }
    .iconBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .iconBtn.on{
      border-color: rgba(16,185,129,.55);
      background: rgba(16,185,129,.16);
      color: #d6fff1;
    }

    .brandPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 9px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 34px rgba(0,0,0,.35);
      font-weight: 950;
      letter-spacing:.3px;
      user-select:none;
      color: rgba(255,255,255,.92);
    }
    .dot{
      width:9px; height:9px; border-radius:999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 0 4px rgba(255,255,255,.08);
    }
    .dot.ok{ background: rgba(16,185,129,.95); box-shadow: 0 0 0 4px rgba(16,185,129,.18); }
    .dot.err{ background: rgba(239,68,68,.95); box-shadow: 0 0 0 4px rgba(239,68,68,.18); }

    /* ===== Main time HUD (‡πÄ‡∏≠‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏°‡∏≤‡πÑ‡∏ß‡πâ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å) ===== */
    .timeHUD{
      position:absolute;
      top: calc(62px + var(--safe-t));
      left: 50%;
      transform: translateX(-50%);
      z-index: 11;
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.26);
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 34px rgba(0,0,0,.30);
      user-select:none;
      max-width: min(92vw, 760px);
    }
    .timeModeBtn{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      font-weight: 950;
      cursor:pointer;
      min-height: 38px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .timeModeBtn.on{
      border-color: rgba(16,185,129,.55);
      background: rgba(16,185,129,.16);
      color:#d6fff1;
    }
    .timeLabelBtn{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.90);
      font-weight: 900;
      cursor:pointer;
      min-height: 38px;
      max-width: 68vw;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space:nowrap;
    }
    .timeHint{
      font-size: 12px;
      color: rgba(255,255,255,.70);
      font-weight: 900;
      margin-left: 4px;
      display:none;
    }
    @media (max-width: 420px){
      .timeHint{ display:none; }
    }

    /* ===== Filmstrip (‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á ‡πÑ‡∏°‡πà‡∏ö‡∏î‡∏ö‡∏±‡∏á) ===== */
    .filmstrip{
      position:absolute;
      left: calc(10px + var(--safe-l));
      right: calc(10px + var(--safe-r));
      bottom: calc(112px + var(--safe-b));
      z-index: 12;
      display:flex;
      gap:10px;
      align-items:center;
      padding: 8px 8px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      overflow-x:auto;
      scrollbar-width: none;
      max-height: 72px;
    }
    .filmstrip::-webkit-scrollbar{ display:none; }

    .thumb{
      width: 56px;
      height: 56px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      flex: 0 0 auto;
      position:relative;
      cursor:pointer;
      user-select:none;
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
    }
    .thumb.active{
      outline: 3px solid rgba(16,185,129,.55);
      outline-offset: 2px;
    }
    .thumb .del{
      position:absolute;
      top:6px; right:6px;
      width: 22px; height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.55);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 13px;
      font-weight: 950;
      cursor:pointer;
    }
    .thumb .num{
      position:absolute;
      left:6px; bottom:6px;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 11px;
      font-weight: 950;
    }
    .emptyPill{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.80);
      font-size: 12px;
      font-weight: 900;
      user-select:none;
      white-space:nowrap;
    }

    /* ===== Bottom controls (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÅ‡∏£‡πá‡∏ü: thumb - shutter - switch) ===== */
    .bottomBar{
      position:absolute;
      left:0; right:0; bottom:0;
      z-index: 13;
      padding: 10px calc(14px + var(--safe-r)) calc(14px + var(--safe-b)) calc(14px + var(--safe-l));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      pointer-events:auto;
    }
    .miniBtn{
      width: 58px;
      height: 58px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      color:#fff;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
    }
    .miniBtn:active{ transform: translateY(1px); }
    .miniBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .latestThumbImg{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.05);
    }
    .countBadge{
      position:absolute;
      right:6px; bottom:6px;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(0,0,0,.58);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 11px;
      font-weight: 950;
    }

    .shutter{
      width: 86px;
      height: 86px;
      border-radius: 999px;
      border: 6px solid rgba(255,255,255,.92);
      background: rgba(255,255,255,.12);
      cursor:pointer;
      user-select:none;
      position:relative;
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
      flex: 0 0 auto;
    }
    .shutter::after{
      content:"";
      position:absolute;
      inset: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
    }
    .shutter:active{ transform: scale(.985); }
    .shutter[disabled]{ opacity:.45; cursor:not-allowed; }

    /* ===== Delete all FAB (‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á) ===== */
    .fabDanger{
      position:absolute;
      right: calc(14px + var(--safe-r));
      bottom: calc(124px + var(--safe-b));
      z-index: 20;
      width: 54px;
      height: 54px;
      border-radius: 999px;
      border: 1px solid rgba(239,68,68,.40);
      background: rgba(239,68,68,.14);
      color:#ffd7d7;
      font-size: 18px;
      font-weight: 950;
      cursor:pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      display:none;
    }
    .fabDanger:active{ transform: translateY(1px); }

    /* ===== Modals ===== */
    .backdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.74);
      display:none;
      z-index:50;
      padding: 12px;
      padding-top: calc(12px + var(--safe-t));
      padding-bottom: calc(12px + var(--safe-b));
      align-items:center;
      justify-content:center;
    }
    .modal{
      width: min(920px, 100%);
      max-height: 100%;
      background: linear-gradient(180deg, rgba(15,22,32,.98), rgba(10,14,20,.98));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }
    .modalTitle{
      font-weight: 950;
      font-size: 14px;
      color: rgba(255,255,255,.92);
      letter-spacing:.2px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .modalBody{
      padding: 12px;
      overflow:auto;
      display:grid;
      gap: 12px;
    }
    .modalFooter{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 950;
      cursor:pointer;
      min-height: 46px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(16,185,129,.95), rgba(16,185,129,.65));
      border-color: rgba(16,185,129,.45);
      color: #062b1f;
    }
    .btn.danger{
      background: rgba(239,68,68,.12);
      border-color: rgba(239,68,68,.35);
      color: #ffd7d7;
    }
    .btn.ghost{ background: rgba(255,255,255,.03); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .card{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .label{
      font-size: 12px;
      color: rgba(255,255,255,.78);
      font-weight: 900;
      letter-spacing:.2px;
    }
    .mini{
      font-size: 12px;
      color: rgba(255,255,255,.60);
      line-height:1.35;
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 820px){ .grid3{ grid-template-columns: 1fr; } }
    @media (max-width: 680px){ .grid2{ grid-template-columns: 1fr; } }

    .field{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: 15px;
      outline: none;
    }
    .field:focus{
      border-color: rgba(16,185,129,.55);
      box-shadow: 0 0 0 4px rgba(16,185,129,.16);
    }
    .switch{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      user-select:none;
      min-height: 46px;
    }
    .switch .left{
      display:flex; align-items:center; gap:10px;
    }
    .switch input{ width: 20px; height: 20px; accent-color: var(--accent); }
    .switch span{ font-size: 15px; font-weight: 900; color: rgba(255,255,255,.92); }

    /* Map */
    #mapWrap{
      display:none;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    #map{ width: 100%; height: 320px; }

    /* Preview */
    .previewImg{
      width:100%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      display:block;
      max-height: 58vh;
      object-fit: contain;
    }
    .previewMeta{
      font-size:12px;
      color: rgba(255,255,255,.70);
      line-height:1.35;
      white-space: pre-wrap;
    }

    /* Toast */
    .toast{
      position:fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(18px + var(--safe-b));
      z-index: 60;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.62);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 12px;
      font-weight: 900;
      display:none;
      box-shadow: 0 20px 50px rgba(0,0,0,.55);
      max-width: min(92vw, 720px);
      text-align:center;
      backdrop-filter: blur(8px);
    }

    /* Busy overlay */
    .busy{
      position:fixed;
      inset:0;
      z-index: 70;
      background: rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 14px;
      text-align:center;
    }
    .busyCard{
      width:min(520px, 100%);
      background: rgba(15,22,32,.98);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 14px;
      display:grid;
      gap: 10px;
    }
    .busyTitle{ font-weight: 950; font-size: 14px; }
    .bar{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height:100%;
      width: 0%;
      background: rgba(16,185,129,.92);
      transition: width .15s linear;
    }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <div class="videoWrap">
      <video id="camVideo" playsinline autoplay muted></video>
    </div>

    <div class="topShade"></div>
    <div class="bottomShade"></div>

    <!-- Live overlay preview (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏î‡∏≥) -->
    <div class="liveOverlay" id="liveOverlay">
      <div class="overlayText" id="liveOverlayText"></div>
    </div>

    <!-- Top bar -->
    <div class="topBar">
      <div class="topGroup">
        <div class="brandPill" title="PT Timestamp">
          <span class="dot" id="dotCam"></span>
          <span>PT</span>
        </div>
      </div>

      <div class="topGroup">
        <button class="iconBtn" id="btnTorch" title="Torch/Flash" aria-label="Torch" disabled>‚ö°</button>
        <button class="iconBtn" id="btnImport" title="Import from gallery" aria-label="Import">üñºÔ∏è</button>
        <button class="iconBtn" id="btnDownloadAll" title="Download All" aria-label="Download All" disabled>‚¨áÔ∏è</button>
        <button class="iconBtn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <!-- Main time HUD (‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å) -->
    <div class="timeHUD" id="timeHUD">
      <button class="timeModeBtn on" id="btnMainNow" type="button">NOW</button>
      <button class="timeLabelBtn" id="btnMainPick" type="button">-</button>
      <span class="timeHint" id="timeHint">‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤</span>
      <input id="mainTimeInput" type="datetime-local" style="display:none" />
    </div>

    <!-- Filmstrip (‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á + ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÑ‡∏î‡πâ) -->
    <div class="filmstrip" id="filmstrip" aria-label="filmstrip"></div>

    <!-- Delete all (‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á) -->
    <button class="fabDanger" id="btnDeleteAll" title="‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î" aria-label="Delete All">üóëÔ∏è</button>

    <!-- Bottom camera controls -->
    <div class="bottomBar">
      <button class="miniBtn" id="btnLatest" title="‡πÄ‡∏õ‡∏¥‡∏î‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡∏£‡∏π‡∏õ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î" aria-label="Latest" disabled>
        <img id="latestImg" class="latestThumbImg" alt="" style="display:none" />
        <span id="latestPlaceholder">üñºÔ∏è</span>
        <span class="countBadge" id="countBadge" style="display:none;">0</span>
      </button>

      <button class="shutter" id="btnShutter" title="Shutter" aria-label="Shutter"></button>

      <button class="miniBtn" id="btnSwitchCam" title="Switch camera" aria-label="Switch camera">üîÑ</button>
    </div>
  </div>

  <!-- Hidden file input (multiple) -->
  <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />

  <!-- Preview Modal -->
  <div class="backdrop" id="previewBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">üñºÔ∏è Preview / Download</div>
        <button class="btn danger" id="btnClosePreview" style="min-height:42px; padding:10px 12px;">‡∏õ‡∏¥‡∏î</button>
      </div>
      <div class="modalBody">
        <img id="previewImg" class="previewImg" alt="preview" />
        <div class="previewMeta" id="previewMeta">-</div>

        <!-- Per-photo time controls (‡πÉ‡∏´‡∏°‡πà) -->
        <div class="card">
          <div class="label">‡πÄ‡∏ß‡∏•‡∏≤ Stamp ‡∏Ç‡∏≠‡∏á ‚Äú‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ‚Äù</div>
          <label class="switch">
            <div class="left">
              <input id="photoUseCustomTime" type="checkbox" />
              <span>‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ</span>
            </div>
            <span class="mini">‡∏ñ‡πâ‡∏≤‡∏õ‡∏¥‡∏î = ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</span>
          </label>
          <div class="grid2">
            <div>
              <div class="label">‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ (datetime-local)</div>
              <input id="photoTimeInput" class="field" type="datetime-local" disabled />
              <div class="mini">Tip: ‡πÄ‡∏õ‡∏¥‡∏î‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏Å‡πà‡∏≠‡∏ô</div>
            </div>
            <div>
              <div class="label">‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</div>
              <button class="btn" id="btnCopyMainTime">‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏™‡πà‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ</button>
              <div class="mini">‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏£‡πá‡∏ß ‡πÜ ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">Download options (‡∏ï‡πà‡∏≠‡∏£‡∏π‡∏õ)</div>
          <div class="grid2">
            <div>
              <div class="label">‡∏ä‡∏ô‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå</div>
              <select id="dlFormat" class="field">
                <option value="image/jpeg">JPG</option>
                <option value="image/png">PNG</option>
              </select>
              <div class="mini">Export ‡∏ú‡πà‡∏≤‡∏ô canvas ‚Üí ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ ‚Äú‡πÑ‡∏°‡πà‡∏°‡∏µ EXIF/metadata ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‚Äù</div>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="dlQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
              <div class="mini">‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å JPG ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô</div>
            </div>
          </div>

          <div style="display:flex; gap:10px; justify-content:space-between; flex-wrap:wrap;">
            <button class="btn danger" id="btnDeletePhoto" style="flex:1">‡∏•‡∏ö‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ</button>
            <button class="btn primary" id="btnDownloadPhoto" style="flex:1">‚¨áÔ∏è Download</button>
          </div>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn ghost" id="btnReRender">üîÑ Re-render preview</button>
        <button class="btn" id="btnPrevPhoto">‚¨ÖÔ∏è ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>
        <button class="btn" id="btnNextPhoto">‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚û°Ô∏è</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal (‡∏¢‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° ‡πÅ‡∏ï‡πà default box ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß) -->
  <div class="backdrop" id="settingsBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">‚öôÔ∏è Settings</div>
        <button class="btn danger" id="btnCloseSettings" style="min-height:42px; padding:10px 12px;">‡∏õ‡∏¥‡∏î</button>
      </div>

      <div class="modalBody">
        <div class="card">
          <div class="label">1) ‡πÄ‡∏ß‡∏•‡∏≤ (Timestamp)</div>
          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="useNow" type="checkbox" checked />
                <span>‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô</span>
              </div>
              <span class="mini" id="timeMini">-</span>
            </label>
            <div>
              <div class="label">‡πÅ‡∏Å‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏≠‡∏á (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏¥‡πä‡∏Å‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)</div>
              <input id="customTime" class="field" type="datetime-local" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ß‡∏•‡∏≤</div>
              <select id="timeFormat" class="field">
                <option value="thai_verbose" selected>Thai verbose (‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°)</option>
                <option value="ddmmyyyy_hms">DD/MM/YYYY HH:mm:ss</option>
                <option value="yyyymmdd_hms">YYYY-MM-DD HH:mm:ss</option>
                <option value="iso">ISO 8601</option>
              </select>
              <div class="mini">Overlay ‡∏à‡∏∞ render ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà Download/Preview</div>
            </div>
            <div>
              <div class="label">‡πÄ‡∏™‡πâ‡∏ô‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤</div>
              <select id="timeLines" class="field">
                <option value="two" selected>2 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î (Network + Local)</option>
                <option value="one">1 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î</option>
              </select>
              <div class="mini">‡∏Ñ‡∏á‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ + ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ</div>
            </div>
          </div>

          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button class="btn" id="btnSetNow" style="flex:1">‚è± ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô</button>
          </div>
        </div>

        <div class="card">
          <div class="label">2) Output size (Preset/Original) + Fit</div>
          <div class="grid3">
            <div>
              <div class="label">‡πÇ‡∏´‡∏°‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å</div>
              <select id="outputMode" class="field">
                <option value="preset" selected>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î (Preset)</option>
                <option value="original">‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏¥‡∏° (‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á)</option>
              </select>
              <div class="mini">Preset = ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏≠‡∏á ‚Ä¢ Original = ‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡∏à‡∏£‡∏¥‡∏á</div>
            </div>

            <div>
              <div class="label">Preset Size</div>
              <select id="outputSize" class="field">
                <option value="1920x1440" selected>1920 √ó 1440</option>
                <option value="2340x1080">2340 √ó 1080</option>
                <option value="2160x1080">2160 √ó 1080</option>
                <option value="1920x1080">1920 √ó 1080</option>
                <option value="1600x1200">1600 √ó 1200</option>
                <option value="1440x1080">1440 √ó 1080</option>
                <option value="1280x960">1280 √ó 960</option>
                <option value="1560x720">1560 √ó 720</option>
                <option value="1440x720">1440 √ó 720</option>
                <option value="1280x720">1280 √ó 720</option>
                <option value="800x600">800 √ó 600</option>
                <option value="720x480">720 √ó 480</option>
                <option value="640x480">640 √ó 480</option>
                <option value="640x360">640 √ó 360</option>
                <option value="352x288">352 √ó 288</option>
                <option value="320x240">320 √ó 240</option>
                <option value="176x144">176 √ó 144</option>
              </select>
              <div class="mini">‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Original ‡∏à‡∏∞‡∏õ‡∏¥‡∏î preset</div>
            </div>

            <div>
              <div class="label">Fit Mode</div>
              <select id="fitMode" class="field">
                <option value="contain" selected>Contain (‡∏°‡∏µ‡∏Ç‡∏≠‡∏ö‡∏î‡∏≥‡∏ñ‡πâ‡∏≤‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á)</option>
                <option value="cover">Cover (‡πÄ‡∏ï‡πá‡∏°‡πÄ‡∏ü‡∏£‡∏° + ‡∏Ñ‡∏£‡∏≠‡∏õ)</option>
              </select>
              <div class="mini">‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÅ‡∏ö‡∏ö ‚Äú‡πÑ‡∏°‡πà‡∏¢‡∏∑‡∏î‡∏†‡∏≤‡∏û‚Äù</div>
            </div>
          </div>
          <div class="mini" id="outStatus">-</div>
        </div>

        <div class="card">
          <div class="label">3) Overlay style (‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‚Äú‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏î‡∏≥‚Äù)</div>

          <div class="grid3">
            <div>
              <div class="label">‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Overlay</div>
              <select id="overlayPos" class="field">
                <option value="tl">‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô</option>
                <option value="tr" selected>‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô</option>
                <option value="bl">‡∏ã‡πâ‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏á</option>
                <option value="br">‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á</option>
              </select>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayBoxEnable" type="checkbox" />
                  <span>‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÇ‡∏õ‡∏£‡πà‡∏á‡∏î‡∏≥</span>
                </div>
                <span class="mini">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡∏õ‡∏¥‡∏î</span>
              </label>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayStrokeEnable" type="checkbox" checked />
                  <span>Stroke/Shadow</span>
                </div>
                <span class="mini">‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡πÄ‡∏õ‡∏¥‡∏î</span>
              </label>
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">‡∏ü‡∏≠‡∏ô‡∏ï‡πå</div>
              <label class="switch" style="margin-bottom:10px">
                <div class="left">
                  <input id="fontAuto" type="checkbox" checked />
                  <span>Auto (‡∏™‡πÄ‡∏Å‡∏•‡∏ï‡∏≤‡∏° Output)</span>
                </div>
                <span class="mini">‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢ preset</span>
              </label>

              <div class="grid2">
                <div>
                  <div class="label">Auto scale (%)</div>
                  <input id="fontScale" class="field" type="number" min="50" max="250" step="5" value="100">
                </div>
                <div>
                  <div class="label">Fixed px (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î Auto)</div>
                  <input id="fontPx" class="field" type="number" min="10" max="200" step="1" value="32" disabled>
                </div>
              </div>
              <div class="mini">Auto ‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å output ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏π‡∏ì‡∏î‡πâ‡∏ß‡∏¢ %</div>
            </div>

            <div>
              <div class="label">‡∏£‡∏∞‡∏¢‡∏∞‡∏Ç‡∏≠‡∏ö/‡∏™‡πÄ‡∏Å‡∏•‡∏Å‡∏•‡πà‡∏≠‡∏á</div>
              <div class="grid2">
                <div>
                  <div class="label">Margin scale (%)</div>
                  <input id="overlayMarginScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
                <div>
                  <div class="label">Padding scale (%)</div>
                  <input id="overlayPadScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
              </div>
              <div class="mini">‡∏ä‡πà‡∏ß‡∏¢‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á/‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="liveOverlayEnable" type="checkbox" checked />
                <span>‡πÅ‡∏™‡∏î‡∏á overlay ‡∏ö‡∏ô‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡∏Å‡∏•‡πâ‡∏≠‡∏á</span>
              </div>
              <span class="mini">Preview-only</span>
            </label>
            <div class="mini">
              * Preview overlay ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏Å‡∏î‡πå ‡πÅ‡∏ï‡πà‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏∞ render ‡∏ú‡πà‡∏≤‡∏ô canvas ‡∏ï‡∏≠‡∏ô Download/Preview
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">4) Location (Lat/Lng + Address via Nominatim)</div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="enableLocation" type="checkbox" />
                <span>‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á (Overlay)</span>
              </div>
              <span class="mini" id="locMini">‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>
            </label>

            <div class="grid2">
              <label class="switch">
                <div class="left">
                  <input id="showLatLng" type="checkbox" checked />
                  <span>‡πÅ‡∏™‡∏î‡∏á Lat/Lng</span>
                </div>
              </label>
              <label class="switch">
                <div class="left">
                  <input id="showAddress" type="checkbox" checked />
                  <span>‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà</span>
                </div>
              </label>
            </div>
          </div>

          <div class="grid2">
            <button class="btn" id="btnUseGPS">üìç ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (GPS)</button>
            <button class="btn" id="btnPickOnMap">üó∫Ô∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</button>
          </div>

          <div class="grid2">
            <div>
              <div class="label">Lat</div>
              <input id="lat" class="field" type="number" step="any" placeholder="‡πÄ‡∏ä‡πà‡∏ô 13.7563" />
            </div>
            <div>
              <div class="label">Lng</div>
              <input id="lng" class="field" type="number" step="any" placeholder="‡πÄ‡∏ä‡πà‡∏ô 100.5018" />
            </div>
          </div>

          <div>
            <div class="label">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà (Forward geocode)</div>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <input id="placeQuery" class="field" placeholder="‡πÄ‡∏ä‡πà‡∏ô CentralWorld Bangkok" style="flex:1" />
              <button class="btn" id="btnSearchPlace">üîé ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
            </div>
          </div>

          <div id="mapWrap">
            <div id="map"></div>
            <div style="display:flex; gap:10px; padding:10px; flex-wrap:wrap;">
              <button class="btn primary" id="btnConfirmMap" style="flex:1">‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ô‡∏µ‡πâ</button>
              <button class="btn danger" id="btnCloseMap" style="flex:1">‚úñ ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</button>
            </div>
          </div>

          <div class="mini" id="locStatus">-</div>
        </div>

        <div class="card">
          <div class="label">5) Download (Default)</div>
          <div class="grid3">
            <div>
              <div class="label">‡∏ä‡∏ô‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</div>
              <select id="defaultFormat" class="field">
                <option value="image/jpeg" selected>JPG</option>
                <option value="image/png">PNG</option>
              </select>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="jpgQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
            </div>
            <div>
              <div class="label">‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå</div>
              <select id="namePattern" class="field">
                <option value="pt_now_index" selected>PT_YYYYMMDD_HHMMSS_&lt;index&gt;</option>
                <option value="pt_capture_index">PT_(captureTime)_&lt;index&gt;</option>
              </select>
              <div class="mini">Download All ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏ä‡∏∏‡∏î</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="preferFolderSave" type="checkbox" checked />
                <span>Download All ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà zip (‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå)</span>
              </div>
              <span class="mini">Chrome ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</span>
            </label>
            <label class="switch">
              <div class="left">
                <input id="zipFallback" type="checkbox" checked />
                <span>Fallback ‡πÄ‡∏õ‡πá‡∏ô ZIP ‡∏ñ‡πâ‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</span>
              </div>
              <span class="mini">‡πÉ‡∏ä‡πâ JSZip</span>
            </label>
          </div>

          <div class="mini">
            ‚Ä¢ ‚Äú‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‚Äù ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ File System Access API (Chrome/Android ‡∏°‡∏±‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)<br>
            ‚Ä¢ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö ‚Üí ZIP ‚Üí ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏à‡∏∞ fallback ‡πÄ‡∏õ‡πá‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏µ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå
          </div>
        </div>
      </div>

      <div class="modalFooter">
        <button class="btn" id="btnResetSettings">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡πà‡∏≤</button>
        <button class="btn primary" id="btnApplySettings">Apply/Save</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="busy" id="busy">
    <div class="busyCard">
      <div class="busyTitle" id="busyTitle">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...</div>
      <div class="mini" id="busyText">-</div>
      <div class="bar"><div id="busyBar"></div></div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button class="btn danger" id="btnBusyClose" style="flex:1">‡∏õ‡∏¥‡∏î</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* =========================
     Storage
  ========================== */
  const SETTINGS_KEY = "PT_TS_SETTINGS_V2_4";

  const DEFAULT_SETTINGS = {
    // time
    useNow: true,
    customTime: "",
    timeFormat: "thai_verbose",
    timeLines: "two",

    // output
    outputMode: "preset",
    outputSize: "1920x1440",
    fitMode: "contain",

    // overlay
    overlayPos: "tr",
    overlayBoxEnable: false,   // <= default ‡∏õ‡∏¥‡∏î (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠)
    overlayStrokeEnable: true,
    overlayMarginScale: 100,
    overlayPadScale: 100,
    liveOverlayEnable: true,

    // font
    fontAuto: true,
    fontScale: 100,
    fontPx: 32,

    // location
    enableLocation: false,
    showLatLng: true,
    showAddress: true,
    lat: "",
    lng: "",
    placeQuery: "",

    // download
    defaultFormat: "image/jpeg",
    jpgQuality: 0.95,
    namePattern: "pt_now_index",
    preferFolderSave: true,
    zipFallback: true,

    // camera prefs
    preferredFacing: "environment",
    preferredDeviceId: "",
    torchOn: false
  };

  /* =========================
     Elements
  ========================== */
  const camVideo = document.getElementById("camVideo");
  const dotCam = document.getElementById("dotCam");

  const btnTorch = document.getElementById("btnTorch");
  const btnImport = document.getElementById("btnImport");
  const btnDownloadAll = document.getElementById("btnDownloadAll");
  const btnSettings = document.getElementById("btnSettings");
  const btnSwitchCam = document.getElementById("btnSwitchCam");

  const btnLatest = document.getElementById("btnLatest");
  const latestImg = document.getElementById("latestImg");
  const latestPlaceholder = document.getElementById("latestPlaceholder");
  const countBadge = document.getElementById("countBadge");

  const btnShutter = document.getElementById("btnShutter");

  const filmstrip = document.getElementById("filmstrip");
  const btnDeleteAll = document.getElementById("btnDeleteAll");

  const liveOverlay = document.getElementById("liveOverlay");
  const liveOverlayText = document.getElementById("liveOverlayText");

  const fileInput = document.getElementById("fileInput");

  // Main time HUD
  const btnMainNow = document.getElementById("btnMainNow");
  const btnMainPick = document.getElementById("btnMainPick");
  const mainTimeInput = document.getElementById("mainTimeInput");
  const timeHint = document.getElementById("timeHint");

  // Preview modal
  const previewBackdrop = document.getElementById("previewBackdrop");
  const btnClosePreview = document.getElementById("btnClosePreview");
  const previewImg = document.getElementById("previewImg");
  const previewMeta = document.getElementById("previewMeta");
  const dlFormat = document.getElementById("dlFormat");
  const dlQuality = document.getElementById("dlQuality");
  const btnDownloadPhoto = document.getElementById("btnDownloadPhoto");
  const btnDeletePhoto = document.getElementById("btnDeletePhoto");
  const btnPrevPhoto = document.getElementById("btnPrevPhoto");
  const btnNextPhoto = document.getElementById("btnNextPhoto");
  const btnReRender = document.getElementById("btnReRender");

  // Per-photo time UI
  const photoUseCustomTime = document.getElementById("photoUseCustomTime");
  const photoTimeInput = document.getElementById("photoTimeInput");
  const btnCopyMainTime = document.getElementById("btnCopyMainTime");

  // Settings modal
  const settingsBackdrop = document.getElementById("settingsBackdrop");
  const btnCloseSettings = document.getElementById("btnCloseSettings");
  const btnApplySettings = document.getElementById("btnApplySettings");
  const btnResetSettings = document.getElementById("btnResetSettings");

  const useNow = document.getElementById("useNow");
  const customTime = document.getElementById("customTime");
  const timeFormat = document.getElementById("timeFormat");
  const timeLines = document.getElementById("timeLines");
  const btnSetNow = document.getElementById("btnSetNow");
  const timeMini = document.getElementById("timeMini");

  const outputMode = document.getElementById("outputMode");
  const outputSize = document.getElementById("outputSize");
  const fitMode = document.getElementById("fitMode");
  const outStatus = document.getElementById("outStatus");

  const overlayPos = document.getElementById("overlayPos");
  const overlayBoxEnable = document.getElementById("overlayBoxEnable");
  const overlayStrokeEnable = document.getElementById("overlayStrokeEnable");
  const overlayMarginScale = document.getElementById("overlayMarginScale");
  const overlayPadScale = document.getElementById("overlayPadScale");
  const liveOverlayEnable = document.getElementById("liveOverlayEnable");

  const fontAuto = document.getElementById("fontAuto");
  const fontScale = document.getElementById("fontScale");
  const fontPx = document.getElementById("fontPx");

  const enableLocation = document.getElementById("enableLocation");
  const showLatLng = document.getElementById("showLatLng");
  const showAddress = document.getElementById("showAddress");
  const btnUseGPS = document.getElementById("btnUseGPS");
  const btnPickOnMap = document.getElementById("btnPickOnMap");
  const btnConfirmMap = document.getElementById("btnConfirmMap");
  const btnCloseMap = document.getElementById("btnCloseMap");
  const mapWrap = document.getElementById("mapWrap");
  const locStatus = document.getElementById("locStatus");
  const locMini = document.getElementById("locMini");

  const latEl = document.getElementById("lat");
  const lngEl = document.getElementById("lng");
  const placeQuery = document.getElementById("placeQuery");
  const btnSearchPlace = document.getElementById("btnSearchPlace");

  const defaultFormat = document.getElementById("defaultFormat");
  const jpgQuality = document.getElementById("jpgQuality");
  const namePattern = document.getElementById("namePattern");
  const preferFolderSave = document.getElementById("preferFolderSave");
  const zipFallback = document.getElementById("zipFallback");

  const toast = document.getElementById("toast");
  const busy = document.getElementById("busy");
  const busyTitle = document.getElementById("busyTitle");
  const busyText = document.getElementById("busyText");
  const busyBar = document.getElementById("busyBar");
  const btnBusyClose = document.getElementById("btnBusyClose");

  /* =========================
     Utils
  ========================== */
  const pad2 = (n) => String(n).padStart(2, "0");
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const toNumberOrNull = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  let toastTimer = null;
  function showToast(msg, ms=1600){
    toast.textContent = msg;
    toast.style.display = "block";
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { toast.style.display = "none"; }, ms);
  }

  function setBusy(on, title="‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...", text="-", pct=null){
    busy.style.display = on ? "flex" : "none";
    busyTitle.textContent = title;
    busyText.textContent = text;
    if (pct === null) busyBar.style.width = "0%";
    else busyBar.style.width = `${clamp(pct,0,100)}%`;
  }

  function showModal(backdropEl, on){
    backdropEl.style.display = on ? "flex" : "none";
    backdropEl.setAttribute("aria-hidden", on ? "false" : "true");
  }

  /* =========================
     Settings
  ========================== */
  let settings = readSettings();

  function readSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return { ...DEFAULT_SETTINGS };
      const obj = JSON.parse(raw);
      return { ...DEFAULT_SETTINGS, ...(obj || {}) };
    } catch {
      return { ...DEFAULT_SETTINGS };
    }
  }
  function writeSettings(next){
    settings = { ...settings, ...(next || {}) };
    try{
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } catch {}
    applySettingsToUI();
  }

  let saveTimer = null;
  function scheduleSave(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      try{
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectSettingsFromUI()));
        settings = readSettings();
      } catch {}
      applySettingsToUI();
    }, 220);
  }

  function applySettingsToInputs(){
    useNow.checked = !!settings.useNow;
    customTime.value = settings.customTime || "";
    timeFormat.value = settings.timeFormat || "thai_verbose";
    timeLines.value = settings.timeLines || "two";

    outputMode.value = settings.outputMode || "preset";
    outputSize.value = settings.outputSize || "1920x1440";
    fitMode.value = settings.fitMode || "contain";

    overlayPos.value = settings.overlayPos || "tr";
    overlayBoxEnable.checked = !!settings.overlayBoxEnable;
    overlayStrokeEnable.checked = (settings.overlayStrokeEnable ?? true);
    overlayMarginScale.value = String(settings.overlayMarginScale ?? 100);
    overlayPadScale.value = String(settings.overlayPadScale ?? 100);
    liveOverlayEnable.checked = (settings.liveOverlayEnable ?? true);

    fontAuto.checked = !!settings.fontAuto;
    fontScale.value = String(settings.fontScale ?? 100);
    fontPx.value = String(settings.fontPx ?? 32);

    enableLocation.checked = !!settings.enableLocation;
    showLatLng.checked = (settings.showLatLng ?? true);
    showAddress.checked = (settings.showAddress ?? true);
    latEl.value = settings.lat ?? "";
    lngEl.value = settings.lng ?? "";
    placeQuery.value = settings.placeQuery ?? "";

    defaultFormat.value = settings.defaultFormat || "image/jpeg";
    jpgQuality.value = String(settings.jpgQuality ?? 0.95);
    namePattern.value = settings.namePattern || "pt_now_index";
    preferFolderSave.checked = (settings.preferFolderSave ?? true);
    zipFallback.checked = (settings.zipFallback ?? true);

    // Preview defaults
    dlFormat.value = settings.defaultFormat || "image/jpeg";
    dlQuality.value = String(settings.jpgQuality ?? 0.95);

    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    updateDownloadAllState();
  }

  function collectSettingsFromUI(){
    return {
      useNow: useNow.checked,
      customTime: customTime.value || "",
      timeFormat: timeFormat.value,
      timeLines: timeLines.value,

      outputMode: outputMode.value,
      outputSize: outputSize.value,
      fitMode: fitMode.value,

      overlayPos: overlayPos.value,
      overlayBoxEnable: overlayBoxEnable.checked,
      overlayStrokeEnable: overlayStrokeEnable.checked,
      overlayMarginScale: Number(overlayMarginScale.value) || 100,
      overlayPadScale: Number(overlayPadScale.value) || 100,
      liveOverlayEnable: liveOverlayEnable.checked,

      fontAuto: fontAuto.checked,
      fontScale: Number(fontScale.value) || 100,
      fontPx: Number(fontPx.value) || 32,

      enableLocation: enableLocation.checked,
      showLatLng: showLatLng.checked,
      showAddress: showAddress.checked,
      lat: latEl.value || "",
      lng: lngEl.value || "",
      placeQuery: placeQuery.value || "",

      defaultFormat: defaultFormat.value,
      jpgQuality: clamp(Number(jpgQuality.value) || 0.95, 0.5, 1),
      namePattern: namePattern.value,
      preferFolderSave: preferFolderSave.checked,
      zipFallback: zipFallback.checked,

      preferredFacing: settings.preferredFacing || "environment",
      preferredDeviceId: settings.preferredDeviceId || "",
      torchOn: settings.torchOn || false
    };
  }

  function applySettingsToUI(){
    applySettingsToInputs();
  }

  /* =========================
     Time formatting
  ========================== */
  function parseDatetimeLocalToDate(v){
    if (!v) return null;
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return null;
    return d;
  }

  function getGlobalDate(){
    if (useNow.checked) return new Date();
    const d = parseDatetimeLocalToDate(customTime.value);
    return d;
  }

  function formatThaiVerbose(date){
    const d = date.getDate();
    const m = date.toLocaleString("th-TH", { month: "short" });
    const y = date.getFullYear();
    const hh = date.getHours();
    const mm = date.getMinutes();
    const ss = date.getSeconds();
    const tz = "GMT+07:00";
    return `${d} ${m}. ${y} ${hh} ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ ${mm} ‡∏ô‡∏≤‡∏ó‡∏µ ${ss} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ${tz}`;
  }
  function formatDDMMYYYY(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${dd}/${MM}/${yyyy} ${HH}:${mm}:${ss}`;
  }
  function formatYYYYMMDD(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${yyyy}-${MM}-${dd} ${HH}:${mm}:${ss}`;
  }
  function formatTimestamp(date){
    switch (timeFormat.value){
      case "ddmmyyyy_hms": return formatDDMMYYYY(date);
      case "yyyymmdd_hms": return formatYYYYMMDD(date);
      case "iso": return date.toISOString();
      case "thai_verbose":
      default: return formatThaiVerbose(date);
    }
  }
  function buildTimeLines(date){
    const t = formatTimestamp(date);
    if ((timeLines.value || "two") === "one") return [`Timestamp: ${t}`];
    return [`Network: ${t}`, `Local: ${t}`];
  }
  function updateTimeMini(){
    const d = getGlobalDate();
    timeMini.textContent = d ? formatTimestamp(d) : "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤";
  }

  /* =========================
     Main Time HUD (‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å)
     - NOW toggle
     - ‡πÅ‡∏ï‡∏∞ label ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤
  ========================== */
  function dateToDatetimeLocalValue(date){
    const yyyy = date.getFullYear();
    const MM = pad2(date.getMonth()+1);
    const dd = pad2(date.getDate());
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    return `${yyyy}-${MM}-${dd}T${HH}:${mm}`;
  }

  function syncMainTimeHUDFromSettings(){
    // NOW button state
    btnMainNow.classList.toggle("on", useNow.checked);
    btnMainNow.textContent = useNow.checked ? "NOW" : "SET";
    timeHint.style.display = "none";

    const d = getGlobalDate() || new Date();
    // label: ‡πÄ‡∏ô‡πâ‡∏ô‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ (‡∏™‡∏±‡πâ‡∏ô‡∏Å‡∏ß‡πà‡∏≤ thai_verbose)
    const label = (timeFormat.value === "thai_verbose")
      ? formatDDMMYYYY(d)
      : formatTimestamp(d);

    btnMainPick.textContent = label;
  }

  btnMainNow.addEventListener("click", () => {
    // toggle now/custom
    useNow.checked = !useNow.checked;
    if (useNow.checked){
      // keep customTime but not used
      syncMainTimeHUDFromSettings();
      scheduleSave();
      updateLiveOverlay();
      showToast("‚è± ‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô");
    } else {
      // switch to custom: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà now
      if (!customTime.value){
        customTime.value = dateToDatetimeLocalValue(new Date());
      }
      syncMainTimeHUDFromSettings();
      scheduleSave();
      updateLiveOverlay();
      showToast("üóìÔ∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏≠‡∏á");
      // ‡πÄ‡∏õ‡∏¥‡∏î picker ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠ UX
      setTimeout(() => { mainTimeInput.value = customTime.value; mainTimeInput.click(); }, 50);
    }
  });

  btnMainPick.addEventListener("click", () => {
    // open datetime picker (‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô custom)
    useNow.checked = false;
    if (!customTime.value){
      customTime.value = dateToDatetimeLocalValue(new Date());
    }
    mainTimeInput.value = customTime.value;
    syncMainTimeHUDFromSettings();
    scheduleSave();
    updateLiveOverlay();
    mainTimeInput.click();
  });

  mainTimeInput.addEventListener("change", () => {
    if (!mainTimeInput.value) return;
    useNow.checked = false;
    customTime.value = mainTimeInput.value;
    syncMainTimeHUDFromSettings();
    updateTimeMini();
    scheduleSave();
    updateLiveOverlay();
    showToast("‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß");
  });

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï label ‡∏ó‡∏∏‡∏Å‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ NOW
  setInterval(() => {
    if (useNow.checked){
      syncMainTimeHUDFromSettings();
      updateLiveOverlay(); // ‡πÉ‡∏´‡πâ overlay guide ‡πÄ‡∏î‡∏¥‡∏ô‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤
    }
  }, 1000);

  /* =========================
     Output + Font
  ========================== */
  function parseOutputSize(){
    const v = (outputSize.value || "1920x1440").toLowerCase().trim();
    const m = v.match(/^(\d+)\s*x\s*(\d+)$/);
    if (!m) return { w: 1920, h: 1440 };
    const w = Number(m[1]);
    const h = Number(m[2]);
    if (!Number.isFinite(w) || !Number.isFinite(h) || w < 1 || h < 1) return { w: 1920, h: 1440 };
    return { w, h };
  }

  function updateOutputUI(){
    const mode = outputMode.value;
    outputSize.disabled = (mode !== "preset");
    fitMode.disabled = (mode !== "preset");
    if (mode === "original"){
      outStatus.textContent = "Output = ‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏¥‡∏° (‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á)";
    } else {
      const { w, h } = parseOutputSize();
      outStatus.textContent = `Output = ${w}√ó${h} ‚Ä¢ Fit = ${fitMode.value === "contain" ? "Contain" : "Cover"}`;
    }
  }

  function updateFontUI(){
    const auto = fontAuto.checked;
    fontScale.disabled = !auto;
    fontPx.disabled = auto;
  }

  function computeFontSizePx(outW, outH){
    if (!fontAuto.checked){
      const px = Number(fontPx.value);
      return clamp(Number.isFinite(px) ? px : 32, 10, 200);
    }
    const base = Math.min(outW, outH);
    const autoPx = clamp(Math.round(base * 0.022), 12, 220);
    const scalePct = clamp(Number(fontScale.value) || 100, 50, 250);
    return clamp(Math.round(autoPx * (scalePct / 100)), 10, 240);
  }

  /* =========================
     Location + Geocode
  ========================== */
  function hasValidLatLng(){
    const lat = toNumberOrNull(latEl.value);
    const lng = toNumberOrNull(lngEl.value);
    if (lat === null || lng === null) return false;
    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
  }

  let addressText = "";
  let addressCacheKey = "";
  let lastGeoFetchAt = 0;

  async function reverseGeocode(lat, lng){
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=18&addressdetails=1`;
    const res = await fetch(url, {
      headers: { "Accept":"application/json", "Accept-Language":"th-TH,th;q=0.9,en;q=0.7" }
    });
    if (!res.ok) throw new Error("Reverse geocode failed");
    const data = await res.json();
    return data?.display_name || "";
  }

  async function forwardGeocode(q){
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&limit=1`;
    const res = await fetch(url, {
      headers: { "Accept":"application/json", "Accept-Language":"th-TH,th;q=0.9,en;q=0.7" }
    });
    if (!res.ok) throw new Error("Search place failed");
    const data = await res.json();
    if (!Array.isArray(data) || data.length === 0) return null;
    return { lat: Number(data[0].lat), lng: Number(data[0].lon), display_name: data[0].display_name || "" };
  }

  async function refreshAddressIfNeeded(){
    addressText = "";
    addressCacheKey = "";

    if (!enableLocation.checked){
      locStatus.textContent = "‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }
    if (!hasValidLatLng()){
      locStatus.textContent = "‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Lat/Lng ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|${showAddress.checked ? "addr" : "noaddr"}`;
    addressCacheKey = key;

    let msg = `Lat/Lng: ${lat.toFixed(6)}, ${lng.toFixed(6)}\n`;

    if (showAddress.checked){
      locStatus.textContent = msg + "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏≤‡∏Å Nominatim...";
      try{
        addressText = await reverseGeocode(lat, lng);
        msg += `Address: ${addressText || "(‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)"}`;
      } catch {
        msg += "Address: (‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‚Äî ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https)";
      }
    } else {
      msg += "Address: (‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)";
    }

    locStatus.textContent = msg;
    refreshLocMini();
    updateLiveOverlay();
  }

  function refreshLocMini(){
    if (!enableLocation.checked){
      locMini.textContent = "‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô";
      return;
    }
    if (hasValidLatLng()){
      locMini.textContent = `ON ‚Ä¢ ${Number(latEl.value).toFixed(4)}, ${Number(lngEl.value).toFixed(4)}`;
    } else {
      locMini.textContent = "ON ‚Ä¢ ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î";
    }
  }

  async function ensureAddressLazy(){
    if (!enableLocation.checked) return;
    if (!hasValidLatLng()) return;
    if (!showAddress.checked) return;
    if (addressText) return;

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|addr`;
    if (addressCacheKey === key && addressText) return;

    try{
      addressText = await reverseGeocode(lat, lng);
      addressCacheKey = key;
    } catch {}
  }

  /* =========================
     Overlay lines + Drawing
  ========================== */
  function buildOverlayLines(date){
    const lines = [];
    lines.push(...buildTimeLines(date));

    if (enableLocation.checked && hasValidLatLng()){
      const lat = Number(latEl.value);
      const lng = Number(lngEl.value);
      if (showLatLng.checked) lines.push(`üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
      if (showAddress.checked) lines.push(addressText ? addressText : "(‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°)");
    }
    return lines;
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawOverlayOnCanvas(ctx, lines, outW, outH){
    if (!lines || lines.length === 0) return;

    const fontSize = computeFontSizePx(outW, outH);
    const lineGap = Math.round(fontSize * 1.18);
    const marginScalePct = clamp(Number(overlayMarginScale.value) || 100, 50, 200);
    const padScalePct = clamp(Number(overlayPadScale.value) || 100, 50, 200);

    const margin = Math.round(Math.min(outW, outH) * 0.018 * (marginScalePct/100));
    const pad = Math.round(fontSize * 0.55 * (padScalePct/100));

    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");

    ctx.save();
    ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif`;
    ctx.textBaseline = "top";
    ctx.textAlign = isLeft ? "left" : "right";

    let maxW = 0;
    for (const line of lines){
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    }
    const boxW = Math.round(maxW + pad*2);
    const boxH = Math.round(lines.length * lineGap + pad*2 - (lineGap - fontSize));

    const x = isLeft ? margin : (outW - margin);
    const y = isTop ? margin : (outH - margin - boxH);
    const boxX = isLeft ? x : (x - boxW);

    // (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠) ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏î‡∏≥ ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏Ñ‡∏á option ‡πÉ‡∏ô settings
    if (overlayBoxEnable.checked){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = Math.max(1, Math.round(fontSize * 0.06));
      roundRect(ctx, boxX, y, boxW, boxH, Math.round(fontSize * 0.6));
      ctx.fill();
      ctx.stroke();
    }

    // shadow for readability (‡πÑ‡∏°‡πà‡∏°‡∏µ box ‡∏Å‡πá‡∏¢‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ)
    if (overlayStrokeEnable.checked){
      ctx.shadowColor = "rgba(0,0,0,.85)";
      ctx.shadowBlur = Math.round(fontSize * 0.45);
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = "#fff";
    const textX = isLeft ? (boxX + pad) : (boxX + boxW - pad);
    let ty = y + pad;

    for (const line of lines){
      if (overlayStrokeEnable.checked){
        ctx.save();
        ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,.70)";
        ctx.strokeText(line, textX, ty);
        ctx.restore();
      }
      ctx.fillText(line, textX, ty);
      ty += lineGap;
    }

    ctx.restore();
  }

  function updateLiveOverlay(){
    if (!liveOverlayEnable.checked){
      liveOverlayText.style.display = "none";
      return;
    }
    const d = getGlobalDate();
    if (!d){
      liveOverlayText.style.display = "none";
      return;
    }
    const lines = buildOverlayLines(d);
    if (!lines.length){
      liveOverlayText.style.display = "none";
      return;
    }

    // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á overlay ‡∏ö‡∏ô‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß (‡∏ï‡∏≤‡∏° overlayPos)
    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");
    liveOverlay.style.alignItems = isTop ? "flex-start" : "flex-end";
    liveOverlay.style.justifyContent = isLeft ? "flex-start" : "flex-end";

    liveOverlayText.style.display = "block";
    liveOverlayText.textContent = lines.join("\n");
  }

  /* =========================
     EXIF orientation fix
  ========================== */
  async function getExifOrientation(file){
    try{
      if (!file || !file.type || !file.type.toLowerCase().includes("jpeg")) return 1;
      const buf = await file.arrayBuffer();
      const view = new DataView(buf);

      if (view.getUint16(0, false) !== 0xFFD8) return 1;
      let offset = 2;
      const length = view.byteLength;

      while (offset < length){
        if (view.getUint8(offset) !== 0xFF) break;
        const marker = view.getUint16(offset, false);
        offset += 2;

        if (marker === 0xFFE1){
          offset += 2;
          if (view.getUint32(offset, false) !== 0x45786966) return 1;
          offset += 6;

          const tiffOffset = offset;
          const endianness = view.getUint16(tiffOffset, false);
          const little = (endianness === 0x4949);
          if (!little && endianness !== 0x4D4D) return 1;

          const getU16 = (o) => view.getUint16(o, little);
          const getU32 = (o) => view.getUint32(o, little);

          if (getU16(tiffOffset + 2) !== 0x002A) return 1;

          const ifd0Offset = getU32(tiffOffset + 4);
          let dirOffset = tiffOffset + ifd0Offset;
          if (dirOffset < 0 || dirOffset > length - 2) return 1;

          const entries = getU16(dirOffset);
          dirOffset += 2;

          for (let i=0;i<entries;i++){
            const entryOffset = dirOffset + i*12;
            if (entryOffset + 12 > length) break;
            const tag = getU16(entryOffset);
            if (tag === 0x0112){
              const type = getU16(entryOffset + 2);
              const count = getU32(entryOffset + 4);
              if (type !== 3 || count !== 1) return 1;
              const valOffset = entryOffset + 8;
              const orient = getU16(valOffset);
              return (orient >= 1 && orient <= 8) ? orient : 1;
            }
          }
          return 1;
        } else {
          if (offset + 2 > length) break;
          const size = view.getUint16(offset, false);
          offset += size;
        }
      }
      return 1;
    } catch {
      return 1;
    }
  }

  async function blobToImage(blob){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const im = new Image();
      im.onload = () => resolve({ im, url });
      im.onerror = () => { try{ URL.revokeObjectURL(url);}catch{}; reject(new Error("Image onerror(blobUrl)")); };
      im.src = url;
    });
  }

  function drawWithOrientationToCanvas(img, orientation){
    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const c = document.createElement("canvas");
    const cctx = c.getContext("2d");

    if ([5,6,7,8].includes(orientation)){ c.width = h; c.height = w; }
    else { c.width = w; c.height = h; }

    cctx.save();
    switch (orientation){
      case 2: cctx.translate(w, 0); cctx.scale(-1, 1); break;
      case 3: cctx.translate(w, h); cctx.rotate(Math.PI); break;
      case 4: cctx.translate(0, h); cctx.scale(1, -1); break;
      case 5: cctx.rotate(0.5*Math.PI); cctx.scale(1, -1); break;
      case 6: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); break;
      case 7: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); cctx.scale(-1, 1); break;
      case 8: cctx.translate(0, w); cctx.rotate(-0.5*Math.PI); break;
      default: break;
    }
    cctx.drawImage(img, 0, 0);
    cctx.restore();
    return c;
  }

  function drawContain(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.min(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  function drawCover(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.max(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  /* =========================
     Session Gallery
     - ‡πÄ‡∏û‡∏¥‡πà‡∏° per-photo time: p.stampMode ("global"|"custom"), p.stampTime (datetime-local string)
  ========================== */
  const photos = []; // {id, blob, type, fromCamera, capturedAt, exifOrientation, thumbUrl, correctedCacheCanvas, lastPreviewUrl, stampMode, stampTime}
  let activePhotoId = null;

  function updateDownloadAllState(){
    btnDownloadAll.disabled = photos.length === 0;
    btnDeleteAll.style.display = photos.length > 0 ? "inline-flex" : "none";
    btnLatest.disabled = photos.length === 0;
    countBadge.style.display = photos.length > 0 ? "block" : "none";
    countBadge.textContent = String(photos.length);
  }

  function updateLatestThumb(){
    if (photos.length === 0){
      latestImg.style.display = "none";
      latestPlaceholder.style.display = "inline";
      btnLatest.disabled = true;
      updateDownloadAllState();
      return;
    }
    const p = photos[photos.length - 1];
    if (p.thumbUrl){
      latestImg.src = p.thumbUrl;
      latestImg.style.display = "block";
      latestPlaceholder.style.display = "none";
      btnLatest.disabled = false;
    } else {
      latestImg.style.display = "none";
      latestPlaceholder.style.display = "inline";
    }
    updateDownloadAllState();
  }

  function renderFilmstrip(){
    filmstrip.innerHTML = "";
    if (photos.length === 0){
      const empty = document.createElement("div");
      empty.className = "emptyPill";
      empty.textContent = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ ‚Äî ‡∏ñ‡πà‡∏≤‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠ Import";
      filmstrip.appendChild(empty);
      updateLatestThumb();
      return;
    }

    photos.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "thumb" + (p.id === activePhotoId ? " active" : "");
      div.dataset.id = p.id;

      const img = document.createElement("img");
      img.alt = `thumb ${idx+1}`;
      img.src = p.thumbUrl || "";
      div.appendChild(img);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(idx+1);
      div.appendChild(num);

      const del = document.createElement("div");
      del.className = "del";
      del.textContent = "√ó";
      del.title = "‡∏•‡∏ö‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ";
      del.addEventListener("click", (e) => {
        e.stopPropagation();
        removePhotoById(p.id);
      });
      div.appendChild(del);

      div.addEventListener("click", () => openPreview(p.id));
      filmstrip.appendChild(div);
    });

    updateLatestThumb();
  }

  async function generateThumbnailForPhoto(p){
    try{
      const { im, url } = await blobToImage(p.blob);
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected;
      try { URL.revokeObjectURL(url); } catch {}

      const maxSide = 260;
      const tw = corrected.width;
      const th = corrected.height;
      const scale = Math.min(1, maxSide / Math.max(tw, th));
      const cw = Math.max(1, Math.round(tw * scale));
      const ch = Math.max(1, Math.round(th * scale));
      const tcan = document.createElement("canvas");
      tcan.width = cw;
      tcan.height = ch;
      tcan.getContext("2d").drawImage(corrected, 0,0, tw,th, 0,0, cw,ch);

      p.thumbUrl = tcan.toDataURL("image/jpeg", 0.85);
    } catch {
      p.thumbUrl = "";
    }
    renderFilmstrip();
  }

  async function addPhotoFromBlob(blob, {fromCamera=false, capturedAt=null, exifOrientation=1} = {}){
    const id = `p_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const p = {
      id,
      blob,
      type: blob.type || "image/jpeg",
      fromCamera: !!fromCamera,
      capturedAt: capturedAt || new Date(),
      exifOrientation,
      thumbUrl: "",
      correctedCacheCanvas: null,
      lastPreviewUrl: "",
      stampMode: "global",
      stampTime: "" // datetime-local string
    };
    photos.push(p);
    activePhotoId = id;
    renderFilmstrip();
    await generateThumbnailForPhoto(p);
    showToast(fromCamera ? "üì∏ ‡∏ñ‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‚úÖ" : "üñºÔ∏è ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‚úÖ");
    renderFilmstrip();
  }

  async function addPhotosFromFiles(fileList){
    const files = Array.from(fileList || []).filter(Boolean);
    if (files.length === 0) return;

    setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏π‡∏õ...", `0 / ${files.length}`, 0);

    for (let i=0;i<files.length;i++){
      const f = files[i];
      try{
        const orient = await getExifOrientation(f);
        await addPhotoFromBlob(f, { fromCamera:false, capturedAt:new Date(), exifOrientation: orient });
      } catch {}
      const pct = Math.round(((i+1)/files.length)*100);
      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏π‡∏õ...", `${i+1} / ${files.length}`, pct);
    }
    setBusy(false);
  }

  function findPhotoIndexById(id){
    return photos.findIndex(p => p.id === id);
  }
  function getActivePhoto(){
    if (!activePhotoId) return null;
    return photos.find(p => p.id === activePhotoId) || null;
  }

  function removePhotoById(id){
    const idx = findPhotoIndexById(id);
    if (idx < 0) return;
    const p = photos[idx];
    try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
    photos.splice(idx, 1);

    if (photos.length === 0){
      activePhotoId = null;
      showToast("‡∏•‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏•‡πâ‡∏ß");
      closePreview();
    } else {
      const nextIdx = Math.min(idx, photos.length-1);
      activePhotoId = photos[nextIdx].id;
      showToast("‡∏•‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏•‡πâ‡∏ß");
      // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô preview ‡∏Å‡πá rerender ‡∏ï‡πà‡∏≠
      if (previewBackdrop.style.display === "flex") renderPreview();
    }

    renderFilmstrip();
  }

  function deleteAllPhotos(){
    if (photos.length === 0) return;
    const ok = confirm(`‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${photos.length} ‡∏£‡∏π‡∏õ?\n(‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÑ‡∏î‡πâ‡∏î‡πâ‡∏ß‡∏¢ Cancel)`);
    if (!ok) return;

    // cleanup urls
    for (const p of photos){
      try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
    }
    photos.length = 0;
    activePhotoId = null;
    renderFilmstrip();
    closePreview();
    showToast("üóëÔ∏è ‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß");
  }

  /* =========================
     Per-photo time helpers
  ========================== */
  function getStampDateForPhoto(p){
    // priority: per-photo custom -> global
    if (p?.stampMode === "custom"){
      const d = parseDatetimeLocalToDate(p.stampTime);
      if (d) return d;
    }
    return getGlobalDate();
  }

  function applyPhotoTimeUI(p){
    if (!p) return;
    const isCustom = (p.stampMode === "custom");
    photoUseCustomTime.checked = isCustom;
    photoTimeInput.disabled = !isCustom;

    if (isCustom){
      if (!p.stampTime){
        // default custom time = global time (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
        const gd = getGlobalDate() || new Date();
        p.stampTime = dateToDatetimeLocalValue(gd);
      }
      photoTimeInput.value = p.stampTime;
    } else {
      photoTimeInput.value = "";
    }
  }

  /* =========================
     Render per photo
  ========================== */
  async function getCorrectedCanvasForPhoto(p){
    if (p.correctedCacheCanvas) return p.correctedCacheCanvas;

    const { im, url } = await blobToImage(p.blob);
    try{
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected;
      return corrected;
    } finally {
      try{ URL.revokeObjectURL(url); } catch {}
    }
  }

  function getOutputDims(srcW, srcH){
    if (outputMode.value === "original"){
      return { outW: srcW, outH: srcH, mode: "original" };
    }
    const { w, h } = parseOutputSize();
    return { outW: w, outH: h, mode: "preset" };
  }

  async function renderPhotoToBlob(p, { mime=null, quality=null } = {}){
    const d = getStampDateForPhoto(p);
    if (!d) throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤ (NOW ‡∏´‡∏£‡∏∑‡∏≠ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏≠‡∏á)");

    await ensureAddressLazy();

    const src = await getCorrectedCanvasForPhoto(p);
    const sw = src.width;
    const sh = src.height;

    const { outW, outH } = getOutputDims(sw, sh);
    const outCanvas = document.createElement("canvas");
    outCanvas.width = outW;
    outCanvas.height = outH;
    const ctx = outCanvas.getContext("2d", { alpha:false });

    if (outputMode.value === "original"){
      ctx.drawImage(src, 0,0, sw,sh, 0,0, outW,outH);
    } else {
      if (fitMode.value === "cover") drawCover(ctx, src, outW, outH);
      else drawContain(ctx, src, outW, outH);
    }

    const lines = buildOverlayLines(d);
    drawOverlayOnCanvas(ctx, lines, outW, outH);

    const finalMime = mime || defaultFormat.value || "image/jpeg";
    let q = quality;
    if (q == null) q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const blob = await new Promise((resolve, reject) => {
      outCanvas.toBlob((b) => {
        if (!b) return reject(new Error("toBlob failed"));
        resolve(b);
      }, finalMime, finalMime === "image/jpeg" ? q : undefined);
    });

    return { blob, outW, outH, linesCount: lines.length, mime: finalMime, quality: finalMime === "image/jpeg" ? q : null };
  }

  function buildFilename(baseDate, index1, ext, p){
    const yyyy = baseDate.getFullYear();
    const MM = pad2(baseDate.getMonth()+1);
    const dd = pad2(baseDate.getDate());
    const HH = pad2(baseDate.getHours());
    const mm = pad2(baseDate.getMinutes());
    const ss = pad2(baseDate.getSeconds());

    const idx = String(index1).padStart(2, "0");
    const stampNow = `${yyyy}${MM}${dd}_${HH}${mm}${ss}`;

    if (namePattern.value === "pt_capture_index" && p?.capturedAt){
      const cd = p.capturedAt;
      const cy = cd.getFullYear();
      const cM = pad2(cd.getMonth()+1);
      const cD = pad2(cd.getDate());
      const cH = pad2(cd.getHours());
      const cm = pad2(cd.getMinutes());
      const cs = pad2(cd.getSeconds());
      return `PT_${cy}${cM}${cD}_${cH}${cm}${cs}_${idx}.${ext}`;
    }
    return `PT_${stampNow}_${idx}.${ext}`;
  }

  function triggerDownload(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => { try{ URL.revokeObjectURL(url);}catch{} }, 1200);
  }

  /* =========================
     Preview flow
  ========================== */
  function openPreview(id){
    activePhotoId = id;
    renderFilmstrip();
    showModal(previewBackdrop, true);
    const p = getActivePhoto();
    applyPhotoTimeUI(p);
    renderPreview();
  }

  function closePreview(){
    showModal(previewBackdrop, false);
  }

  async function renderPreview(){
    const p = getActivePhoto();
    if (!p){
      previewMeta.textContent = "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ";
      return;
    }

    btnDownloadPhoto.disabled = true;
    btnDeletePhoto.disabled = true;
    btnReRender.disabled = true;

    previewMeta.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á render...";
    previewImg.src = "";

    try{
      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á render preview...", "‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà", null);

      const mime = dlFormat.value || "image/jpeg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const url = URL.createObjectURL(r.blob);

      try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
      p.lastPreviewUrl = url;

      previewImg.src = url;

      const idx = findPhotoIndexById(p.id);
      const ext = (mime === "image/png") ? "png" : "jpg";
      const filename = buildFilename(new Date(), idx+1, ext, p);

      const usedDate = getStampDateForPhoto(p);
      const usedStr = usedDate ? formatDDMMYYYY(usedDate) : "-";
      const modeStr = (p.stampMode === "custom") ? "custom (per-photo)" : "global";

      previewMeta.textContent =
        `#${idx+1}\n` +
        `StampTime: ${modeStr} ‚Ä¢ ${usedStr}\n` +
        `Source: ${p.fromCamera ? "Camera" : "File"} ‚Ä¢ EXIF: ${p.fromCamera ? "-" : (p.exifOrientation || 1)}\n` +
        `Output: ${r.outW}√ó${r.outH} ‚Ä¢ Lines: ${r.linesCount}\n` +
        `Format: ${mime === "image/png" ? "PNG" : `JPG (q=${r.quality})`}\n` +
        `Filename: ${filename}`;

      btnDownloadPhoto.disabled = false;
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;

      setBusy(false);
      updateLiveOverlay();
    } catch (e){
      setBusy(false);
      previewMeta.textContent = `Render ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${String(e.message || e)}`;
      showToast("‚ùå Render ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;
    }
  }

  /* =========================
     Download All
  ========================== */
  async function downloadAll(){
    if (photos.length === 0) return;

    const mime = defaultFormat.value || "image/jpeg";
    const ext = (mime === "image/png") ? "png" : "jpg";
    const q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const batchDate = new Date();
    const canFS = !!window.showDirectoryPicker;

    try{
      setBusy(true, "Download All", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°...", 0);

      if (preferFolderSave.checked && canFS){
        const dir = await window.showDirectoryPicker({ mode: "readwrite" });

        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);

          const handle = await dir.getFileHandle(filename, { create:true });
          const writable = await handle.createWritable();
          await writable.write(r.blob);
          await writable.close();

          setBusy(true, "Download All", `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß: ${i+1} / ${photos.length}`, Math.round(((i+1)/photos.length)*100));
        }

        setBusy(false);
        showToast("‚úÖ Download All ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß (‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå)");
        return;
      }

      if (zipFallback.checked && window.JSZip){
        const zip = new window.JSZip();
        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All (ZIP)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);
          zip.file(filename, r.blob);
        }

        setBusy(true, "Download All (ZIP)", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP...", 96);
        const zipBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
          const pct = clamp(Math.round(meta.percent), 0, 100);
          setBusy(true, "Download All (ZIP)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP... ${pct}%`, pct);
        });

        const zipName = `PT_${batchDate.getFullYear()}${pad2(batchDate.getMonth()+1)}${pad2(batchDate.getDate())}_${pad2(batchDate.getHours())}${pad2(batchDate.getMinutes())}${pad2(batchDate.getSeconds())}.zip`;
        triggerDownload(zipBlob, zipName);
        setBusy(false);
        showToast("‚úÖ Download All ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß (ZIP)");
        return;
      }

      for (let i=0;i<photos.length;i++){
        const p = photos[i];
        setBusy(true, "Download All (fallback)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));
        const r = await renderPhotoToBlob(p, { mime, quality: q });
        const filename = buildFilename(batchDate, i+1, ext, p);
        triggerDownload(r.blob, filename);
        await new Promise(r => setTimeout(r, 180));
      }

      setBusy(false);
      showToast("‚úÖ Download All (fallback)");
    } catch (e){
      setBusy(false);
      showToast("‚ùå Download All ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
    }
  }

  /* =========================
     Camera
  ========================== */
  let camStream = null;
  let currentFacing = "environment";
  let videoDevices = [];
  let selectedDeviceId = "";

  function setCamIndicator(ok){
    dotCam.className = "dot " + (ok ? "ok" : "err");
  }

  function isUserFacingNow(){
    return (currentFacing === "user");
  }

  function applyMirrorClass(){
    camVideo.classList.toggle("mirror", isUserFacingNow());
  }

  async function stopCamera(){
    try{
      if (camStream) camStream.getTracks().forEach(t => t.stop());
    } catch {}
    camStream = null;
    camVideo.srcObject = null;
    btnTorch.disabled = true;
    btnTorch.classList.remove("on");
    setCamIndicator(false);
  }

  async function refreshDevices(){
    if (!navigator.mediaDevices?.enumerateDevices) return [];
    const all = await navigator.mediaDevices.enumerateDevices();
    videoDevices = all.filter(d => d.kind === "videoinput");
    return videoDevices;
  }

  function getVideoTrack(){
    try{ return camStream?.getVideoTracks?.()[0] || null; }
    catch { return null; }
  }

  async function refreshTorchSupport(){
    const track = getVideoTrack();
    if (!track){
      btnTorch.disabled = true;
      btnTorch.classList.remove("on");
      return;
    }
    const caps = track.getCapabilities ? track.getCapabilities() : null;
    const supported = !!(caps && "torch" in caps);
    btnTorch.disabled = !supported;
    if (!supported){
      btnTorch.classList.remove("on");
      settings.torchOn = false;
      return;
    }
    btnTorch.classList.toggle("on", !!settings.torchOn);
  }

  async function setTorch(on){
    const track = getVideoTrack();
    if (!track || !track.applyConstraints) throw new Error("torch not supported");
    await track.applyConstraints({ advanced: [{ torch: !!on }] });
    settings.torchOn = !!on;
    btnTorch.classList.toggle("on", !!on);
    writeSettings({ torchOn: !!on });
  }

  async function startCamera({ forceFacing=null, forceDeviceId=null } = {}){
    if (!navigator.mediaDevices?.getUserMedia){
      setCamIndicator(false);
      showToast("‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
      return;
    }

    try{
      await stopCamera();

      currentFacing = forceFacing || settings.preferredFacing || "environment";
      selectedDeviceId = forceDeviceId || settings.preferredDeviceId || "";

      const constraints = {
        video: { width:{ideal:1920}, height:{ideal:1080} },
        audio: false
      };

      if (selectedDeviceId) constraints.video.deviceId = { exact: selectedDeviceId };
      else constraints.video.facingMode = { ideal: currentFacing };

      camStream = await navigator.mediaDevices.getUserMedia(constraints);
      camVideo.srcObject = camStream;
      try { await camVideo.play(); } catch {}

      setCamIndicator(true);
      applyMirrorClass();

      try{ await refreshDevices(); } catch {}
      await refreshTorchSupport();

      writeSettings({
        preferredFacing: currentFacing,
        preferredDeviceId: selectedDeviceId || ""
      });

      updateLiveOverlay();
    } catch {
      setCamIndicator(false);
      showToast("‚ùå ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô https + ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏•‡πâ‡∏≠‡∏á)");
    }
  }

  async function switchCamera(){
    try{ await refreshDevices(); } catch {}

    if (videoDevices.length >= 2){
      let idx = videoDevices.findIndex(d => d.deviceId === selectedDeviceId);
      idx = (idx < 0) ? 0 : idx;
      const next = videoDevices[(idx + 1) % videoDevices.length];
      selectedDeviceId = next.deviceId;

      const label = (next.label || "").toLowerCase();
      const likelyFront = label.includes("front") || label.includes("user") || label.includes("facetime");
      currentFacing = likelyFront ? "user" : "environment";

      await startCamera({ forceFacing: currentFacing, forceDeviceId: selectedDeviceId });
      showToast("üîÑ ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
      return;
    }

    currentFacing = (currentFacing === "environment") ? "user" : "environment";
    selectedDeviceId = "";
    await startCamera({ forceFacing: currentFacing, forceDeviceId: "" });
    showToast("üîÑ ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
  }

  async function snapPhoto(){
    if (!camStream || !camVideo.videoWidth || !camVideo.videoHeight){
      showToast("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ñ‡πà‡∏≤‡∏¢ (‡∏•‡∏≠‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô)");
      await startCamera({ forceFacing: currentFacing || "environment" });
      return;
    }

    const vw = camVideo.videoWidth;
    const vh = camVideo.videoHeight;

    const c = document.createElement("canvas");
    c.width = vw;
    c.height = vh;
    const cctx = c.getContext("2d", { alpha:false });

    // Front camera: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏ö‡∏ö mirror ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß (‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏≠)
    if (isUserFacingNow()){
      cctx.save();
      cctx.translate(vw, 0);
      cctx.scale(-1, 1);
      cctx.drawImage(camVideo, 0, 0, vw, vh);
      cctx.restore();
    } else {
      cctx.drawImage(camVideo, 0, 0, vw, vh);
    }

    const rawBlob = await new Promise((resolve, reject) => {
      c.toBlob((b) => {
        if (!b) return reject(new Error("capture toBlob failed"));
        resolve(b);
      }, "image/jpeg", 0.95);
    });

    await addPhotoFromBlob(rawBlob, { fromCamera:true, capturedAt:new Date(), exifOrientation: 1 });
  }

  /* =========================
     Leaflet map
  ========================== */
  let map = null;
  let mapMarker = null;

  function openMap(){
    if (!window.L){
      locStatus.textContent = "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (Leaflet) ‚Äî ‡∏ï‡∏£‡∏ß‡∏à‡πÄ‡∏ô‡πá‡∏ï/‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https";
      mapWrap.style.display = "none";
      return;
    }

    mapWrap.style.display = "block";
    const lat = hasValidLatLng() ? Number(latEl.value) : 13.7563;
    const lng = hasValidLatLng() ? Number(lngEl.value) : 100.5018;

    if (!map){
      map = L.map('map', { zoomControl: true }).setView([lat, lng], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);

      mapMarker = L.marker([lat, lng]).addTo(map);

      map.on('click', async (e) => {
        latEl.value = e.latlng.lat;
        lngEl.value = e.latlng.lng;
        mapMarker.setLatLng(e.latlng);
        addressText = "";
        if (!enableLocation.checked) enableLocation.checked = true;
        await refreshAddressIfNeeded();
        scheduleSave();
      });
    } else {
      map.setView([lat, lng], 15);
      if (mapMarker) mapMarker.setLatLng([lat, lng]);
    }
    setTimeout(() => map.invalidateSize(), 120);
  }

  function closeMap(){ mapWrap.style.display = "none"; }

  /* =========================
     Wire events
  ========================== */
  btnBusyClose.addEventListener("click", () => setBusy(false));

  btnSettings.addEventListener("click", () => {
    applySettingsToInputs();
    showModal(settingsBackdrop, true);
  });
  btnCloseSettings.addEventListener("click", () => showModal(settingsBackdrop, false));

  btnApplySettings.addEventListener("click", async () => {
    writeSettings(collectSettingsFromUI());
    showModal(settingsBackdrop, false);
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    await refreshAddressIfNeeded();
    showToast("‚úÖ Apply/Save ‡πÅ‡∏•‡πâ‡∏ß");
  });

  btnResetSettings.addEventListener("click", async () => {
    writeSettings({ ...DEFAULT_SETTINGS, preferredFacing: settings.preferredFacing, preferredDeviceId: settings.preferredDeviceId, torchOn: false });
    showToast("‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß");
    await refreshAddressIfNeeded();
  });

  // settings -> debounced save
  const bindSave = (el, evt="change") => el.addEventListener(evt, () => {
    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(useNow, "change");
  bindSave(customTime, "input");
  bindSave(timeFormat, "change");
  bindSave(timeLines, "change");

  btnSetNow.addEventListener("click", () => {
    const now = new Date();
    customTime.value = dateToDatetimeLocalValue(now);
    useNow.checked = true;
    updateTimeMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(outputMode, "change");
  bindSave(outputSize, "change");
  bindSave(fitMode, "change");

  bindSave(overlayPos, "change");
  bindSave(overlayBoxEnable, "change");
  bindSave(overlayStrokeEnable, "change");
  bindSave(overlayMarginScale, "input");
  bindSave(overlayPadScale, "input");
  bindSave(liveOverlayEnable, "change");

  bindSave(fontAuto, "change");
  bindSave(fontScale, "input");
  bindSave(fontPx, "input");

  enableLocation.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showLatLng.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showAddress.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  latEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });
  lngEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });

  btnUseGPS.addEventListener("click", async () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();

    if (!navigator.geolocation){
      locStatus.textContent = "‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå/‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö GPS";
      showToast("GPS ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö");
      return;
    }

    locStatus.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏≤‡∏Å GPS...";
    navigator.geolocation.getCurrentPosition(async (pos) => {
      latEl.value = pos.coords.latitude;
      lngEl.value = pos.coords.longitude;
      addressText = "";
      await refreshAddressIfNeeded();
      scheduleSave();
      showToast("üìç ‡πÑ‡∏î‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß");
    }, (err) => {
      locStatus.textContent = "‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: " + (err?.message || "unknown error");
      showToast("‚ùå ‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
    }, { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 });
  });

  btnPickOnMap.addEventListener("click", () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();
    openMap();
  });

  btnConfirmMap.addEventListener("click", async () => {
    if (!hasValidLatLng()){
      locStatus.textContent = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      return;
    }
    closeMap();
    await refreshAddressIfNeeded();
    scheduleSave();
    showToast("‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß");
  });
  btnCloseMap.addEventListener("click", closeMap);

  btnSearchPlace.addEventListener("click", async () => {
    const q = (placeQuery.value || "").trim();
    if (!q) return;
    if (!enableLocation.checked) enableLocation.checked = true;

    locStatus.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà...";
    try{
      const r = await forwardGeocode(q);
      if (!r){
        locStatus.textContent = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà";
        showToast("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà");
        return;
      }
      latEl.value = r.lat;
      lngEl.value = r.lng;
      addressText = r.display_name || "";
      await refreshAddressIfNeeded();
      scheduleSave();

      if (map && window.L){
        map.setView([r.lat, r.lng], 17);
        if (!mapMarker) mapMarker = L.marker([r.lat, r.lng]).addTo(map);
        mapMarker.setLatLng([r.lat, r.lng]);
      }
      showToast("üîé ‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß");
    } catch {
      locStatus.textContent = "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https)";
      showToast("‚ùå ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
    }
  });

  bindSave(defaultFormat, "change");
  bindSave(jpgQuality, "input");
  bindSave(namePattern, "change");
  bindSave(preferFolderSave, "change");
  bindSave(zipFallback, "change");

  // Top bar actions
  btnTorch.addEventListener("click", async () => {
    if (btnTorch.disabled){
      showToast("Torch ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö");
      return;
    }
    try{
      const next = !btnTorch.classList.contains("on");
      await setTorch(next);
      showToast(next ? "‚ö° Torch ON" : "‚ö° Torch OFF");
    } catch {
      showToast("Torch ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
    }
  });

  btnImport.addEventListener("click", () => {
    fileInput.value = "";
    fileInput.click();
  });

  fileInput.addEventListener("change", async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    await addPhotosFromFiles(files);
  });

  btnDownloadAll.addEventListener("click", downloadAll);

  // Bottom controls
  btnSwitchCam.addEventListener("click", switchCamera);
  btnShutter.addEventListener("click", snapPhoto);

  btnLatest.addEventListener("click", () => {
    if (photos.length === 0) return;
    const last = photos[photos.length - 1];
    openPreview(last.id);
  });

  btnDeleteAll.addEventListener("click", deleteAllPhotos);

  // Preview modal actions
  btnClosePreview.addEventListener("click", closePreview);
  previewBackdrop.addEventListener("click", (e) => { if (e.target === previewBackdrop) closePreview(); });

  btnReRender.addEventListener("click", renderPreview);

  btnPrevPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx <= 0) return;
    openPreview(photos[idx-1].id);
  });

  btnNextPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx >= photos.length-1) return;
    openPreview(photos[idx+1].id);
  });

  btnDeletePhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    removePhotoById(p.id);
  });

  btnDownloadPhoto.addEventListener("click", async () => {
    const p = getActivePhoto();
    if (!p) return;

    try{
      const idx = findPhotoIndexById(p.id);
      const mime = dlFormat.value || "image/jpeg";
      const ext = (mime === "image/png") ? "png" : "jpg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...", "‡∏Å‡∏≥‡∏•‡∏±‡∏á render ‡πÑ‡∏ü‡∏•‡πå", null);
      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const filename = buildFilename(new Date(), idx+1, ext, p);
      triggerDownload(r.blob, filename);
      setBusy(false);

      showToast("‚¨áÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡πâ‡∏ß");
    } catch (e){
      setBusy(false);
      showToast("‚ùå ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
    }
  });

  // Per-photo time events
  photoUseCustomTime.addEventListener("change", () => {
    const p = getActivePhoto();
    if (!p) return;

    p.stampMode = photoUseCustomTime.checked ? "custom" : "global";
    photoTimeInput.disabled = !photoUseCustomTime.checked;

    if (photoUseCustomTime.checked){
      if (!p.stampTime){
        const gd = getGlobalDate() || new Date();
        p.stampTime = dateToDatetimeLocalValue(gd);
      }
      photoTimeInput.value = p.stampTime;
    } else {
      photoTimeInput.value = "";
    }
    renderPreview();
  });

  photoTimeInput.addEventListener("change", () => {
    const p = getActivePhoto();
    if (!p) return;
    if (!photoTimeInput.value) return;

    p.stampMode = "custom";
    p.stampTime = photoTimeInput.value;
    photoUseCustomTime.checked = true;
    photoTimeInput.disabled = false;
    renderPreview();
  });

  btnCopyMainTime.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;

    const gd = getGlobalDate() || new Date();
    p.stampMode = "custom";
    p.stampTime = dateToDatetimeLocalValue(gd);

    photoUseCustomTime.checked = true;
    photoTimeInput.disabled = false;
    photoTimeInput.value = p.stampTime;

    renderPreview();
    showToast("‚úÖ ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å‡πÅ‡∏•‡πâ‡∏ß");
  });

  // Settings modal backdrop click
  settingsBackdrop.addEventListener("click", (e) => {
    if (e.target === settingsBackdrop) showModal(settingsBackdrop, false);
  });

  // Keyboard
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (settingsBackdrop.style.display === "flex") showModal(settingsBackdrop, false);
      if (previewBackdrop.style.display === "flex") closePreview();
    }
  });

  window.addEventListener("beforeunload", () => { try{ stopCamera(); } catch {} });

  /* =========================
     Boot
  ========================== */
  function boot(){
    applySettingsToUI();
    renderFilmstrip();
    refreshLocMini();
    updateTimeMini();
    syncMainTimeHUDFromSettings();
    updateLiveOverlay();
    startCamera({ forceFacing: settings.preferredFacing || "environment", forceDeviceId: settings.preferredDeviceId || "" });
  }

  boot();
})();
</script>
</body>
</html>
