<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>PT Timestamp Camera (Camera-first) v3.0</title>

  <!-- Leaflet (‡πÉ‡∏ä‡πâ‡∏ï‡∏≠‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ô Settings ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- (Optional) JSZip: ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô fallback ‡∏ñ‡πâ‡∏≤ File System Access API ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>

  <style>
    :root{
      --bg:#000;
      --card:#0b0f14;
      --card2:#0d131a;
      --line:rgba(255,255,255,.10);
      --text:#e8f1ff;
      --muted:rgba(232,241,255,.72);
      --muted2:rgba(232,241,255,.55);
      --accent:#10b981;
      --danger:#ef4444;
      --warn:#f59e0b;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:18px;
      --radius2:22px;

      --safe-b: env(safe-area-inset-bottom);
      --safe-t: env(safe-area-inset-top);
      --safe-l: env(safe-area-inset-left);
      --safe-r: env(safe-area-inset-right);
    }
    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif;
      overflow:hidden;
    }
    button, input, select{
      font-family: inherit;
      -webkit-tap-highlight-color: transparent;
    }

    /* ====== Stage ====== */
    .stage{
      position:relative;
      width:100%;
      height: 100svh;
      height: 100dvh;
      background:#000;
      overflow:hidden;
      touch-action: manipulation;
    }

    .videoWrap{
      position:absolute;
      inset:0;
      background:#000;
    }

    video#camVideo{
      width:100%;
      height:100%;
      object-fit: cover;
      background:#000;
      transform: translateZ(0);
    }
    /* mirror preview */
    video#camVideo.mirror{
      transform: scaleX(-1) translateZ(0);
    }

    /* Live overlay (preview-only) */
    .liveOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:flex;
      align-items:flex-start;
      justify-content:flex-end;
      padding: calc(10px + var(--safe-t)) calc(10px + var(--safe-r)) calc(10px + var(--safe-b)) calc(10px + var(--safe-l));
    }
    .overlayBox{
      max-width: min(92vw, 720px);
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      display:none;
      white-space: pre-wrap;
      line-height:1.25;
      text-shadow: 0 2px 10px rgba(0,0,0,.65);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      font-weight: 800;
      color:#fff;
    }

    /* ====== Top bar ====== */
    .topBar{
      position:absolute;
      top:0;
      left:0;
      right:0;
      z-index:10;
      padding: calc(10px + var(--safe-t)) calc(10px + var(--safe-r)) 10px calc(10px + var(--safe-l));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .topLeft, .topRight{
      display:flex;
      align-items:center;
      gap:8px;
      pointer-events:auto;
    }
    .brandPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      font-weight: 950;
      letter-spacing:.3px;
      user-select:none;
    }
    .dot{
      width:9px; height:9px; border-radius:999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 0 4px rgba(255,255,255,.08);
    }
    .dot.ok{ background: rgba(16,185,129,.95); box-shadow: 0 0 0 4px rgba(16,185,129,.18); }
    .dot.err{ background: rgba(239,68,68,.95); box-shadow: 0 0 0 4px rgba(239,68,68,.18); }

    .iconBtn{
      width: 44px;
      height: 44px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: #fff;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
    }
    .iconBtn:active{ transform: translateY(1px); }
    .iconBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .iconBtn.on{
      border-color: rgba(16,185,129,.55);
      background: rgba(16,185,129,.16);
      color: #d6fff1;
    }

    /* ====== Bottom UI ====== */
    .bottomUI{
      position:absolute;
      left:0; right:0;
      bottom:0;
      z-index:12;
      padding: 10px calc(10px + var(--safe-r)) calc(12px + var(--safe-b)) calc(10px + var(--safe-l));
      display:grid;
      gap:10px;
      pointer-events:none;
    }

    /* Gallery strip */
    .thumbStrip{
      pointer-events:auto;
      display:flex;
      gap:10px;
      overflow-x:auto;
      padding: 8px 8px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      scrollbar-width: none;
    }
    .thumbStrip::-webkit-scrollbar{ display:none; }
    .thumb{
      width: 64px;
      height: 64px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      flex: 0 0 auto;
      position:relative;
      cursor:pointer;
      user-select:none;
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
    }
    .thumb .idx{
      position:absolute;
      left:6px; top:6px;
      font-size: 11px;
      font-weight: 950;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
    }
    .thumb.active{
      outline: 3px solid rgba(16,185,129,.55);
      outline-offset: 2px;
    }

    /* Shutter row */
    .controlsRow{
      pointer-events:auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .sideBtn{
      width: 54px; height: 54px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color:#fff;
      font-size: 18px;
      cursor:pointer;
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .sideBtn:active{ transform: translateY(1px); }
    .sideBtn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .shutter{
      width: 82px; height: 82px;
      border-radius: 999px;
      border: 6px solid rgba(255,255,255,.92);
      background: rgba(255,255,255,.12);
      cursor:pointer;
      user-select:none;
      position:relative;
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
    }
    .shutter::after{
      content:"";
      position:absolute;
      inset: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.88);
    }
    .shutter:active{ transform: scale(.985); }
    .shutter[disabled]{ opacity:.45; cursor:not-allowed; }

    .hintBar{
      pointer-events:none;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255,255,255,.78);
      text-shadow: 0 2px 10px rgba(0,0,0,.65);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .hintBar .left, .hintBar .right{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      pointer-events:auto;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 40px rgba(0,0,0,.30);
      font-weight: 850;
      color: rgba(255,255,255,.90);
      user-select:none;
    }

    /* ====== Modals ====== */
    .backdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.72);
      display:none;
      z-index:50;
      padding: 12px;
      padding-top: calc(12px + var(--safe-t));
      padding-bottom: calc(12px + var(--safe-b));
      align-items:center;
      justify-content:center;
    }
    .modal{
      width: min(880px, 100%);
      max-height: 100%;
      background: linear-gradient(180deg, rgba(15,22,32,.98), rgba(10,14,20,.98));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
    }
    .modalTitle{
      font-weight: 950;
      font-size: 14px;
      color: rgba(255,255,255,.92);
      letter-spacing:.2px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .modalBody{
      padding: 12px;
      overflow:auto;
      display:grid;
      gap: 12px;
    }
    .modalFooter{
      padding: 12px;
      border-top: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    .btn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      border-radius: 16px;
      font-size: 15px;
      font-weight: 950;
      cursor:pointer;
      min-height: 46px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(16,185,129,.95), rgba(16,185,129,.65));
      border-color: rgba(16,185,129,.45);
      color: #062b1f;
    }
    .btn.danger{
      background: rgba(239,68,68,.12);
      border-color: rgba(239,68,68,.35);
      color: #ffd7d7;
    }
    .btn.ghost{
      background: rgba(255,255,255,.03);
    }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

    .card{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .label{
      font-size: 12px;
      color: rgba(255,255,255,.78);
      font-weight: 900;
      letter-spacing:.2px;
    }
    .mini{
      font-size: 12px;
      color: rgba(255,255,255,.60);
      line-height:1.35;
    }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 820px){ .grid3{ grid-template-columns: 1fr; } }
    @media (max-width: 680px){ .grid2{ grid-template-columns: 1fr; } }

    .field{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.92);
      padding: 12px 12px;
      font-size: 15px;
      outline: none;
    }
    .field:focus{
      border-color: rgba(16,185,129,.55);
      box-shadow: 0 0 0 4px rgba(16,185,129,.16);
    }
    .switch{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      user-select:none;
      min-height: 46px;
    }
    .switch .left{
      display:flex; align-items:center; gap:10px;
    }
    .switch input{ width: 20px; height: 20px; accent-color: var(--accent); }
    .switch span{ font-size: 15px; font-weight: 900; color: rgba(255,255,255,.92); }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    /* Map */
    #mapWrap{
      display:none;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    #map{
      width: 100%;
      height: 320px;
    }

    /* Preview */
    .previewImg{
      width:100%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      display:block;
      max-height: 58vh;
      object-fit: contain;
    }
    .previewMeta{
      font-size:12px;
      color: rgba(255,255,255,.70);
      line-height:1.35;
      white-space: pre-wrap;
    }

    /* Log drawer */
    .logFab{
      position:fixed;
      right: calc(12px + var(--safe-r));
      bottom: calc(120px + var(--safe-b));
      z-index: 30;
      display:none;
    }
    .logDrawer{
      position:fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + var(--safe-b));
      z-index: 40;
      background: rgba(10,14,20,.98);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
      max-height: min(55vh, 520px);
    }
    .logHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      background: rgba(16,185,129,.10);
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .logHeader .title{
      font-weight: 950;
      font-size: 13px;
      color: rgba(214,255,241,.95);
    }
    pre#logPre{
      margin:0;
      padding: 10px 12px;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255,255,255,.88);
      white-space: pre-wrap;
      word-break: break-word;
      overflow:auto;
      max-height: 46vh;
    }

    /* Toast */
    .toast{
      position:fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(18px + var(--safe-b));
      z-index: 60;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,.62);
      border: 1px solid rgba(255,255,255,.12);
      color:#fff;
      font-size: 12px;
      font-weight: 900;
      display:none;
      box-shadow: 0 20px 50px rgba(0,0,0,.55);
      max-width: min(92vw, 720px);
      text-align:center;
      backdrop-filter: blur(8px);
    }

    /* Busy overlay */
    .busy{
      position:fixed;
      inset:0;
      z-index: 70;
      background: rgba(0,0,0,.72);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 14px;
      text-align:center;
    }
    .busyCard{
      width:min(520px, 100%);
      background: rgba(15,22,32,.98);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 14px;
      display:grid;
      gap: 10px;
    }
    .busyTitle{
      font-weight: 950;
      font-size: 14px;
    }
    .bar{
      width:100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height:100%;
      width: 0%;
      background: rgba(16,185,129,.92);
      transition: width .15s linear;
    }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <div class="videoWrap">
      <video id="camVideo" playsinline autoplay muted></video>
    </div>

    <!-- Live overlay preview (‡πÅ‡∏Ñ‡πà‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏Ñ‡∏£‡πà‡∏≤‡∏ß ‡πÜ) -->
    <div class="liveOverlay" id="liveOverlay">
      <div class="overlayBox" id="liveOverlayBox"></div>
    </div>

    <div class="topBar">
      <div class="topLeft">
        <div class="brandPill">
          <span class="dot" id="dotCam"></span>
          <span>PT Timestamp</span>
        </div>
        <span class="pill" id="pillLoc" style="display:none;">üìç Location ON</span>
      </div>
      <div class="topRight">
        <button class="iconBtn" id="btnTorch" title="Torch/Flash" aria-label="Torch" disabled>üî¶</button>
        <button class="iconBtn" id="btnSwitchCam" title="Switch camera" aria-label="Switch camera">üîÑ</button>
        <button class="iconBtn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottomUI">
      <div class="thumbStrip" id="thumbStrip" aria-label="Gallery thumbnails"></div>

      <div class="controlsRow">
        <button class="sideBtn" id="btnImport" title="Import from gallery" aria-label="Import">üñºÔ∏è</button>
        <button class="shutter" id="btnShutter" title="Shutter" aria-label="Shutter"></button>
        <button class="sideBtn" id="btnDownloadAll" title="Download All" aria-label="Download All" disabled>‚¨áÔ∏è‚¨áÔ∏è</button>
      </div>

      <div class="hintBar">
        <div class="left">
          <span class="pill" id="pillMode">üì∑ Camera</span>
          <span class="pill" id="pillCount">0 ‡∏£‡∏π‡∏õ</span>
        </div>
        <div class="right">
          <span class="pill" id="pillOut">Preset</span>
          <span class="pill" id="pillFmt">JPG</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file input (multiple) -->
  <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />

  <!-- Preview Modal -->
  <div class="backdrop" id="previewBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">üñºÔ∏è Preview / Download</div>
        <button class="btn danger" id="btnClosePreview" style="min-height:42px; padding:10px 12px;">‡∏õ‡∏¥‡∏î</button>
      </div>
      <div class="modalBody">
        <img id="previewImg" class="previewImg" alt="preview" />
        <div class="previewMeta" id="previewMeta">-</div>

        <div class="card">
          <div class="label">Download options (‡∏ï‡πà‡∏≠‡∏£‡∏π‡∏õ)</div>
          <div class="grid2">
            <div>
              <div class="label">‡∏ä‡∏ô‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå</div>
              <select id="dlFormat" class="field">
                <option value="image/jpeg">JPG</option>
                <option value="image/png">PNG</option>
              </select>
              <div class="mini">Export ‡∏ú‡πà‡∏≤‡∏ô canvas ‚Üí ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ ‚Äú‡πÑ‡∏°‡πà‡∏°‡∏µ EXIF/metadata ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‚Äù</div>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="dlQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
              <div class="mini">‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å JPG ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô</div>
            </div>
          </div>

          <div class="row" style="justify-content:space-between">
            <button class="btn danger" id="btnDeletePhoto" style="flex:1">‡∏•‡∏ö‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ</button>
            <button class="btn primary" id="btnDownloadPhoto" style="flex:1">‚¨áÔ∏è Download</button>
          </div>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn ghost" id="btnReRender">üîÑ Re-render preview</button>
        <button class="btn" id="btnPrevPhoto">‚¨ÖÔ∏è ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>
        <button class="btn" id="btnNextPhoto">‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚û°Ô∏è</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="backdrop" id="settingsBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHeader">
        <div class="modalTitle">‚öôÔ∏è Settings</div>
        <button class="btn danger" id="btnCloseSettings" style="min-height:42px; padding:10px 12px;">‡∏õ‡∏¥‡∏î</button>
      </div>

      <div class="modalBody">
        <div class="card">
          <div class="label">1) ‡πÄ‡∏ß‡∏•‡∏≤ (Timestamp)</div>
          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="useNow" type="checkbox" checked />
                <span>‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô</span>
              </div>
              <span class="mini" id="timeMini">-</span>
            </label>
            <div>
              <div class="label">‡πÅ‡∏Å‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏≠‡∏á (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏¥‡πä‡∏Å‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)</div>
              <input id="customTime" class="field" type="datetime-local" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ß‡∏•‡∏≤</div>
              <select id="timeFormat" class="field">
                <option value="thai_verbose" selected>Thai verbose (‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°)</option>
                <option value="ddmmyyyy_hms">DD/MM/YYYY HH:mm:ss</option>
                <option value="yyyymmdd_hms">YYYY-MM-DD HH:mm:ss</option>
                <option value="iso">ISO 8601</option>
              </select>
              <div class="mini">Overlay ‡∏à‡∏∞ render ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà Download/Preview</div>
            </div>
            <div>
              <div class="label">‡πÄ‡∏™‡πâ‡∏ô‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤</div>
              <select id="timeLines" class="field">
                <option value="two" selected>2 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î (Network + Local)</option>
                <option value="one">1 ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î</option>
              </select>
              <div class="mini">‡∏Ñ‡∏á‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ + ‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ</div>
            </div>
          </div>

          <div class="row">
            <button class="btn" id="btnSetNow" style="flex:1">‚è± ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô</button>
          </div>
        </div>

        <div class="card">
          <div class="label">2) Output size (Preset/Original) + Fit</div>
          <div class="grid3">
            <div>
              <div class="label">‡πÇ‡∏´‡∏°‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å</div>
              <select id="outputMode" class="field">
                <option value="preset" selected>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î (Preset)</option>
                <option value="original">‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏¥‡∏° (‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á)</option>
              </select>
              <div class="mini">Preset = ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏≠‡∏á ‚Ä¢ Original = ‡∏ï‡∏≤‡∏°‡∏£‡∏π‡∏õ‡∏à‡∏£‡∏¥‡∏á</div>
            </div>

            <div>
              <div class="label">Preset Size</div>
              <select id="outputSize" class="field">
                <option value="1920x1440" selected>1920 √ó 1440</option>
                <option value="2340x1080">2340 √ó 1080</option>
                <option value="2160x1080">2160 √ó 1080</option>
                <option value="1920x1080">1920 √ó 1080</option>
                <option value="1600x1200">1600 √ó 1200</option>
                <option value="1440x1080">1440 √ó 1080</option>
                <option value="1280x960">1280 √ó 960</option>
                <option value="1560x720">1560 √ó 720</option>
                <option value="1440x720">1440 √ó 720</option>
                <option value="1280x720">1280 √ó 720</option>
                <option value="800x600">800 √ó 600</option>
                <option value="720x480">720 √ó 480</option>
                <option value="640x480">640 √ó 480</option>
                <option value="640x360">640 √ó 360</option>
                <option value="352x288">352 √ó 288</option>
                <option value="320x240">320 √ó 240</option>
                <option value="176x144">176 √ó 144</option>
              </select>
              <div class="mini">‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Original ‡∏à‡∏∞‡∏õ‡∏¥‡∏î preset</div>
            </div>

            <div>
              <div class="label">Fit Mode</div>
              <select id="fitMode" class="field">
                <option value="contain" selected>Contain (‡∏°‡∏µ‡∏Ç‡∏≠‡∏ö‡∏î‡∏≥‡∏ñ‡πâ‡∏≤‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á)</option>
                <option value="cover">Cover (‡πÄ‡∏ï‡πá‡∏°‡πÄ‡∏ü‡∏£‡∏° + ‡∏Ñ‡∏£‡∏≠‡∏õ)</option>
              </select>
              <div class="mini">‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÅ‡∏ö‡∏ö ‚Äú‡πÑ‡∏°‡πà‡∏¢‡∏∑‡∏î‡∏†‡∏≤‡∏û‚Äù</div>
            </div>
          </div>
          <div class="mini" id="outStatus">-</div>
        </div>

        <div class="card">
          <div class="label">3) Overlay style (‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)</div>

          <div class="grid3">
            <div>
              <div class="label">‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á Overlay</div>
              <select id="overlayPos" class="field">
                <option value="tl">‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô</option>
                <option value="tr" selected>‡∏Ç‡∏ß‡∏≤‡∏ö‡∏ô</option>
                <option value="bl">‡∏ã‡πâ‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏á</option>
                <option value="br">‡∏Ç‡∏ß‡∏≤‡∏•‡πà‡∏≤‡∏á</option>
              </select>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayBoxEnable" type="checkbox" checked />
                  <span>‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÇ‡∏õ‡∏£‡πà‡∏á‡∏î‡∏≥</span>
                </div>
                <span class="mini">‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢</span>
              </label>
            </div>

            <div>
              <label class="switch">
                <div class="left">
                  <input id="overlayStrokeEnable" type="checkbox" checked />
                  <span>Stroke/Shadow</span>
                </div>
                <span class="mini">‡∏Å‡∏±‡∏ô‡∏à‡∏°‡∏´‡∏≤‡∏¢</span>
              </label>
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="label">‡∏ü‡∏≠‡∏ô‡∏ï‡πå</div>
              <label class="switch" style="margin-bottom:10px">
                <div class="left">
                  <input id="fontAuto" type="checkbox" checked />
                  <span>Auto (‡∏™‡πÄ‡∏Å‡∏•‡∏ï‡∏≤‡∏° Output)</span>
                </div>
                <span class="mini">‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢ preset</span>
              </label>

              <div class="grid2">
                <div>
                  <div class="label">Auto scale (%)</div>
                  <input id="fontScale" class="field" type="number" min="50" max="250" step="5" value="100">
                </div>
                <div>
                  <div class="label">Fixed px (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î Auto)</div>
                  <input id="fontPx" class="field" type="number" min="10" max="200" step="1" value="32" disabled>
                </div>
              </div>
              <div class="mini">Auto ‡∏à‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å output ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏π‡∏ì‡∏î‡πâ‡∏ß‡∏¢ %</div>
            </div>

            <div>
              <div class="label">‡∏£‡∏∞‡∏¢‡∏∞‡∏Ç‡∏≠‡∏ö/‡∏™‡πÄ‡∏Å‡∏•‡∏Å‡∏•‡πà‡∏≠‡∏á</div>
              <div class="grid2">
                <div>
                  <div class="label">Margin scale (%)</div>
                  <input id="overlayMarginScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
                <div>
                  <div class="label">Padding scale (%)</div>
                  <input id="overlayPadScale" class="field" type="number" min="50" max="200" step="5" value="100">
                </div>
              </div>
              <div class="mini">‡∏ä‡πà‡∏ß‡∏¢‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á/‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="liveOverlayEnable" type="checkbox" checked />
                <span>‡πÅ‡∏™‡∏î‡∏á overlay ‡∏ö‡∏ô‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡∏Å‡∏•‡πâ‡∏≠‡∏á</span>
              </div>
              <span class="mini">Preview-only</span>
            </label>
            <div class="mini">
              * ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: preview overlay ‡πÄ‡∏õ‡πá‡∏ô ‚Äú‡πÑ‡∏Å‡∏î‡πå‚Äù ‡πÅ‡∏ï‡πà‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏∞ render ‡∏ú‡πà‡∏≤‡∏ô canvas ‡∏ï‡∏≠‡∏ô Download/Preview ‡∏≠‡∏µ‡∏Å‡∏ó‡∏µ
            </div>
          </div>
        </div>

        <div class="card">
          <div class="label">4) Location (Lat/Lng + Address via Nominatim)</div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="enableLocation" type="checkbox" />
                <span>‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á (Overlay)</span>
              </div>
              <span class="mini" id="locMini">‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</span>
            </label>

            <div class="grid2">
              <label class="switch">
                <div class="left">
                  <input id="showLatLng" type="checkbox" checked />
                  <span>‡πÅ‡∏™‡∏î‡∏á Lat/Lng</span>
                </div>
              </label>
              <label class="switch">
                <div class="left">
                  <input id="showAddress" type="checkbox" checked />
                  <span>‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà</span>
                </div>
              </label>
            </div>
          </div>

          <div class="grid2">
            <button class="btn" id="btnUseGPS">üìç ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (GPS)</button>
            <button class="btn" id="btnPickOnMap">üó∫Ô∏è ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</button>
          </div>

          <div class="grid2">
            <div>
              <div class="label">Lat</div>
              <input id="lat" class="field" type="number" step="any" placeholder="‡πÄ‡∏ä‡πà‡∏ô 13.7563" />
            </div>
            <div>
              <div class="label">Lng</div>
              <input id="lng" class="field" type="number" step="any" placeholder="‡πÄ‡∏ä‡πà‡∏ô 100.5018" />
            </div>
          </div>

          <div>
            <div class="label">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà (Forward geocode)</div>
            <div class="row">
              <input id="placeQuery" class="field" placeholder="‡πÄ‡∏ä‡πà‡∏ô CentralWorld Bangkok" style="flex:1" />
              <button class="btn" id="btnSearchPlace">üîé ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
            </div>
          </div>

          <div id="mapWrap">
            <div id="map"></div>
            <div class="row" style="padding:10px">
              <button class="btn primary" id="btnConfirmMap" style="flex:1">‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ô‡∏µ‡πâ</button>
              <button class="btn danger" id="btnCloseMap" style="flex:1">‚úñ ‡∏õ‡∏¥‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</button>
            </div>
          </div>

          <div class="mini" id="locStatus">-</div>
        </div>

        <div class="card">
          <div class="label">5) Download (Default)</div>
          <div class="grid3">
            <div>
              <div class="label">‡∏ä‡∏ô‡∏¥‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</div>
              <select id="defaultFormat" class="field">
                <option value="image/jpeg" selected>JPG</option>
                <option value="image/png">PNG</option>
              </select>
            </div>
            <div>
              <div class="label">JPG Quality</div>
              <input id="jpgQuality" class="field" type="number" min="0.5" max="1" step="0.01" value="0.95" />
            </div>
            <div>
              <div class="label">‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå</div>
              <select id="namePattern" class="field">
                <option value="pt_now_index" selected>PT_YYYYMMDD_HHMMSS_&lt;index&gt;</option>
                <option value="pt_capture_index">PT_(captureTime)_&lt;index&gt;</option>
              </select>
              <div class="mini">Download All ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏ä‡∏∏‡∏î</div>
            </div>
          </div>

          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="preferFolderSave" type="checkbox" checked />
                <span>Download All ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà zip (‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå)</span>
              </div>
              <span class="mini">Chrome ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥</span>
            </label>
            <label class="switch">
              <div class="left">
                <input id="zipFallback" type="checkbox" checked />
                <span>Fallback ‡πÄ‡∏õ‡πá‡∏ô ZIP ‡∏ñ‡πâ‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</span>
              </div>
              <span class="mini">‡πÉ‡∏ä‡πâ JSZip</span>
            </label>
          </div>

          <div class="mini">
            ‚Ä¢ ‚Äú‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‚Äù ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ File System Access API (Chrome/Android ‡∏°‡∏±‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)<br>
            ‚Ä¢ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö ‚Üí ZIP (‡∏ñ‡πâ‡∏≤‡πÇ‡∏´‡∏•‡∏î JSZip ‡πÑ‡∏î‡πâ) ‚Üí ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏à‡∏∞ fallback ‡πÄ‡∏õ‡πá‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏µ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå
          </div>
        </div>

        <div class="card">
          <div class="label">6) Log panel (‡∏ä‡πà‡∏ß‡∏¢‡∏î‡∏π‡πÅ‡∏ó‡∏ô Console ‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)</div>
          <div class="grid2">
            <label class="switch">
              <div class="left">
                <input id="enableLogPanel" type="checkbox" />
                <span>‡πÄ‡∏õ‡∏¥‡∏î Log</span>
              </div>
              <span class="mini">‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏° üêû ‡πÇ‡∏ú‡∏•‡πà‡∏ö‡∏ô‡∏à‡∏≠</span>
            </label>
            <button class="btn danger" id="btnClearLog">‡∏•‡πâ‡∏≤‡∏á Log</button>
          </div>
          <div class="mini">‡∏ñ‡πâ‡∏≤‡∏Å‡∏•‡πâ‡∏≠‡∏á/‡πÑ‡∏ü‡∏•‡πå/‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ ‡πÄ‡∏õ‡∏¥‡∏î Log ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏≤‡πÑ‡∏î‡πâ</div>
        </div>
      </div>

      <div class="modalFooter">
        <button class="btn" id="btnResetSettings">‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡πà‡∏≤</button>
        <button class="btn primary" id="btnApplySettings">Apply/Save</button>
      </div>
    </div>
  </div>

  <!-- Log UI -->
  <div class="logFab" id="logFab">
    <button class="iconBtn" id="btnToggleLog" title="Log" aria-label="Log">üêû</button>
  </div>

  <div class="logDrawer" id="logDrawer" aria-hidden="true">
    <div class="logHeader">
      <div class="title">Runtime Log (‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î)</div>
      <div class="row">
        <button class="btn danger" id="btnCloseLog" style="min-height:38px; padding:8px 10px;">‡∏õ‡∏¥‡∏î</button>
      </div>
    </div>
    <pre id="logPre"></pre>
  </div>

  <div class="toast" id="toast"></div>

  <div class="busy" id="busy">
    <div class="busyCard">
      <div class="busyTitle" id="busyTitle">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...</div>
      <div class="mini" id="busyText">-</div>
      <div class="bar"><div id="busyBar"></div></div>
      <div class="row">
        <button class="btn danger" id="btnBusyClose" style="flex:1">‡∏õ‡∏¥‡∏î</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* =========================
     Storage (‡∏Ñ‡∏á key ‡πÄ‡∏î‡∏¥‡∏°)
  ========================== */
  const SETTINGS_KEY = "PT_TS_SETTINGS_V2_4";

  const DEFAULT_SETTINGS = {
    // ‡πÄ‡∏î‡∏¥‡∏°
    useNow: true,
    customTime: "",
    outputMode: "preset",
    outputSize: "1920x1440",
    fitMode: "contain",
    fontAuto: true,
    fontScale: 100,
    fontPx: 32,
    enableLocation: false,
    showLatLng: true,
    showAddress: true,
    lat: "",
    lng: "",
    placeQuery: "",
    enableLogPanel: false,

    // ‡πÉ‡∏´‡∏°‡πà
    timeFormat: "thai_verbose",
    timeLines: "two", // one | two
    overlayPos: "tr", // tl tr bl br
    overlayBoxEnable: true,
    overlayStrokeEnable: true,
    overlayMarginScale: 100,
    overlayPadScale: 100,
    liveOverlayEnable: true,

    defaultFormat: "image/jpeg",
    jpgQuality: 0.95,
    namePattern: "pt_now_index", // pt_now_index | pt_capture_index

    preferFolderSave: true,
    zipFallback: true,

    // camera prefs
    preferredFacing: "environment",
    preferredDeviceId: "",
    torchOn: false
  };

  /* =========================
     Elements
  ========================== */
  const camVideo = document.getElementById("camVideo");
  const dotCam = document.getElementById("dotCam");
  const pillLoc = document.getElementById("pillLoc");

  const btnTorch = document.getElementById("btnTorch");
  const btnSwitchCam = document.getElementById("btnSwitchCam");
  const btnSettings = document.getElementById("btnSettings");

  const thumbStrip = document.getElementById("thumbStrip");
  const btnImport = document.getElementById("btnImport");
  const btnShutter = document.getElementById("btnShutter");
  const btnDownloadAll = document.getElementById("btnDownloadAll");

  const pillMode = document.getElementById("pillMode");
  const pillCount = document.getElementById("pillCount");
  const pillOut = document.getElementById("pillOut");
  const pillFmt = document.getElementById("pillFmt");

  const fileInput = document.getElementById("fileInput");

  const liveOverlayBox = document.getElementById("liveOverlayBox");

  // Preview modal
  const previewBackdrop = document.getElementById("previewBackdrop");
  const btnClosePreview = document.getElementById("btnClosePreview");
  const previewImg = document.getElementById("previewImg");
  const previewMeta = document.getElementById("previewMeta");
  const dlFormat = document.getElementById("dlFormat");
  const dlQuality = document.getElementById("dlQuality");
  const btnDownloadPhoto = document.getElementById("btnDownloadPhoto");
  const btnDeletePhoto = document.getElementById("btnDeletePhoto");
  const btnPrevPhoto = document.getElementById("btnPrevPhoto");
  const btnNextPhoto = document.getElementById("btnNextPhoto");
  const btnReRender = document.getElementById("btnReRender");

  // Settings modal inputs
  const settingsBackdrop = document.getElementById("settingsBackdrop");
  const btnCloseSettings = document.getElementById("btnCloseSettings");
  const btnApplySettings = document.getElementById("btnApplySettings");
  const btnResetSettings = document.getElementById("btnResetSettings");

  const useNow = document.getElementById("useNow");
  const customTime = document.getElementById("customTime");
  const timeFormat = document.getElementById("timeFormat");
  const timeLines = document.getElementById("timeLines");
  const btnSetNow = document.getElementById("btnSetNow");
  const timeMini = document.getElementById("timeMini");

  const outputMode = document.getElementById("outputMode");
  const outputSize = document.getElementById("outputSize");
  const fitMode = document.getElementById("fitMode");
  const outStatus = document.getElementById("outStatus");

  const overlayPos = document.getElementById("overlayPos");
  const overlayBoxEnable = document.getElementById("overlayBoxEnable");
  const overlayStrokeEnable = document.getElementById("overlayStrokeEnable");
  const overlayMarginScale = document.getElementById("overlayMarginScale");
  const overlayPadScale = document.getElementById("overlayPadScale");
  const liveOverlayEnable = document.getElementById("liveOverlayEnable");

  const fontAuto = document.getElementById("fontAuto");
  const fontScale = document.getElementById("fontScale");
  const fontPx = document.getElementById("fontPx");

  const enableLocation = document.getElementById("enableLocation");
  const showLatLng = document.getElementById("showLatLng");
  const showAddress = document.getElementById("showAddress");
  const btnUseGPS = document.getElementById("btnUseGPS");
  const btnPickOnMap = document.getElementById("btnPickOnMap");
  const btnConfirmMap = document.getElementById("btnConfirmMap");
  const btnCloseMap = document.getElementById("btnCloseMap");
  const mapWrap = document.getElementById("mapWrap");
  const locStatus = document.getElementById("locStatus");
  const locMini = document.getElementById("locMini");

  const latEl = document.getElementById("lat");
  const lngEl = document.getElementById("lng");
  const placeQuery = document.getElementById("placeQuery");
  const btnSearchPlace = document.getElementById("btnSearchPlace");

  const defaultFormat = document.getElementById("defaultFormat");
  const jpgQuality = document.getElementById("jpgQuality");
  const namePattern = document.getElementById("namePattern");
  const preferFolderSave = document.getElementById("preferFolderSave");
  const zipFallback = document.getElementById("zipFallback");

  const enableLogPanel = document.getElementById("enableLogPanel");
  const btnClearLog = document.getElementById("btnClearLog");

  const logFab = document.getElementById("logFab");
  const btnToggleLog = document.getElementById("btnToggleLog");
  const logDrawer = document.getElementById("logDrawer");
  const btnCloseLog = document.getElementById("btnCloseLog");
  const logPre = document.getElementById("logPre");

  const toast = document.getElementById("toast");
  const busy = document.getElementById("busy");
  const busyTitle = document.getElementById("busyTitle");
  const busyText = document.getElementById("busyText");
  const busyBar = document.getElementById("busyBar");
  const btnBusyClose = document.getElementById("btnBusyClose");

  /* =========================
     Utils + Log
  ========================== */
  const pad2 = (n) => String(n).padStart(2, "0");
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

  const logs = [];
  function ts() {
    const d = new Date();
    return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
  }
  function addLog(line) {
    const msg = `[${ts()}] ${line}`;
    logs.push(msg);
    if (logs.length > 300) logs.shift();
    if (enableLogPanel.checked) logPre.textContent = logs.join("\n");
  }
  window.addEventListener("error", (e) => addLog(`‚ùå error: ${e.message || "unknown"} @ ${e.filename || ""}:${e.lineno || ""}`));
  window.addEventListener("unhandledrejection", (e) => addLog(`‚ùå promise: ${String(e.reason || "unknown")}`));

  let toastTimer = null;
  function showToast(msg, ms=1600){
    toast.textContent = msg;
    toast.style.display = "block";
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { toast.style.display = "none"; }, ms);
  }

  function setBusy(on, title="‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô...", text="-", pct=null){
    busy.style.display = on ? "flex" : "none";
    busyTitle.textContent = title;
    busyText.textContent = text;
    if (pct === null) busyBar.style.width = "0%";
    else busyBar.style.width = `${clamp(pct,0,100)}%`;
  }

  /* =========================
     Settings
  ========================== */
  let settings = readSettings();

  function readSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      if (!raw) return { ...DEFAULT_SETTINGS };
      const obj = JSON.parse(raw);
      return { ...DEFAULT_SETTINGS, ...(obj || {}) };
    } catch (e){
      addLog(`readSettings failed: ${String(e.message || e)}`);
      return { ...DEFAULT_SETTINGS };
    }
  }

  function writeSettings(next){
    settings = { ...settings, ...(next || {}) };
    try{
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      addLog("üíæ saved settings");
    } catch (e){
      addLog(`saveSettings failed: ${String(e.message || e)}`);
    }
    applySettingsToUI();
  }

  let saveTimer = null;
  function scheduleSave(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      try{
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectSettingsFromUI()));
        settings = readSettings();
        addLog("üíæ saved settings (debounced)");
        applySettingsToUI();
      } catch (e){
        addLog(`scheduleSave failed: ${String(e.message || e)}`);
      }
    }, 220);
  }

  function applySettingsToInputs(){
    useNow.checked = !!settings.useNow;
    customTime.value = settings.customTime || "";
    timeFormat.value = settings.timeFormat || "thai_verbose";
    timeLines.value = settings.timeLines || "two";

    outputMode.value = settings.outputMode || "preset";
    outputSize.value = settings.outputSize || "1920x1440";
    fitMode.value = settings.fitMode || "contain";

    overlayPos.value = settings.overlayPos || "tr";
    overlayBoxEnable.checked = !!settings.overlayBoxEnable;
    overlayStrokeEnable.checked = !!settings.overlayStrokeEnable;
    overlayMarginScale.value = String(settings.overlayMarginScale ?? 100);
    overlayPadScale.value = String(settings.overlayPadScale ?? 100);
    liveOverlayEnable.checked = (settings.liveOverlayEnable ?? true);

    fontAuto.checked = !!settings.fontAuto;
    fontScale.value = String(settings.fontScale ?? 100);
    fontPx.value = String(settings.fontPx ?? 32);

    enableLocation.checked = !!settings.enableLocation;
    showLatLng.checked = (settings.showLatLng ?? true);
    showAddress.checked = (settings.showAddress ?? true);
    latEl.value = settings.lat ?? "";
    lngEl.value = settings.lng ?? "";
    placeQuery.value = settings.placeQuery ?? "";

    defaultFormat.value = settings.defaultFormat || "image/jpeg";
    jpgQuality.value = String(settings.jpgQuality ?? 0.95);
    namePattern.value = settings.namePattern || "pt_now_index";
    preferFolderSave.checked = (settings.preferFolderSave ?? true);
    zipFallback.checked = (settings.zipFallback ?? true);

    enableLogPanel.checked = !!settings.enableLogPanel;
    logFab.style.display = enableLogPanel.checked ? "block" : "none";
    if (enableLogPanel.checked) logPre.textContent = logs.join("\n");

    // Preview modal defaults should follow settings
    dlFormat.value = settings.defaultFormat || "image/jpeg";
    dlQuality.value = String(settings.jpgQuality ?? 0.95);

    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    updatePills();
    updateLiveOverlay();
  }

  function collectSettingsFromUI(){
    return {
      useNow: useNow.checked,
      customTime: customTime.value || "",
      timeFormat: timeFormat.value,
      timeLines: timeLines.value,

      outputMode: outputMode.value,
      outputSize: outputSize.value,
      fitMode: fitMode.value,

      overlayPos: overlayPos.value,
      overlayBoxEnable: overlayBoxEnable.checked,
      overlayStrokeEnable: overlayStrokeEnable.checked,
      overlayMarginScale: Number(overlayMarginScale.value) || 100,
      overlayPadScale: Number(overlayPadScale.value) || 100,
      liveOverlayEnable: liveOverlayEnable.checked,

      fontAuto: fontAuto.checked,
      fontScale: Number(fontScale.value) || 100,
      fontPx: Number(fontPx.value) || 32,

      enableLocation: enableLocation.checked,
      showLatLng: showLatLng.checked,
      showAddress: showAddress.checked,
      lat: latEl.value || "",
      lng: lngEl.value || "",
      placeQuery: placeQuery.value || "",

      defaultFormat: defaultFormat.value,
      jpgQuality: clamp(Number(jpgQuality.value) || 0.95, 0.5, 1),
      namePattern: namePattern.value,
      preferFolderSave: preferFolderSave.checked,
      zipFallback: zipFallback.checked,

      enableLogPanel: enableLogPanel.checked,

      // keep camera prefs
      preferredFacing: settings.preferredFacing || "environment",
      preferredDeviceId: settings.preferredDeviceId || "",
      torchOn: settings.torchOn || false
    };
  }

  function applySettingsToUI(){
    applySettingsToInputs();
  }

  /* =========================
     Time formatting
  ========================== */
  function getSelectedDate(){
    if (useNow.checked) return new Date();
    const v = customTime.value;
    if (!v) return null;
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return null;
    return d;
  }

  function formatThaiVerbose(date){
    const d = date.getDate();
    const m = date.toLocaleString("th-TH", { month: "short" });
    const y = date.getFullYear();
    const hh = date.getHours();
    const mm = date.getMinutes();
    const ss = date.getSeconds();
    const tz = "GMT+07:00";
    return `${d} ${m}. ${y} ${hh} ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ ${mm} ‡∏ô‡∏≤‡∏ó‡∏µ ${ss} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ${tz}`;
  }

  function formatDDMMYYYY(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${dd}/${MM}/${yyyy} ${HH}:${mm}:${ss}`;
  }

  function formatYYYYMMDD(date){
    const dd = pad2(date.getDate());
    const MM = pad2(date.getMonth()+1);
    const yyyy = date.getFullYear();
    const HH = pad2(date.getHours());
    const mm = pad2(date.getMinutes());
    const ss = pad2(date.getSeconds());
    return `${yyyy}-${MM}-${dd} ${HH}:${mm}:${ss}`;
  }

  function formatTimestamp(date){
    switch (timeFormat.value){
      case "ddmmyyyy_hms": return formatDDMMYYYY(date);
      case "yyyymmdd_hms": return formatYYYYMMDD(date);
      case "iso": return date.toISOString();
      case "thai_verbose":
      default: return formatThaiVerbose(date);
    }
  }

  function buildTimeLines(date){
    const t = formatTimestamp(date);
    if ((timeLines.value || "two") === "one"){
      return [`Timestamp: ${t}`];
    }
    // ‡∏Ñ‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏° (Network + Local)
    return [
      `Network: ${t}`,
      `Local: ${t}`
    ];
  }

  function updateTimeMini(){
    const d = getSelectedDate();
    if (!d){
      timeMini.textContent = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤";
      return;
    }
    timeMini.textContent = formatTimestamp(d);
  }

  /* =========================
     Output + Font
  ========================== */
  function parseOutputSize(){
    const v = (outputSize.value || "1920x1440").toLowerCase().trim();
    const m = v.match(/^(\d+)\s*x\s*(\d+)$/);
    if (!m) return { w: 1920, h: 1440 };
    const w = Number(m[1]);
    const h = Number(m[2]);
    if (!Number.isFinite(w) || !Number.isFinite(h) || w < 1 || h < 1) return { w: 1920, h: 1440 };
    return { w, h };
  }

  function updateOutputUI(){
    const mode = outputMode.value;
    outputSize.disabled = (mode !== "preset");
    fitMode.disabled = (mode !== "preset");
    if (mode === "original"){
      outStatus.textContent = "Output = ‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡πÄ‡∏î‡∏¥‡∏° (‡∏ï‡∏≤‡∏°‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á)";
    } else {
      const { w, h } = parseOutputSize();
      outStatus.textContent = `Output = ${w}√ó${h} ‚Ä¢ Fit = ${fitMode.value === "contain" ? "Contain (‡∏Ç‡∏≠‡∏ö‡∏î‡∏≥)" : "Cover (‡∏Ñ‡∏£‡∏≠‡∏õ‡πÄ‡∏ï‡πá‡∏°‡πÄ‡∏ü‡∏£‡∏°)"}`;
    }
    updatePills();
  }

  function updateFontUI(){
    const auto = fontAuto.checked;
    fontScale.disabled = !auto;
    fontPx.disabled = auto;
  }

  function computeFontSizePx(outW, outH){
    if (!fontAuto.checked){
      const px = Number(fontPx.value);
      return clamp(Number.isFinite(px) ? px : 32, 10, 200);
    }
    const base = Math.min(outW, outH);
    const autoPx = clamp(Math.round(base * 0.022), 12, 220);
    const scalePct = clamp(Number(fontScale.value) || 100, 50, 250);
    return clamp(Math.round(autoPx * (scalePct / 100)), 10, 240);
  }

  function updatePills(){
    pillOut.textContent = (outputMode.value === "original") ? "Original" : `Preset ${outputSize.value}`;
    pillFmt.textContent = (defaultFormat.value === "image/png") ? "PNG" : "JPG";
  }

  /* =========================
     Location + Geocode
  ========================== */
  const toNumberOrNull = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  function hasValidLatLng(){
    const lat = toNumberOrNull(latEl.value);
    const lng = toNumberOrNull(lngEl.value);
    if (lat === null || lng === null) return false;
    return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
  }

  let addressText = "";
  let addressCacheKey = "";
  let lastGeoFetchAt = 0;

  async function reverseGeocode(lat, lng){
    // Nominatim policy: ‡∏≠‡∏¢‡πà‡∏≤‡∏¢‡∏¥‡∏á‡∏ñ‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=18&addressdetails=1`;
    const res = await fetch(url, {
      headers: {
        "Accept":"application/json",
        "Accept-Language":"th-TH,th;q=0.9,en;q=0.7"
      }
    });
    if (!res.ok) throw new Error("Reverse geocode failed");
    const data = await res.json();
    return data?.display_name || "";
  }

  async function forwardGeocode(q){
    const now = Date.now();
    if (now - lastGeoFetchAt < 1100){
      await new Promise(r => setTimeout(r, 1100 - (now - lastGeoFetchAt)));
    }
    lastGeoFetchAt = Date.now();

    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&limit=1`;
    const res = await fetch(url, {
      headers: {
        "Accept":"application/json",
        "Accept-Language":"th-TH,th;q=0.9,en;q=0.7"
      }
    });
    if (!res.ok) throw new Error("Search place failed");
    const data = await res.json();
    if (!Array.isArray(data) || data.length === 0) return null;
    return { lat: Number(data[0].lat), lng: Number(data[0].lon), display_name: data[0].display_name || "" };
  }

  async function refreshAddressIfNeeded(){
    addressText = "";
    addressCacheKey = "";

    if (!enableLocation.checked){
      locStatus.textContent = "‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }
    if (!hasValidLatLng()){
      locStatus.textContent = "‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Lat/Lng ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      refreshLocMini();
      updateLiveOverlay();
      return;
    }

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|${showAddress.checked ? "addr" : "noaddr"}`;
    addressCacheKey = key;

    let msg = `Lat/Lng: ${lat.toFixed(6)}, ${lng.toFixed(6)}\n`;

    if (showAddress.checked){
      locStatus.textContent = msg + "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏≤‡∏Å Nominatim...";
      try{
        addressText = await reverseGeocode(lat, lng);
        msg += `Address: ${addressText || "(‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)"}`;
      } catch (e){
        msg += "Address: (‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‚Äî ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https)";
        addLog(`reverseGeocode failed: ${String(e.message || e)}`);
      }
    } else {
      msg += "Address: (‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)";
    }

    locStatus.textContent = msg;
    refreshLocMini();
    updateLiveOverlay();
  }

  function refreshLocMini(){
    if (!enableLocation.checked){
      locMini.textContent = "‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô";
      pillLoc.style.display = "none";
      return;
    }
    pillLoc.style.display = "inline-flex";
    if (hasValidLatLng()){
      locMini.textContent = `ON ‚Ä¢ ${Number(latEl.value).toFixed(4)}, ${Number(lngEl.value).toFixed(4)}`;
    } else {
      locMini.textContent = "ON ‚Ä¢ ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î";
    }
  }

  /* =========================
     Overlay lines + Drawing
  ========================== */
  function buildOverlayLines(date){
    const lines = [];
    lines.push(...buildTimeLines(date));

    if (enableLocation.checked && hasValidLatLng()){
      const lat = Number(latEl.value);
      const lng = Number(lngEl.value);
      if (showLatLng.checked){
        lines.push(`üìç ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
      }
      if (showAddress.checked){
        lines.push(addressText ? addressText : "(‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°)");
      }
    }
    return lines;
  }

  function getOverlayAnchor(outW, outH){
    const pos = overlayPos.value || "tr";
    const marginBase = Math.min(outW, outH) * 0.018;
    const margin = Math.round(marginBase * (clamp(Number(overlayMarginScale.value) || 100, 50, 200) / 100));
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");
    return { margin, isTop, isLeft };
  }

  function drawOverlayOnCanvas(ctx, lines, outW, outH){
    if (!lines || lines.length === 0) return;

    const fontSize = computeFontSizePx(outW, outH);
    const lineGap = Math.round(fontSize * 1.18);
    const marginScalePct = clamp(Number(overlayMarginScale.value) || 100, 50, 200);
    const padScalePct = clamp(Number(overlayPadScale.value) || 100, 50, 200);

    const margin = Math.round(Math.min(outW, outH) * 0.018 * (marginScalePct/100));
    const pad = Math.round(fontSize * 0.55 * (padScalePct/100));

    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");
    ctx.save();

    ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif`;
    ctx.textBaseline = "top";
    ctx.textAlign = isLeft ? "left" : "right";

    // measure box
    let maxW = 0;
    for (const line of lines){
      const w = ctx.measureText(line).width;
      if (w > maxW) maxW = w;
    }
    const boxW = Math.round(maxW + pad*2);
    const boxH = Math.round(lines.length * lineGap + pad*2 - (lineGap - fontSize));

    const x = isLeft ? margin : (outW - margin);
    const y = isTop ? margin : (outH - margin - boxH);

    const boxX = isLeft ? x : (x - boxW);

    // bg box
    if (overlayBoxEnable.checked){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = Math.max(1, Math.round(fontSize * 0.06));
      roundRect(ctx, boxX, y, boxW, boxH, Math.round(fontSize * 0.6));
      ctx.fill();
      ctx.stroke();
    }

    // stroke/shadow
    if (overlayStrokeEnable.checked){
      ctx.shadowColor = "rgba(0,0,0,.85)";
      ctx.shadowBlur = Math.round(fontSize * 0.45);
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = "#fff";
    const textX = isLeft ? (boxX + pad) : (boxX + boxW - pad);
    let ty = y + pad;
    for (const line of lines){
      if (overlayStrokeEnable.checked){
        ctx.save();
        ctx.lineWidth = Math.max(2, Math.round(fontSize * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,.65)";
        ctx.strokeText(line, textX, ty);
        ctx.restore();
      }
      ctx.fillText(line, textX, ty);
      ty += lineGap;
    }

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function updateLiveOverlay(){
    if (!liveOverlayEnable.checked){
      liveOverlayBox.style.display = "none";
      return;
    }
    const d = getSelectedDate();
    if (!d){
      liveOverlayBox.style.display = "none";
      return;
    }
    const lines = buildOverlayLines(d);
    if (!lines.length){
      liveOverlayBox.style.display = "none";
      return;
    }
    // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ö‡∏ô‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß: ‡πÄ‡∏≠‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö overlayPos
    const pos = overlayPos.value || "tr";
    const isTop = (pos === "tl" || pos === "tr");
    const isLeft = (pos === "tl" || pos === "bl");
    const parent = document.getElementById("liveOverlay");
    parent.style.alignItems = isTop ? "flex-start" : "flex-end";
    parent.style.justifyContent = isLeft ? "flex-start" : "flex-end";

    liveOverlayBox.style.display = "block";
    liveOverlayBox.textContent = lines.join("\n");
  }

  /* =========================
     EXIF orientation fix (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
  ========================== */
  async function getExifOrientation(file){
    try{
      if (!file || !file.type || !file.type.toLowerCase().includes("jpeg")) return 1;
      const buf = await file.arrayBuffer();
      const view = new DataView(buf);

      if (view.getUint16(0, false) !== 0xFFD8) return 1;
      let offset = 2;
      const length = view.byteLength;

      while (offset < length){
        if (view.getUint8(offset) !== 0xFF) break;
        const marker = view.getUint16(offset, false);
        offset += 2;

        if (marker === 0xFFE1){
          offset += 2; // segment length
          if (view.getUint32(offset, false) !== 0x45786966) return 1;
          offset += 6;

          const tiffOffset = offset;
          const endianness = view.getUint16(tiffOffset, false);
          const little = (endianness === 0x4949);
          if (!little && endianness !== 0x4D4D) return 1;

          const getU16 = (o) => view.getUint16(o, little);
          const getU32 = (o) => view.getUint32(o, little);

          if (getU16(tiffOffset + 2) !== 0x002A) return 1;

          const ifd0Offset = getU32(tiffOffset + 4);
          let dirOffset = tiffOffset + ifd0Offset;
          if (dirOffset < 0 || dirOffset > length - 2) return 1;

          const entries = getU16(dirOffset);
          dirOffset += 2;

          for (let i=0;i<entries;i++){
            const entryOffset = dirOffset + i*12;
            if (entryOffset + 12 > length) break;
            const tag = getU16(entryOffset);
            if (tag === 0x0112){
              const type = getU16(entryOffset + 2);
              const count = getU32(entryOffset + 4);
              if (type !== 3 || count !== 1) return 1;
              const valOffset = entryOffset + 8;
              const orient = getU16(valOffset);
              return (orient >= 1 && orient <= 8) ? orient : 1;
            }
          }
          return 1;
        } else {
          if (offset + 2 > length) break;
          const size = view.getUint16(offset, false);
          offset += size;
        }
      }
      return 1;
    } catch (e){
      addLog(`getExifOrientation fallback: ${String(e.message || e)}`);
      return 1;
    }
  }

  async function blobToImage(blob){
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const im = new Image();
      im.onload = () => { resolve({ im, url }); };
      im.onerror = () => { try{ URL.revokeObjectURL(url);}catch{}; reject(new Error("Image onerror(blobUrl)")); };
      im.src = url;
    });
  }

  function drawWithOrientationToCanvas(img, orientation){
    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const c = document.createElement("canvas");
    const cctx = c.getContext("2d");

    if ([5,6,7,8].includes(orientation)){
      c.width = h; c.height = w;
    } else {
      c.width = w; c.height = h;
    }

    cctx.save();
    switch (orientation){
      case 2: cctx.translate(w, 0); cctx.scale(-1, 1); break;
      case 3: cctx.translate(w, h); cctx.rotate(Math.PI); break;
      case 4: cctx.translate(0, h); cctx.scale(1, -1); break;
      case 5: cctx.rotate(0.5*Math.PI); cctx.scale(1, -1); break;
      case 6: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); break;
      case 7: cctx.translate(h, 0); cctx.rotate(0.5*Math.PI); cctx.scale(-1, 1); break;
      case 8: cctx.translate(0, w); cctx.rotate(-0.5*Math.PI); break;
      default: break;
    }
    cctx.drawImage(img, 0, 0);
    cctx.restore();
    return c;
  }

  function drawContain(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.min(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  function drawCover(ctx, src, outW, outH){
    ctx.clearRect(0,0,outW,outH);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,outW,outH);

    const sw = src.width, sh = src.height;
    const scale = Math.max(outW / sw, outH / sh);
    const dw = Math.round(sw * scale);
    const dh = Math.round(sh * scale);
    const dx = Math.round((outW - dw) / 2);
    const dy = Math.round((outH - dh) / 2);
    ctx.drawImage(src, 0,0, sw,sh, dx,dy, dw,dh);
  }

  /* =========================
     Session Gallery (‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ)
  ========================== */
  const photos = []; // {id, blob, type, fromCamera, capturedAt, exifOrientation, thumbUrl, correctedCacheCanvas, lastPreviewUrl}
  let activePhotoId = null;

  function updateGalleryUI(){
    thumbStrip.innerHTML = "";
    if (photos.length === 0){
      const empty = document.createElement("div");
      empty.className = "pill";
      empty.style.opacity = ".85";
      empty.textContent = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ ‚Äî ‡∏Å‡∏î‡∏ä‡∏±‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡πå ‡∏´‡∏£‡∏∑‡∏≠ Import";
      thumbStrip.appendChild(empty);
      btnDownloadAll.disabled = true;
      pillCount.textContent = "0 ‡∏£‡∏π‡∏õ";
      return;
    }

    photos.forEach((p, idx) => {
      const div = document.createElement("div");
      div.className = "thumb" + (p.id === activePhotoId ? " active" : "");
      div.title = "‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß/‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î";
      div.dataset.id = p.id;

      const img = document.createElement("img");
      img.alt = `thumb ${idx+1}`;
      img.src = p.thumbUrl || "";
      div.appendChild(img);

      const badge = document.createElement("div");
      badge.className = "idx";
      badge.textContent = String(idx+1);
      div.appendChild(badge);

      div.addEventListener("click", () => openPreview(p.id));
      thumbStrip.appendChild(div);
    });

    btnDownloadAll.disabled = photos.length === 0;
    pillCount.textContent = `${photos.length} ‡∏£‡∏π‡∏õ`;
  }

  async function generateThumbnailForPhoto(p){
    try{
      const { im, url } = await blobToImage(p.blob);
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected; // cache (‡∏ä‡πà‡∏ß‡∏¢ render ‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô)
      try { URL.revokeObjectURL(url); } catch {}

      const maxSide = 260;
      const tw = corrected.width;
      const th = corrected.height;
      const scale = Math.min(1, maxSide / Math.max(tw, th));
      const cw = Math.max(1, Math.round(tw * scale));
      const ch = Math.max(1, Math.round(th * scale));
      const tcan = document.createElement("canvas");
      tcan.width = cw;
      tcan.height = ch;
      const tctx = tcan.getContext("2d");
      tctx.drawImage(corrected, 0,0, tw,th, 0,0, cw,ch);

      // thumb as dataURL (‡∏á‡πà‡∏≤‡∏¢+‡πÄ‡∏£‡πá‡∏ß)
      p.thumbUrl = tcan.toDataURL("image/jpeg", 0.85);
      addLog(`üß© thumb ok: ${p.id} ${cw}x${ch}`);
    } catch (e){
      addLog(`thumb failed: ${String(e.message || e)}`);
      p.thumbUrl = "";
    }
    updateGalleryUI();
  }

  async function addPhotoFromBlob(blob, {fromCamera=false, capturedAt=null, exifOrientation=1} = {}){
    const id = `p_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const p = {
      id,
      blob,
      type: blob.type || "image/jpeg",
      fromCamera: !!fromCamera,
      capturedAt: capturedAt || new Date(),
      exifOrientation,
      thumbUrl: "",
      correctedCacheCanvas: null,
      lastPreviewUrl: ""
    };
    photos.push(p);
    activePhotoId = id;
    updateGalleryUI();
    await generateThumbnailForPhoto(p);
    showToast(fromCamera ? "üì∏ ‡∏ñ‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‚úÖ" : "üñºÔ∏è ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‚úÖ");
    updateGalleryUI();
  }

  async function addPhotosFromFiles(fileList){
    const files = Array.from(fileList || []).filter(Boolean);
    if (files.length === 0) return;

    setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏π‡∏õ...", `0 / ${files.length}`, 0);

    for (let i=0;i<files.length;i++){
      const f = files[i];
      try{
        const orient = await getExifOrientation(f);
        await addPhotoFromBlob(f, { fromCamera:false, capturedAt:new Date(), exifOrientation: orient });
      } catch (e){
        addLog(`add file failed: ${f.name} ${String(e.message || e)}`);
      }
      const pct = Math.round(((i+1)/files.length)*100);
      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏π‡∏õ...", `${i+1} / ${files.length}`, pct);
    }
    setBusy(false);
  }

  function findPhotoIndexById(id){
    return photos.findIndex(p => p.id === id);
  }
  function getActivePhoto(){
    if (!activePhotoId) return null;
    return photos.find(p => p.id === activePhotoId) || null;
  }

  function removePhotoById(id){
    const idx = findPhotoIndexById(id);
    if (idx < 0) return;
    const p = photos[idx];
    try{
      if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl);
    } catch {}
    photos.splice(idx, 1);
    if (photos.length === 0){
      activePhotoId = null;
    } else {
      const nextIdx = Math.min(idx, photos.length-1);
      activePhotoId = photos[nextIdx].id;
    }
    updateGalleryUI();
    showToast("‡∏•‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏•‡πâ‡∏ß");
  }

  /* =========================
     Render (Preview/Download) per photo
  ========================== */
  async function getCorrectedCanvasForPhoto(p){
    if (p.correctedCacheCanvas) return p.correctedCacheCanvas;

    const { im, url } = await blobToImage(p.blob);
    try{
      const orient = p.fromCamera ? 1 : (p.exifOrientation || 1);
      const corrected = (orient === 1) ? (() => {
        const c = document.createElement("canvas");
        c.width = im.naturalWidth;
        c.height = im.naturalHeight;
        c.getContext("2d").drawImage(im, 0, 0);
        return c;
      })() : drawWithOrientationToCanvas(im, orient);

      p.correctedCacheCanvas = corrected;
      return corrected;
    } finally {
      try{ URL.revokeObjectURL(url); } catch {}
    }
  }

  async function ensureAddressLazy(){
    if (!enableLocation.checked) return;
    if (!hasValidLatLng()) return;
    if (!showAddress.checked) return;
    if (addressText) return;

    const lat = Number(latEl.value);
    const lng = Number(lngEl.value);
    const key = `${lat.toFixed(6)},${lng.toFixed(6)}|addr`;
    if (addressCacheKey === key && addressText) return;

    try{
      addressText = await reverseGeocode(lat, lng);
      addressCacheKey = key;
    } catch (e){
      addLog(`reverseGeocode(lazy) failed: ${String(e.message || e)}`);
    }
  }

  function getOutputDims(srcW, srcH){
    if (outputMode.value === "original"){
      return { outW: srcW, outH: srcH, mode: "original" };
    }
    const { w, h } = parseOutputSize();
    return { outW: w, outH: h, mode: "preset" };
  }

  async function renderPhotoToBlob(p, { mime=null, quality=null } = {}){
    const d = getSelectedDate();
    if (!d) throw new Error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤ (Settings > ‡πÄ‡∏ß‡∏•‡∏≤)");
    await ensureAddressLazy();

    const src = await getCorrectedCanvasForPhoto(p);
    const sw = src.width;
    const sh = src.height;

    const { outW, outH } = getOutputDims(sw, sh);
    const outCanvas = document.createElement("canvas");
    outCanvas.width = outW;
    outCanvas.height = outH;
    const ctx = outCanvas.getContext("2d", { alpha:false });

    if (outputMode.value === "original"){
      ctx.drawImage(src, 0,0, sw,sh, 0,0, outW,outH);
    } else {
      if (fitMode.value === "cover") drawCover(ctx, src, outW, outH);
      else drawContain(ctx, src, outW, outH);
    }

    const lines = buildOverlayLines(d);
    drawOverlayOnCanvas(ctx, lines, outW, outH);

    const finalMime = mime || defaultFormat.value || "image/jpeg";
    let q = quality;
    if (q == null) q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const blob = await new Promise((resolve, reject) => {
      outCanvas.toBlob((b) => {
        if (!b) return reject(new Error("toBlob failed"));
        resolve(b);
      }, finalMime, finalMime === "image/jpeg" ? q : undefined);
    });

    return {
      blob,
      outW, outH,
      linesCount: lines.length,
      mime: finalMime,
      quality: finalMime === "image/jpeg" ? q : null
    };
  }

  function buildFilename(baseDate, index1, ext, p){
    const yyyy = baseDate.getFullYear();
    const MM = pad2(baseDate.getMonth()+1);
    const dd = pad2(baseDate.getDate());
    const HH = pad2(baseDate.getHours());
    const mm = pad2(baseDate.getMinutes());
    const ss = pad2(baseDate.getSeconds());

    const idx = String(index1).padStart(2, "0");
    const stampNow = `${yyyy}${MM}${dd}_${HH}${mm}${ss}`;

    if (namePattern.value === "pt_capture_index" && p?.capturedAt){
      const cd = p.capturedAt;
      const cy = cd.getFullYear();
      const cM = pad2(cd.getMonth()+1);
      const cD = pad2(cd.getDate());
      const cH = pad2(cd.getHours());
      const cm = pad2(cd.getMinutes());
      const cs = pad2(cd.getSeconds());
      return `PT_${cy}${cM}${cD}_${cH}${cm}${cs}_${idx}.${ext}`;
    }

    return `PT_${stampNow}_${idx}.${ext}`;
  }

  function triggerDownload(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => { try{ URL.revokeObjectURL(url);}catch{} }, 1200);
  }

  /* =========================
     Preview modal flow
  ========================== */
  function showModal(backdropEl, on){
    backdropEl.style.display = on ? "flex" : "none";
    backdropEl.setAttribute("aria-hidden", on ? "false" : "true");
  }

  function openPreview(id){
    activePhotoId = id;
    updateGalleryUI();
    showModal(previewBackdrop, true);
    renderPreview();
  }

  async function renderPreview(){
    const p = getActivePhoto();
    if (!p){
      previewMeta.textContent = "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏π‡∏õ";
      return;
    }

    // sync preview options from default if user didn't change
    if (!dlFormat.value) dlFormat.value = defaultFormat.value;
    if (!dlQuality.value) dlQuality.value = String(jpgQuality.value);

    btnDownloadPhoto.disabled = true;
    btnDeletePhoto.disabled = true;
    btnReRender.disabled = true;
    previewMeta.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á render...";
    previewImg.src = "";

    try{
      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á render preview...", "‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà", null);

      const mime = dlFormat.value || "image/jpeg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const url = URL.createObjectURL(r.blob);

      // revoke old preview url
      try{ if (p.lastPreviewUrl) URL.revokeObjectURL(p.lastPreviewUrl); } catch {}
      p.lastPreviewUrl = url;

      previewImg.src = url;

      const idx = findPhotoIndexById(p.id);
      const ext = (mime === "image/png") ? "png" : "jpg";
      const filename = buildFilename(new Date(), idx+1, ext, p);

      previewMeta.textContent =
        `#${idx+1}\n` +
        `Source: ${p.fromCamera ? "Camera" : "File"} ‚Ä¢ EXIF: ${p.fromCamera ? "-" : (p.exifOrientation || 1)}\n` +
        `Output: ${r.outW}√ó${r.outH} ‚Ä¢ Lines: ${r.linesCount}\n` +
        `Format: ${mime === "image/png" ? "PNG" : `JPG (q=${r.quality})`}\n` +
        `Filename: ${filename}`;

      btnDownloadPhoto.disabled = false;
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;

      setBusy(false);
      updateLiveOverlay();
      addLog(`üñºÔ∏è preview ok: #${idx+1} ${r.outW}x${r.outH} ${mime}`);
    } catch (e){
      setBusy(false);
      previewMeta.textContent = `Render ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${String(e.message || e)}`;
      showToast("‚ùå Render ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      addLog(`preview render failed: ${String(e.message || e)}`);
      btnDeletePhoto.disabled = false;
      btnReRender.disabled = false;
    }
  }

  function closePreview(){
    showModal(previewBackdrop, false);
  }

  /* =========================
     Download All
  ========================== */
  async function downloadAll(){
    if (photos.length === 0) return;

    // Use settings default
    const mime = defaultFormat.value || "image/jpeg";
    const ext = (mime === "image/png") ? "png" : "jpg";
    const q = clamp(Number(jpgQuality.value) || 0.95, 0.5, 1);

    const batchDate = new Date();

    // Strategy:
    // 1) Folder Save (File System Access) if preferFolderSave + supported
    // 2) ZIP (JSZip) if enabled + available
    // 3) Multi-download fallback
    const canFS = !!window.showDirectoryPicker;

    try{
      setBusy(true, "Download All", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°...", 0);

      if (preferFolderSave.checked && canFS){
        const dir = await window.showDirectoryPicker({ mode: "readwrite" });
        addLog("üìÅ folder selected");

        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);

          const handle = await dir.getFileHandle(filename, { create:true });
          const writable = await handle.createWritable();
          await writable.write(r.blob);
          await writable.close();

          addLog(`‚úÖ saved: ${filename}`);
          setBusy(true, "Download All", `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß: ${i+1} / ${photos.length}`, Math.round(((i+1)/photos.length)*100));
        }

        setBusy(false);
        showToast("‚úÖ Download All ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß (‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå)");
        return;
      }

      if (zipFallback.checked && window.JSZip){
        const zip = new window.JSZip();
        for (let i=0;i<photos.length;i++){
          const p = photos[i];
          setBusy(true, "Download All (ZIP)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

          const r = await renderPhotoToBlob(p, { mime, quality: q });
          const filename = buildFilename(batchDate, i+1, ext, p);
          zip.file(filename, r.blob);
        }

        setBusy(true, "Download All (ZIP)", "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP...", 96);
        const zipBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
          const pct = clamp(Math.round(meta.percent), 0, 100);
          setBusy(true, "Download All (ZIP)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP... ${pct}%`, pct);
        });

        const zipName = `PT_${batchDate.getFullYear()}${pad2(batchDate.getMonth()+1)}${pad2(batchDate.getDate())}_${pad2(batchDate.getHours())}${pad2(batchDate.getMinutes())}${pad2(batchDate.getSeconds())}.zip`;
        triggerDownload(zipBlob, zipName);
        setBusy(false);
        showToast("‚úÖ Download All ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß (ZIP)");
        return;
      }

      // Fallback multi-download (‡∏≠‡∏≤‡∏à‡πÇ‡∏î‡∏ô block ‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)
      for (let i=0;i<photos.length;i++){
        const p = photos[i];
        setBusy(true, "Download All (fallback)", `‡∏Å‡∏≥‡∏•‡∏±‡∏á render: ${i+1} / ${photos.length}`, Math.round((i/photos.length)*100));

        const r = await renderPhotoToBlob(p, { mime, quality: q });
        const filename = buildFilename(batchDate, i+1, ext, p);
        triggerDownload(r.blob, filename);

        // ‡∏´‡∏¢‡∏∏‡∏î‡∏ô‡∏¥‡∏î‡∏ô‡∏∂‡∏á‡πÉ‡∏´‡πâ browser ‡πÑ‡∏°‡πà choke
        await new Promise(r => setTimeout(r, 180));
      }
      setBusy(false);
      showToast("‚úÖ Download All: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏µ‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå (fallback)");
    } catch (e){
      setBusy(false);
      showToast("‚ùå Download All ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      addLog(`downloadAll failed: ${String(e.message || e)}`);
    }
  }

  /* =========================
     Camera (getUserMedia + switch + torch)
  ========================== */
  let camStream = null;
  let currentFacing = "environment";
  let videoDevices = [];
  let selectedDeviceId = "";

  function setCamIndicator(ok){
    dotCam.className = "dot " + (ok ? "ok" : "err");
  }

  function isUserFacingNow(){
    // ‡∏ñ‡πâ‡∏≤ user ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å deviceId ‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡∏¢‡∏≤‡∏Å ‚Üí ‡πÉ‡∏ä‡πâ currentFacing ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡∏´‡∏•‡∏±‡∏Å
    return (currentFacing === "user");
  }

  function applyMirrorClass(){
    camVideo.classList.toggle("mirror", isUserFacingNow());
  }

  async function stopCamera(){
    try{
      if (camStream){
        camStream.getTracks().forEach(t => t.stop());
      }
    } catch {}
    camStream = null;
    camVideo.srcObject = null;
    btnTorch.disabled = true;
    btnTorch.classList.remove("on");
    setCamIndicator(false);
  }

  async function refreshDevices(){
    if (!navigator.mediaDevices?.enumerateDevices) return [];
    const all = await navigator.mediaDevices.enumerateDevices();
    videoDevices = all.filter(d => d.kind === "videoinput");
    addLog(`üéõÔ∏è devices: ${videoDevices.length} videoinput`);
    return videoDevices;
  }

  function getVideoTrack(){
    try{
      return camStream?.getVideoTracks?.()[0] || null;
    } catch { return null; }
  }

  async function refreshTorchSupport(){
    const track = getVideoTrack();
    if (!track) {
      btnTorch.disabled = true;
      btnTorch.classList.remove("on");
      return;
    }
    const caps = track.getCapabilities ? track.getCapabilities() : null;
    const supported = !!(caps && "torch" in caps);
    btnTorch.disabled = !supported;
    if (!supported){
      btnTorch.classList.remove("on");
      settings.torchOn = false;
      return;
    }
    // sync current state
    btnTorch.classList.toggle("on", !!settings.torchOn);
  }

  async function setTorch(on){
    const track = getVideoTrack();
    if (!track || !track.applyConstraints) throw new Error("torch not supported");
    await track.applyConstraints({ advanced: [{ torch: !!on }] });
    settings.torchOn = !!on;
    btnTorch.classList.toggle("on", !!on);
    writeSettings({ torchOn: !!on });
  }

  async function startCamera({ forceFacing=null, forceDeviceId=null } = {}){
    if (!navigator.mediaDevices?.getUserMedia){
      setCamIndicator(false);
      showToast("‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
      addLog("getUserMedia not supported");
      return;
    }

    try{
      await stopCamera();

      currentFacing = forceFacing || settings.preferredFacing || "environment";
      selectedDeviceId = forceDeviceId || settings.preferredDeviceId || "";

      const constraints = {
        video: {
          width: { ideal: 1920 },
          height:{ ideal: 1080 }
        },
        audio: false
      };

      if (selectedDeviceId){
        constraints.video.deviceId = { exact: selectedDeviceId };
      } else {
        constraints.video.facingMode = { ideal: currentFacing };
      }

      camStream = await navigator.mediaDevices.getUserMedia(constraints);
      camVideo.srcObject = camStream;

      // autoplay safety
      try { await camVideo.play(); } catch {}

      setCamIndicator(true);
      applyMirrorClass();

      // refresh list (after permission, labels will appear)
      try { await refreshDevices(); } catch {}

      // update torch button
      await refreshTorchSupport();

      // persist preference
      writeSettings({
        preferredFacing: currentFacing,
        preferredDeviceId: selectedDeviceId || ""
      });

      pillMode.textContent = (isUserFacingNow() ? "ü§≥ Front (mirror)" : "üì∑ Rear");
      addLog(`üì∑ camera started: facing=${currentFacing} deviceId=${selectedDeviceId ? "set" : "auto"}`);
      updateLiveOverlay();
    } catch (e){
      setCamIndicator(false);
      pillMode.textContent = "üì∑ Camera (blocked)";
      showToast("‚ùå ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô https + ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏•‡πâ‡∏≠‡∏á)");
      addLog(`camera start failed: ${String(e.message || e)}`);
    }
  }

  async function switchCamera(){
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏´‡∏•‡∏≤‡∏¢ device ‚Üí cycle deviceId
    try{
      await refreshDevices();
    } catch {}

    if (videoDevices.length >= 2){
      // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å deviceId ‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
      let idx = videoDevices.findIndex(d => d.deviceId === selectedDeviceId);
      idx = (idx < 0) ? 0 : idx;
      const next = videoDevices[(idx + 1) % videoDevices.length];
      selectedDeviceId = next.deviceId;

      // heuristic: label ‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ front/user? (‡∏´‡∏•‡∏±‡∏á permission)
      const label = (next.label || "").toLowerCase();
      const likelyFront = label.includes("front") || label.includes("user") || label.includes("facetime");
      currentFacing = likelyFront ? "user" : "environment";

      await startCamera({ forceFacing: currentFacing, forceDeviceId: selectedDeviceId });
      showToast("üîÑ ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
      return;
    }

    // fallback: toggle facingMode
    currentFacing = (currentFacing === "environment") ? "user" : "environment";
    selectedDeviceId = "";
    await startCamera({ forceFacing: currentFacing, forceDeviceId: "" });
    showToast("üîÑ ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á");
  }

  async function snapPhoto(){
    if (!camStream || !camVideo.videoWidth || !camVideo.videoHeight){
      showToast("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ñ‡πà‡∏≤‡∏¢ (‡∏•‡∏≠‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô)");
      // try to start camera from user gesture
      await startCamera({ forceFacing: currentFacing || "environment" });
      return;
    }

    const vw = camVideo.videoWidth;
    const vh = camVideo.videoHeight;

    const c = document.createElement("canvas");
    c.width = vw;
    c.height = vh;
    const cctx = c.getContext("2d", { alpha:false });

    // IMPORTANT: mirror saved result for front camera (‡∏ï‡∏≤‡∏° requirement)
    // - preview: mirrored via CSS
    // - saved: ‡∏ß‡∏≤‡∏î‡∏•‡∏á canvas ‡πÅ‡∏ö‡∏ö flip ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ overlay ‡∏ï‡∏≠‡∏ô render (overlay ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏î‡πâ‡∏≤‡∏ô)
    if (isUserFacingNow()){
      cctx.save();
      cctx.translate(vw, 0);
      cctx.scale(-1, 1);
      cctx.drawImage(camVideo, 0, 0, vw, vh);
      cctx.restore();
    } else {
      cctx.drawImage(camVideo, 0, 0, vw, vh);
    }

    // export raw capture as jpg (no EXIF)
    const rawBlob = await new Promise((resolve, reject) => {
      c.toBlob((b) => {
        if (!b) return reject(new Error("capture toBlob failed"));
        resolve(b);
      }, "image/jpeg", 0.95);
    });

    await addPhotoFromBlob(rawBlob, { fromCamera:true, capturedAt:new Date(), exifOrientation: 1 });
    pillMode.textContent = (isUserFacingNow() ? "ü§≥ Front (mirror)" : "üì∑ Rear");
  }

  /* =========================
     Leaflet map (in Settings)
  ========================== */
  let map = null;
  let mapMarker = null;

  function openMap(){
    if (!window.L){
      locStatus.textContent = "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (Leaflet) ‚Äî ‡∏ï‡∏£‡∏ß‡∏à‡πÄ‡∏ô‡πá‡∏ï/‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https";
      addLog("Leaflet not available: window.L is undefined");
      mapWrap.style.display = "none";
      return;
    }

    mapWrap.style.display = "block";
    const lat = hasValidLatLng() ? Number(latEl.value) : 13.7563;
    const lng = hasValidLatLng() ? Number(lngEl.value) : 100.5018;

    if (!map){
      map = L.map('map', { zoomControl: true }).setView([lat, lng], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);

      mapMarker = L.marker([lat, lng]).addTo(map);

      map.on('click', async (e) => {
        latEl.value = e.latlng.lat;
        lngEl.value = e.latlng.lng;
        mapMarker.setLatLng(e.latlng);
        addressText = "";
        if (!enableLocation.checked) enableLocation.checked = true;
        await refreshAddressIfNeeded();
        scheduleSave();
      });
    } else {
      map.setView([lat, lng], 15);
      if (mapMarker) mapMarker.setLatLng([lat, lng]);
    }

    setTimeout(() => map.invalidateSize(), 120);
  }

  function closeMap(){
    mapWrap.style.display = "none";
  }

  /* =========================
     UI wires
  ========================== */
  function updateLogUI(){
    logFab.style.display = enableLogPanel.checked ? "block" : "none";
    if (enableLogPanel.checked){
      logPre.textContent = logs.join("\n");
    } else {
      logDrawer.style.display = "none";
      logDrawer.setAttribute("aria-hidden", "true");
    }
  }

  function toggleLogDrawer(on){
    logDrawer.style.display = on ? "block" : "none";
    logDrawer.setAttribute("aria-hidden", on ? "false" : "true");
    if (on) logPre.textContent = logs.join("\n");
  }

  /* =========================
     Events
  ========================== */
  btnBusyClose.addEventListener("click", () => setBusy(false));

  btnSettings.addEventListener("click", () => {
    applySettingsToInputs();
    showModal(settingsBackdrop, true);
  });
  btnCloseSettings.addEventListener("click", () => showModal(settingsBackdrop, false));

  btnApplySettings.addEventListener("click", async () => {
    writeSettings(collectSettingsFromUI());
    showModal(settingsBackdrop, false);
    updateLiveOverlay();
    showToast("‚úÖ Apply/Save ‡πÅ‡∏•‡πâ‡∏ß");
    // ‡∏ñ‡πâ‡∏≤ location ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‚Üí refresh address ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà
    await refreshAddressIfNeeded();
  });

  btnResetSettings.addEventListener("click", async () => {
    writeSettings({ ...DEFAULT_SETTINGS, preferredFacing: settings.preferredFacing, preferredDeviceId: settings.preferredDeviceId, torchOn: false });
    showToast("‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡πà‡∏≤‡πÅ‡∏•‡πâ‡∏ß");
    await refreshAddressIfNeeded();
  });

  // settings inputs -> debounced save
  const bindSave = (el, evt="change") => el.addEventListener(evt, () => {
    updateOutputUI();
    updateFontUI();
    updateTimeMini();
    refreshLocMini();
    updatePills();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(useNow, "change");
  bindSave(customTime, "input");
  bindSave(timeFormat, "change");
  bindSave(timeLines, "change");

  btnSetNow.addEventListener("click", () => {
    const now = new Date();
    const v = `${now.getFullYear()}-${pad2(now.getMonth()+1)}-${pad2(now.getDate())}T${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
    customTime.value = v;
    useNow.checked = true;
    updateTimeMini();
    updateLiveOverlay();
    scheduleSave();
  });

  bindSave(outputMode, "change");
  bindSave(outputSize, "change");
  bindSave(fitMode, "change");

  bindSave(overlayPos, "change");
  bindSave(overlayBoxEnable, "change");
  bindSave(overlayStrokeEnable, "change");
  bindSave(overlayMarginScale, "input");
  bindSave(overlayPadScale, "input");
  bindSave(liveOverlayEnable, "change");

  bindSave(fontAuto, "change");
  bindSave(fontScale, "input");
  bindSave(fontPx, "input");

  enableLocation.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showLatLng.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  showAddress.addEventListener("change", async () => { await refreshAddressIfNeeded(); scheduleSave(); });
  latEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });
  lngEl.addEventListener("input", async () => { addressText=""; await refreshAddressIfNeeded(); scheduleSave(); });

  btnUseGPS.addEventListener("click", async () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();

    if (!navigator.geolocation){
      locStatus.textContent = "‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå/‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö GPS";
      addLog("geolocation not supported");
      showToast("GPS ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö");
      return;
    }

    locStatus.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏≤‡∏Å GPS...";
    navigator.geolocation.getCurrentPosition(async (pos) => {
      latEl.value = pos.coords.latitude;
      lngEl.value = pos.coords.longitude;
      addressText = "";
      await refreshAddressIfNeeded();
      scheduleSave();
      showToast("üìç ‡πÑ‡∏î‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß");
    }, (err) => {
      locStatus.textContent = "‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: " + (err?.message || "unknown error") + "\n(‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https ‡πÅ‡∏•‡∏∞‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï location)";
      addLog(`geolocation error: ${String(err?.message || err)}`);
      showToast("‚ùå ‡∏Ç‡∏≠‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
    }, { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 });
  });

  btnPickOnMap.addEventListener("click", () => {
    if (!enableLocation.checked) enableLocation.checked = true;
    scheduleSave();
    openMap();
  });

  btnConfirmMap.addEventListener("click", async () => {
    if (!hasValidLatLng()){
      locStatus.textContent = "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á";
      return;
    }
    closeMap();
    await refreshAddressIfNeeded();
    scheduleSave();
    showToast("‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß");
  });

  btnCloseMap.addEventListener("click", closeMap);

  btnSearchPlace.addEventListener("click", async () => {
    const q = (placeQuery.value || "").trim();
    if (!q) return;
    if (!enableLocation.checked) enableLocation.checked = true;

    locStatus.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà...";
    try{
      const r = await forwardGeocode(q);
      if (!r){
        locStatus.textContent = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà";
        showToast("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà");
        return;
      }
      latEl.value = r.lat;
      lngEl.value = r.lng;
      addressText = r.display_name || "";
      await refreshAddressIfNeeded();
      scheduleSave();

      if (map && window.L){
        map.setView([r.lat, r.lng], 17);
        if (!mapMarker) mapMarker = L.marker([r.lat, r.lng]).addTo(map);
        mapMarker.setLatLng([r.lat, r.lng]);
      }
      showToast("üîé ‡∏û‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß");
    } catch (e){
      locStatus.textContent = "‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô https)";
      addLog(`forwardGeocode failed: ${String(e.message || e)}`);
      showToast("‚ùå ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
    }
  });

  bindSave(defaultFormat, "change");
  bindSave(jpgQuality, "input");
  bindSave(namePattern, "change");
  bindSave(preferFolderSave, "change");
  bindSave(zipFallback, "change");

  enableLogPanel.addEventListener("change", () => { updateLogUI(); scheduleSave(); });
  btnClearLog.addEventListener("click", () => {
    logs.length = 0;
    logPre.textContent = "";
    addLog("log cleared");
    showToast("‡∏•‡πâ‡∏≤‡∏á Log ‡πÅ‡∏•‡πâ‡∏ß");
  });

  btnToggleLog.addEventListener("click", () => {
    const on = (logDrawer.style.display !== "block");
    toggleLogDrawer(on);
  });
  btnCloseLog.addEventListener("click", () => toggleLogDrawer(false));

  // Camera controls
  btnSwitchCam.addEventListener("click", switchCamera);
  btnTorch.addEventListener("click", async () => {
    if (btnTorch.disabled){
      showToast("Torch ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ö‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ");
      return;
    }
    try{
      const next = !btnTorch.classList.contains("on");
      await setTorch(next);
      showToast(next ? "üî¶ Torch ON" : "üî¶ Torch OFF");
      addLog(`torch ${next ? "on" : "off"}`);
    } catch (e){
      showToast("Torch ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ");
      addLog(`torch failed: ${String(e.message || e)}`);
    }
  });

  // Shutter / Import / Download All
  btnShutter.addEventListener("click", snapPhoto);

  btnImport.addEventListener("click", () => {
    fileInput.value = "";
    fileInput.click();
  });

  fileInput.addEventListener("change", async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    await addPhotosFromFiles(files);
  });

  btnDownloadAll.addEventListener("click", downloadAll);

  // Preview modal controls
  btnClosePreview.addEventListener("click", closePreview);

  btnReRender.addEventListener("click", renderPreview);

  dlFormat.addEventListener("change", () => {
    // sync quality field enable
    renderPreview();
  });

  dlQuality.addEventListener("input", () => {
    // don't spam render too much
  });

  btnDownloadPhoto.addEventListener("click", async () => {
    const p = getActivePhoto();
    if (!p) return;

    try{
      const idx = findPhotoIndexById(p.id);
      const mime = dlFormat.value || "image/jpeg";
      const ext = (mime === "image/png") ? "png" : "jpg";
      const q = clamp(Number(dlQuality.value) || 0.95, 0.5, 1);

      setBusy(true, "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...", "‡∏Å‡∏≥‡∏•‡∏±‡∏á render ‡πÑ‡∏ü‡∏•‡πå", null);
      const r = await renderPhotoToBlob(p, { mime, quality: q });
      const filename = buildFilename(new Date(), idx+1, ext, p);
      triggerDownload(r.blob, filename);
      setBusy(false);

      showToast("‚¨áÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡πâ‡∏ß");
      addLog(`‚¨áÔ∏è download single: ${filename}`);
    } catch (e){
      setBusy(false);
      showToast("‚ùå ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      addLog(`download single failed: ${String(e.message || e)}`);
    }
  });

  btnDeletePhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    removePhotoById(p.id);
    if (photos.length === 0) closePreview();
    else renderPreview();
  });

  btnPrevPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx <= 0) return;
    openPreview(photos[idx-1].id);
  });

  btnNextPhoto.addEventListener("click", () => {
    const p = getActivePhoto();
    if (!p) return;
    const idx = findPhotoIndexById(p.id);
    if (idx >= photos.length-1) return;
    openPreview(photos[idx+1].id);
  });

  // Close modals by tapping backdrop
  previewBackdrop.addEventListener("click", (e) => {
    if (e.target === previewBackdrop) closePreview();
  });
  settingsBackdrop.addEventListener("click", (e) => {
    if (e.target === settingsBackdrop) showModal(settingsBackdrop, false);
  });

  // Basic keyboard support (desktop)
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (settingsBackdrop.style.display === "flex") showModal(settingsBackdrop, false);
      if (previewBackdrop.style.display === "flex") closePreview();
      if (logDrawer.style.display === "block") toggleLogDrawer(false);
    }
  });

  window.addEventListener("beforeunload", () => {
    try{ stopCamera(); } catch {}
  });

  /* =========================
     Boot
  ========================== */
  function boot(){
    addLog("boot v3.0 camera-first");
    applySettingsToUI();
    updateGalleryUI();
    updateLogUI();
    refreshLocMini();
    updateTimeMini();
    updateLiveOverlay();

    // camera-first: ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    startCamera({ forceFacing: settings.preferredFacing || "environment", forceDeviceId: settings.preferredDeviceId || "" });
  }

  boot();
})();
</script>
</body>
</html>
